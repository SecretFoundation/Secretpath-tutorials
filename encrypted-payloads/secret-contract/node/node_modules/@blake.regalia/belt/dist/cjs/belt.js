"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.die = exports.remove = exports.shuffle = exports.crypto_random_int = exports.random_int = exports.crypto_random = exports.defer_many = exports.defer = exports.microtask = exports.forever = exports.with_timeout = exports.timeout_exec = exports.timeout = exports.fodemtv = exports.oderom = exports.oderaf = exports.oderac = exports.oder = exports.odem = exports.ofe = exports.ode = exports.odv = exports.odk = exports.oda = exports.oc = exports.escape_regex = exports.deduplicate = exports.interjoin = exports.fold = exports.is_dict_es = exports.is_dict = exports.is_array = exports.is_bytes = exports.pascal = exports.snake = exports.proper = exports.F_IDENTITY = exports.F_NOOP = exports.XG_32 = exports.XG_16 = exports.XG_8 = exports.__UNDEFINED = exports.ATU8_NIL = void 0;
/**
 * Utility nil buffer constant
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
exports.ATU8_NIL = new Uint8Array(0);
// eslint-disable-next-line @typescript-eslint/naming-convention
exports.__UNDEFINED = void 0;
/**
 * The value `8n`
 */
exports.XG_8 = 8n;
/**
 * The value `16n`
 */
exports.XG_16 = 8n;
/**
 * The value `32n`
 */
exports.XG_32 = 8n;
/**
 * The frequently-used "no-operation" function
 */
const F_NOOP = () => { }; // eslint-disable-line
exports.F_NOOP = F_NOOP;
/**
 * The seldomnly-used "identity" function
 */
const F_IDENTITY = (w) => w; // eslint-disable-line
exports.F_IDENTITY = F_IDENTITY;
/**
 * Creates a proper-case string
 */
const proper = (s_input) => s_input ? s_input.split(/[\s_]+/g).map(s => s[0].toUpperCase() + s.slice(1)).join(' ') : s_input;
exports.proper = proper;
/**
 * Converts given identifier to "snake_case"
 */
const snake = (s_ident) => s_ident.toUpperCase() === s_ident
    // depending on upper or mixed case
    ? s_ident.toLowerCase().replace(/[^a-z0-9$]+/g, '_')
    : s_ident.replace(/(?<!^)(?:[^a-zA-Z0-9$]*([A-Z])|[^a-zA-Z0-9$]+)/g, (s_ignore, s_cap) => '_' + (s_cap || '')).toLowerCase();
exports.snake = snake;
/**
 * Converts given identifier to "PascalCase"
 */
// if all uppercase; make lower
const pascal = (s_ident) => (s_ident.toUpperCase() === s_ident ? (0, exports.pascal)(s_ident.toLowerCase()) : s_ident)
    // convert to pascal
    .replace(/(?:^|[^A-Za-z0-9$])([\w0-9$])/g, (s_ignore, s_letter) => s_letter.toUpperCase());
exports.pascal = pascal;
/**
 * Simple test for whether a value is a Uint8Array or not
 */
const is_bytes = (z) => z instanceof Uint8Array;
exports.is_bytes = is_bytes;
/**
 * Simple test for whether a value is an array or not
 */
const is_array = (z) => Array.isArray(z);
exports.is_array = is_array;
/**
 * Simple test for whether a deserialized JSON value is a plain object (dict) or not
 */
const is_dict = (z) => z ? 'object' === typeof z && !(0, exports.is_array)(z) : false;
exports.is_dict = is_dict;
/**
 * Strict test for whether an ES object is a plain object (dict) or not
 */
const is_dict_es = (z) => Object === z?.constructor;
exports.is_dict_es = is_dict_es;
/**
 * Fold array into an object
 */
const fold = (a_in, f_fold) => {
    const h_out = {};
    let i_each = 0;
    for (const z_each of a_in) {
        Object.assign(h_out, f_fold(z_each, i_each++));
    }
    return h_out;
};
exports.fold = fold;
/**
 * Creates a new array by inserting an item in between every existing item
 */
const interjoin = (a_input, w_insert) => {
    const a_output = [];
    for (let i_each = 0, nl_items = a_input.length; i_each < nl_items - 1; i_each++) {
        a_output.push(a_input[i_each]);
        a_output.push(w_insert);
    }
    if (a_input.length)
        a_output.push(a_input.at(-1));
    return a_output;
};
exports.interjoin = interjoin;
/**
 * Removes duplicates from an array, keeping only the first occurrence.
 * @param z_identify - if specified and a string, identifies the key of each item to use as an identifier
 * if specified and a function, used as a callback to produce the comparison key
 * if omitted, compares items using full equality `===`
 */
const deduplicate = (a_items, z_identify) => {
    // compare items exactly by default
    let a_keys = a_items;
    // identify argument
    if (z_identify) {
        // use object property
        if ('string' === typeof z_identify) {
            a_keys = a_items.map(w => w[z_identify]);
        }
        // use identity function
        else if ('function' === typeof z_identify) {
            a_keys = a_items.map(z_identify);
        }
        else {
            throw new TypeError(`Invalid identifier argument value: ${String(z_identify)}`);
        }
    }
    // prep keys set
    const as_keys = new Set();
    // prep output
    const a_unique = [];
    // each item in list
    for (let i_item = 0, nl_items = a_items.length; i_item < nl_items; i_item++) {
        const w_key = a_keys[i_item];
        // already in set; skip
        if (as_keys.has(w_key))
            continue;
        // add to keys set
        as_keys.add(w_key);
        // add to items
        a_unique.push(a_items[i_item]);
    }
    return a_unique;
};
exports.deduplicate = deduplicate;
/**
 * Escape all special regex characters to turn a string into a verbatim match pattern
 * @param s_input input string
 * @returns escaped string ready for RegExp constructor
 */
const escape_regex = (s_input) => s_input.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
exports.escape_regex = escape_regex;
/**
 * Typed alias to `Object.create`
 */
exports.oc = Object.create;
/**
 * Typed alias to `Object.assign`
 */
exports.oda = Object.assign;
/**
 * Typed alias to `Object.keys`
 */
exports.odk = Object.keys;
/**
 * Typed alias to `Object.values`
 */
exports.odv = Object.values;
/**
 * Typed alias to `Object.entries`
 */
exports.ode = Object.entries;
/**
 * Typed alias to `Object.fromEntries`
 */
exports.ofe = Object.fromEntries;
/**
 * Map object entries
 */
const odem = (h_object, f_map) => (0, exports.ode)(h_object).map(f_map);
exports.odem = odem;
/**
 * Reduce object entries to an arbitrary type
 */
const oder = (h_thing, f_reduce, w_init) => (0, exports.ode)(h_thing).reduce(f_reduce, w_init);
exports.oder = oder;
/**
 * Reduce object entries to an array via concatenation (with filtering)
 */
const oderac = (h_thing, f_concat, b_add_undefs = false) => (0, exports.oder)(h_thing, (a_out, [si_key, w_value], i_entry) => {
    // invoke callback and capture return value
    const w_add = f_concat(si_key, w_value, i_entry);
    // add result to array iff not undefined or if undefined values are explictly allowed
    if (exports.__UNDEFINED !== w_add || b_add_undefs)
        a_out.push(w_add);
    return a_out;
}, []);
exports.oderac = oderac;
/**
 * Reduce object entries to an array via flattening
 */
const oderaf = (h_thing, f_concat) => (0, exports.oder)(h_thing, (a_out, [si_key, w_value], i_entry) => [
    ...a_out,
    ...f_concat(si_key, w_value, i_entry),
], []);
exports.oderaf = oderaf;
/**
 * Reduce object entries to an object via merging
 */
const oderom = (h_thing, f_merge) => (0, exports.oder)(h_thing, (h_out, [si_key, w_value], i_index) => ({
    ...h_out,
    ...f_merge(si_key, w_value, i_index),
}), {});
exports.oderom = oderom;
/**
 * Reduce object entries to an object via transforming value function
 */
const fodemtv = (h_thing, f_transform) => (0, exports.ofe)((0, exports.odem)(h_thing, ([si_key, w_value], i_entry) => [si_key, f_transform(w_value, si_key, i_entry)]));
exports.fodemtv = fodemtv;
/**
 * Promise-based version of `setTimeout()`
 */
const timeout = (xt_wait) => new Promise((fk_resolve) => {
    setTimeout(() => {
        fk_resolve(exports.__UNDEFINED);
    }, xt_wait);
});
exports.timeout = timeout;
const timeout_exec = (xt_wait, f_attempt) => new Promise((fk_resolve, fe_reject) => {
    // infinite
    if (!Number.isFinite(xt_wait)) {
        void f_attempt?.().then(w => fk_resolve([w, 0])).catch(e => fe_reject(e));
        return;
    }
    let b_timed_out = false;
    // attempt callback
    f_attempt?.()
        .then((w_return) => {
        // already timed out
        if (b_timed_out)
            return;
        // cancel pending timer
        clearTimeout(i_pending);
        // resolve promise
        fk_resolve([w_return, 0]);
    })
        .catch((e_attempt) => {
        fe_reject(e_attempt);
    });
    // start waiting
    const i_pending = setTimeout(() => {
        // mark as timed out
        b_timed_out = true;
        // resolve promise
        fk_resolve([exports.__UNDEFINED, 1]);
    }, xt_wait);
});
exports.timeout_exec = timeout_exec;
const with_timeout = (g_with) => new Promise((fk_resolve, fe_reject) => {
    // state of completion
    let b_complete = false;
    // timer
    setTimeout(() => {
        // already completed
        if (b_complete)
            return;
        // now complete
        b_complete = true;
        // reject
        fe_reject(g_with.trip());
    }, g_with.duration);
    // run task
    g_with.run().then((w_value) => {
        // already failed
        if (b_complete)
            return;
        // now complete
        b_complete = true;
        // resolve
        fk_resolve(w_value);
    }).catch(fe_reject);
});
exports.with_timeout = with_timeout;
/**
 * A Promise that never fulfills nor rejects
 */
const forever = (w_type) => new Promise(exports.F_NOOP);
exports.forever = forever;
/**
 * Promse-based version of `queueMicrotask()`
 */
const microtask = () => new Promise((fk_resolve) => {
    queueMicrotask(() => {
        fk_resolve(exports.__UNDEFINED);
    });
});
exports.microtask = microtask;
const defer = () => {
    let fk_resolve;
    let fe_reject;
    const dp_promise = new Promise((fk, fe) => {
        fk_resolve = fk;
        fe_reject = fe;
    });
    return [dp_promise, (w_return, e_reject) => {
            if (e_reject) {
                fe_reject(e_reject);
            }
            else {
                fk_resolve(w_return);
            }
        }];
};
exports.defer = defer;
const defer_many = (h_input) => {
    const h_mapped = (0, exports.fodemtv)(h_input, () => (0, exports.defer)());
    return {
        promises: (0, exports.fodemtv)(h_mapped, a_defer => a_defer[0]),
        resolve(h_resolves) {
            for (const si_key in h_resolves) {
                h_mapped[si_key]?.[1](h_resolves[si_key]);
            }
        },
        reject(h_rejects) {
            for (const si_key in h_rejects) {
                h_mapped[si_key]?.[1](exports.__UNDEFINED, h_rejects[si_key]);
            }
        },
    };
};
exports.defer_many = defer_many;
/**
 * Cryptographically strong random number
 */
const crypto_random = () => crypto.getRandomValues(new Uint32Array(1))[0] / (2 ** 32);
exports.crypto_random = crypto_random;
/**
 * Generate a random int within a given range
 */
const random_int = (x_a, x_b = 0) => {
    const x_min = Math.floor(Math.min(x_a, x_b));
    const x_max = Math.ceil(Math.max(x_a, x_b));
    // confine to range
    return Math.floor(Math.random() * (x_max - x_min)) + x_min;
};
exports.random_int = random_int;
/**
 * Generate a cryptographically strong random int within a given range
 */
const crypto_random_int = (x_a, x_b = 0) => {
    const x_min = Math.floor(Math.min(x_a, x_b));
    const x_max = Math.ceil(Math.max(x_a, x_b));
    // confine to range
    return Math.floor((0, exports.crypto_random)() * (x_max - x_min)) + x_min;
};
exports.crypto_random_int = crypto_random_int;
/**
 * Shuffles an array
 */
const shuffle = (a_items, f_random = exports.random_int) => {
    let i_item = a_items.length;
    while (i_item > 0) {
        const i_swap = f_random(--i_item);
        const w_item = a_items[i_item];
        a_items[i_item] = a_items[i_swap];
        a_items[i_swap] = w_item;
    }
    return a_items;
};
exports.shuffle = shuffle;
/**
 * Removes the first occurrence of the given item from the array
 * @param a_items
 * @param w_item
 * @returns
 */
const remove = (a_items, w_item) => {
    const i_item = a_items.indexOf(w_item);
    if (i_item >= 0)
        a_items.splice(i_item, 1);
    return a_items;
};
exports.remove = remove;
/**
 * Throws an error, accepting an optional piece of data to attach to the object
 * @param s_msg
 * @param w_data
 */
const die = (s_msg, w_data) => {
    throw (0, exports.oda)(Error(s_msg), { data: w_data });
};
exports.die = die;
//# sourceMappingURL=belt.js.map