/**
 * Utility nil buffer constant
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
const ATU8_NIL = new Uint8Array(0);
/**
 * The frequently-used "no-operation" function
 */
const F_NOOP = () => { }; // eslint-disable-line
/**
 * The seldomnly-used "identity" function
 */
const F_IDENTITY = (w) => w; // eslint-disable-line
/**
 * Creates a proper-case string
 */
const proper = (s_input) => s_input.split(/[\s_]+/g).map(s => s[0].toUpperCase() + s.slice(1)).join(' ');
/**
 * Simple test for whether a deserialized JSON value is a plain object (dict) or not
 */
const is_dict = (z) => z ? 'object' === typeof z && !Array.isArray(z) : false;
/**
 * More advanced test for whether an ES object is a plain object (dict) or not
 */
const is_dict_es = (z) => z ? 'object' === typeof z && Object === z.constructor : false;
/**
 * Fold array into an object
 */
const fold = (a_in, f_fold) => {
    const h_out = {};
    let i_each = 0;
    for (const z_each of a_in) {
        Object.assign(h_out, f_fold(z_each, i_each++));
    }
    return h_out;
};
/**
 * Creates a new array by inserting an item in between every existing item
 */
const interjoin = (a_input, w_insert) => {
    const a_output = [];
    for (let i_each = 0, nl_items = a_input.length; i_each < nl_items - 1; i_each++) {
        a_output.push(a_input[i_each]);
        a_output.push(w_insert);
    }
    if (a_input.length)
        a_output.push(a_input.at(-1));
    return a_output;
};
/**
 * Removes duplicates from an array, keeping only the first occurrence.
 * @param z_identify - if specified and a string, identifies the key of each item to use as an identifier
 * if specified and a function, used as a callback to produce the comparison key
 * if omitted, compares items using full equality `===`
 */
const deduplicate = (a_items, z_identify) => {
    // compare items exactly by default
    let a_keys = a_items;
    // identify argument
    if (z_identify) {
        // use object property
        if ('string' === typeof z_identify) {
            a_keys = a_items.map(w => w[z_identify]);
        }
        // use identity function
        else if ('function' === typeof z_identify) {
            a_keys = a_items.map(z_identify);
        }
        else {
            throw new TypeError(`Invalid identifier argument value: ${String(z_identify)}`);
        }
    }
    // each item in list
    for (let i_item = 0, nl_items = a_items.length; i_item < nl_items; i_item++) {
        const si_item = a_keys[i_item];
        // compare against all higher-indexed items
        for (let i_test = i_item + 1; i_test < nl_items; i_test++) {
            // found duplicate
            if (si_item === a_keys[i_test]) {
                // remove duplicate
                a_items.splice(i_test, 1);
                a_keys.splice(i_test, 1);
                // update length
                nl_items -= 1;
                // update test index
                i_test -= 1;
                // repeat
                continue;
            }
        }
    }
    return a_items;
};
/**
 * Escape all special regex characters to turn a string into a verbatim match pattern
 * @param s_input input string
 * @returns escaped string ready for RegExp constructor
 */
const escape_regex = (s_input) => s_input.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
/**
 * Typed alias to `Object.entries`
 */
const ode = (h_object) => Object.entries(h_object);
/**
 * Typed alias to `Object.fromEntries`
 */
const ofe = (a_entries) => Object.fromEntries(a_entries);
/**
 * Reduce object entries to an arbitrary type
 */
const oder = (h_thing, f_reduce, w_init) => ode(h_thing).reduce(f_reduce, w_init);
/**
 * Reduce object entries to an array via concatenation
 */
const oderac = (h_thing, f_concat, b_add_undefs = false) => ode(h_thing).reduce((a_out, [si_key, w_value], i_entry) => {
    const w_add = f_concat(si_key, w_value, i_entry);
    if ('undefined' !== typeof w_add || b_add_undefs) {
        a_out.push(w_add);
    }
    return a_out;
}, []);
/**
 * Reduce object entries to an array via flattening
 */
const oderaf = (h_thing, f_concat) => ode(h_thing).reduce((a_out, [si_key, w_value], i_entry) => [
    ...a_out,
    ...f_concat(si_key, w_value, i_entry),
    // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
], []);
/**
 * Reduce object entries to an object via merging
 */
const oderom = (h_thing, f_merge) => ode(h_thing).reduce((h_out, [si_key, w_value]) => ({
    ...h_out,
    ...f_merge(si_key, w_value),
}), {});
/**
 * Reduce object entries to an object via transforming value function
 */
const fodemtv = (h_thing, f_transform) => Object.fromEntries(ode(h_thing).map(([si_key, w_value]) => [si_key, f_transform(w_value, si_key)]));
/**
 * Promise-based version of `setTimeout()`
 */
const timeout = (xt_wait) => new Promise((fk_resolve) => {
    setTimeout(() => {
        fk_resolve(void 0);
    }, xt_wait);
});
const timeout_exec = (xt_wait, f_attempt) => new Promise((fk_resolve, fe_reject) => {
    // infinite
    if (!Number.isFinite(xt_wait)) {
        void f_attempt?.().then(w => fk_resolve([w, 0])).catch(e => fe_reject(e));
        return;
    }
    let b_timed_out = false;
    // attempt callback
    f_attempt?.()
        .then((w_return) => {
        // already timed out
        if (b_timed_out)
            return;
        // cancel pending timer
        clearTimeout(i_pending);
        // resolve promise
        fk_resolve([w_return, 0]);
    })
        .catch((e_attempt) => {
        fe_reject(e_attempt);
    });
    // start waiting
    const i_pending = setTimeout(() => {
        // mark as timed out
        b_timed_out = true;
        // resolve promise
        fk_resolve([void 0, 1]);
    }, xt_wait);
});
const with_timeout = (g_with) => new Promise((fk_resolve, fe_reject) => {
    // state of completion
    let b_complete = false;
    // timer
    setTimeout(() => {
        // already completed
        if (b_complete)
            return;
        // now complete
        b_complete = true;
        // reject
        fe_reject(g_with.trip());
    }, g_with.duration);
    // run task
    g_with.run().then((w_value) => {
        // already failed
        if (b_complete)
            return;
        // now complete
        b_complete = true;
        // resolve
        fk_resolve(w_value);
    }).catch(fe_reject);
});
/**
 * A Promise that never fulfills nor rejects
 */
const forever = (w_type) => new Promise(F_NOOP);
/**
 * Promse-based version of `queueMicrotask()`
 */
const microtask = () => new Promise((fk_resolve) => {
    queueMicrotask(() => {
        fk_resolve(void 0);
    });
});
const defer = () => {
    let fk_resolve;
    let fe_reject;
    const dp_promise = new Promise((fk, fe) => {
        fk_resolve = fk;
        fe_reject = fe;
    });
    return [dp_promise, (w_return, e_reject) => {
            if (e_reject) {
                fe_reject(e_reject);
            }
            else {
                fk_resolve(w_return);
            }
        }];
};
const defer_many = (h_input) => {
    const h_mapped = fodemtv(h_input, () => defer());
    return {
        promises: fodemtv(h_mapped, a_defer => a_defer[0]),
        resolve(h_resolves) {
            for (const si_key in h_resolves) {
                h_mapped[si_key]?.[1](h_resolves[si_key]);
            }
        },
        reject(h_rejects) {
            for (const si_key in h_rejects) {
                h_mapped[si_key]?.[1](void 0, h_rejects[si_key]);
            }
        },
    };
};
/**
 * Cryptographically strong random number
 */
const crypto_random = () => crypto.getRandomValues(new Uint32Array(1))[0] / (2 ** 32);
/**
 * Generate a random int within a given range
 */
const random_int = (x_a, x_b = 0) => {
    const x_min = Math.floor(Math.min(x_a, x_b));
    const x_max = Math.ceil(Math.max(x_a, x_b));
    // confine to range
    return Math.floor(Math.random() * (x_max - x_min)) + x_min;
};
/**
 * Generate a cryptographically strong random int within a given range
 */
const crypto_random_int = (x_a, x_b = 0) => {
    const x_min = Math.floor(Math.min(x_a, x_b));
    const x_max = Math.ceil(Math.max(x_a, x_b));
    // confine to range
    return Math.floor(crypto_random() * (x_max - x_min)) + x_min;
};
/**
 * Shuffles an array
 */
const shuffle = (a_items, f_random = random_int) => {
    let i_item = a_items.length;
    while (i_item > 0) {
        const i_swap = f_random(--i_item);
        const w_item = a_items[i_item];
        a_items[i_item] = a_items[i_swap];
        a_items[i_swap] = w_item;
    }
    return a_items;
};
/**
 * Removes the first occurrence of the given item from the array
 * @param a_items
 * @param w_item
 * @returns
 */
const remove = (a_items, w_item) => {
    const i_item = a_items.indexOf(w_item);
    if (i_item >= 0)
        a_items.splice(i_item, 1);
    return a_items;
};

// eslint-disable-next-line @typescript-eslint/naming-convention
const S_UUID_V4 = 'xxxxxxxx_xxxx_4xxx_yxxx_xxxxxxxxxxxx';
// eslint-disable-next-line @typescript-eslint/naming-convention
const R_UUID_V4 = /[xy]/g;
// @ts-expect-error in case crypto global is not defined
const uuid_v4 = globalThis.crypto?.randomUUID ? () => crypto.randomUUID() : () => {
    let xt_now = Date.now();
    if ('undefined' !== typeof performance)
        xt_now += performance.now();
    return S_UUID_V4.replace(R_UUID_V4, (s) => {
        const x_r = (xt_now + (Math.random() * 16)) % 16 | 0;
        xt_now = Math.floor(xt_now / 16);
        return ('x' === s ? x_r : (x_r & 0x3) | 0x8).toString(16);
    });
};
/**
 * Helps reduce codesize
 * @param a_args
 * @returns
 */
const buffer = (...a_args) => new Uint8Array(...a_args);
/**
 * Performs SHA-256 hash on the given data.
 * @param atu8_data data to hash
 * @returns the hash digest
 */
const sha256 = async (atu8_data) => buffer(await crypto.subtle.digest('SHA-256', atu8_data));
/**
 * Performs SHA-256(SHA-256(data))
 * @param atu8_data data to hash
 * @returns the hash digest
 */
const sha256d = async (atu8_data) => {
    const atu8_1 = await sha256(atu8_data);
    const atu8_2 = await sha256(atu8_1);
    zero_out(atu8_1);
    return atu8_2;
};
/**
 * Performs SHA-384 hash on the given data.
 * @param atu8_data data to hash
 * @returns the hash digest
 */
const sha384 = async (atu8_data) => buffer(await crypto.subtle.digest('SHA-384', atu8_data));
/**
 * Performs SHA-512 hash on the given data.
 * @param atu8_data data to hash
 * @returns the hash digest
 */
const sha512 = async (atu8_data) => buffer(await crypto.subtle.digest('SHA-512', atu8_data));
/**
 * Performs HMAC signing of the given message, **not the digest**.
 * @param atu8_sk private key
 * @param atu8_message message to sign, **not the digest**.
 * @returns HMAC signature
 */
const hmac = async (atu8_sk, atu8_message, si_algo = 'SHA-256') => {
    // import signing private key
    const dk_sign = await crypto.subtle.importKey('raw', atu8_sk, {
        name: 'HMAC',
        hash: { name: si_algo },
    }, false, ['sign']);
    // construct hmac signature
    return buffer(await crypto.subtle.sign('HMAC', dk_sign, atu8_message));
};
/**
 * Wipe the contents of a buffer so that sensitive data does not outlive garbage collection.
 */
const zero_out = (atu8_data) => {
    // overwrite the contents
    atu8_data.fill(0);
    // make sure the engine does not optimize away the above memory wipe instruction
    // @ts-expect-error signature IS compatible with both types
    if (0 !== atu8_data.reduce((c_sum, x_value) => c_sum + x_value, 0))
        throw new Error('Failed to zero out sensitive memory region');
};
const encode_length_prefix_u16 = (atu8_data) => {
    // prep buffer to serialize encoded extension
    const atu8_encoded = concat([
        buffer(2),
        atu8_data,
    ]);
    // use big-endian to encode length prefix
    new DataView(atu8_encoded.buffer).setUint16(atu8_encoded.byteOffset, atu8_data.byteLength, false);
    // return encoded buffer
    return atu8_encoded;
};
const decode_length_prefix_u16 = (atu8_encoded) => {
    // use big-endian to decode length prefix
    const ib_terminus = new DataView(atu8_encoded.buffer).getUint16(atu8_encoded.byteOffset, false) + 2;
    // return decoded payload buffer and everything after it
    return [atu8_encoded.subarray(2, ib_terminus), atu8_encoded.subarray(ib_terminus)];
};
/**
 * UTF-8 encodes the given text to an Uint8Array.
 * @param s_text text to encode
 * @returns UTF-8 encoded Uint8Array
 */
const text_to_buffer = (s_text) => new TextEncoder().encode(s_text);
/**
 * UTF-8 decodes the given Uint8Array to text.
 * @param atu8_text UTF-8 encoded data to decode
 * @returns text
 */
const buffer_to_text = (atu8_text) => new TextDecoder().decode(atu8_text);
/**
 * Converts the given base64-encoded string to a buffer, then UTF-8 decodes it.
 * @param sx_buffer input base64-encoded string
 * @returns text
 */
const base64_to_text = (sx_buffer) => buffer_to_text(base64_to_buffer(sx_buffer));
/**
 * UTF-8 encodes the given text, then converts it to a base64-encoded string.
 * @param s_text text to encode
 * @returns output base64-encoded string
 */
const text_to_base64 = (s_text) => buffer_to_base64(text_to_buffer(s_text));
/**
 * Attempts to JSON stringify the given primitive/object and subsequently UTF-8 encode it.
 * @param w_json JSON-compatible value to encode
 * @returns UTF-8 encoded Uint8Array
 */
const json_to_buffer = (w_json) => text_to_buffer(JSON.stringify(w_json));
/**
 * UTF-8 decodes the given Uint8Array and subsequently attempts to JSON parse it.
 * @param atu8_json UTF-8 encoded JSON string data
 * @returns parsed JSON value
 */
const buffer_to_json = (atu8_json) => JSON.parse(buffer_to_text(atu8_json));
/**
 * Encodes the given 32-bit integer in big-endian format to a new buffer.
 * @param xg_uint
 * @returns
 */
const uint32_to_buffer_be = (xg_uint) => {
    // prep array buffer
    const ab_buffer = new Uint32Array(1).buffer;
    // write to buffer
    new DataView(ab_buffer).setUint32(0, Number(xg_uint), false);
    // wrap as uint8array
    return buffer(ab_buffer);
};
/**
 * Decodes a 32-bit integer in big-endian format from a buffer (optionally at the given position).
 * @param n_uint
 * @returns
 */
const buffer_to_uint32_be = (atu8_buffer, ib_offset = 0) => new DataView(atu8_buffer.buffer).getUint32(atu8_buffer.byteOffset + ib_offset, false);
/**
 * Converts a JSON object into its canonical form.
 * @param w_json JSON-compatible value to canonicalize
 * @returns canonicalized JSON value
 */
const canonicalize_json = (w_json) => {
    if (is_dict(w_json)) {
        // sort all keys
        const h_sorted = Object.fromEntries(Object.entries(w_json).sort((a_a, a_b) => a_a[0] < a_b[0] ? -1 : 1));
        // traverse on children
        for (const si_key in h_sorted) {
            h_sorted[si_key] = canonicalize_json(h_sorted[si_key]);
        }
    }
    return w_json;
};
/**
 * Concatenate a sequence of Uint8Arrays.
 * @param a_buffers the data to concatenate in order
 * @returns the concatenated output Uint8Array
 */
const concat = (a_buffers) => {
    const nb_out = a_buffers.reduce((c_bytes, atu8_each) => c_bytes + atu8_each.byteLength, 0);
    const atu8_out = buffer(nb_out);
    let ib_write = 0;
    for (const atu8_each of a_buffers) {
        atu8_out.set(atu8_each, ib_write);
        ib_write += atu8_each.byteLength;
    }
    return atu8_out;
};
/**
 * Concatenate two Uint8Arrays together.
 * @param atu8_buffer_a left side
 * @param atu8_buffer_b right side
 * @returns the concatenated output Uint8Array
 */
const concat2 = (atu8_a, atu8_b) => {
    const atu8_out = buffer(atu8_a.length + atu8_b.length);
    atu8_out.set(atu8_a);
    atu8_out.set(atu8_b, atu8_a.length);
    return atu8_out;
};
// // cache function reference
// const sfcc = String.fromCharCode;
/**
 * Converts the given buffer to a hex string format in lowercase.
 * @param atu8_buffer input buffer
 * @returns output hex string
 */
const buffer_to_hex = (atu8_buffer) => atu8_buffer.reduce((s_out, xb_byte) => s_out + xb_byte.toString(16).padStart(2, '0'), '');
/**
 * Converts the given hex string into a buffer.
 * @param sx_hex input hex string
 * @returns output buffer
 */
const hex_to_buffer = (sx_hex) => buffer(sx_hex.length / 2)
    .map((xb_ignore, i_char) => parseInt(sx_hex.slice(i_char * 2, (i_char * 2) + 2), 16));
/**
 * Converts the given buffer to a base64-encoded string.
 * @param atu8_buffer input buffer
 * @returns output base64-encoded string
 */
const buffer_to_base64 = (atu8_buffer) => btoa(Array.from(atu8_buffer).map(xb => String.fromCharCode(xb)).join(''));
/**
 * Converts the given base64-encoded string to a buffer.
 * @param sx_buffer input base64-encoded string
 * @returns output buffer
 */
const base64_to_buffer = (sx_buffer) => buffer(atob(sx_buffer).split('').map(s => s.charCodeAt(0)));
/**
 * Converts the given UTF-8 friendly compact string to a buffer.
 * @param sx_buffer input string
 * @returns output buffer
 */
const string8_to_buffer = (sx_buffer) => {
    const nl_pairs = sx_buffer.length;
    const atu8_buffer = buffer(nl_pairs);
    for (let i_read = 0; i_read < nl_pairs; i_read++) {
        atu8_buffer[i_read] = sx_buffer.charCodeAt(i_read);
    }
    return atu8_buffer;
};
// inspired by <https://github.com/ticlo/jsonesc/blob/master/dist/base93.js>
// eslint-disable-next-line @typescript-eslint/naming-convention
const SX_CHARS_BASE93 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&'()*+,-./:;<=>?@[]^_`{|}~ ";
/**
 * Converts the given buffer to a base93-encoded string.
 * @param atu8_buffer input buffer
 * @returns output base93-encoded string
 */
const buffer_to_base93 = (atu8_buffer) => {
    let s_out = '';
    const nb_buffer = atu8_buffer.byteLength;
    let xb_encode = 0;
    let ni_shift = 0;
    for (let ib_each = 0; ib_each < nb_buffer; ib_each++) {
        const xb_each = atu8_buffer[ib_each];
        xb_encode |= xb_each << ni_shift;
        ni_shift += 8;
        if (ni_shift > 13) {
            let xb_local = xb_encode & 0x1fff;
            if (xb_local > 456) {
                xb_encode >>= 13;
                ni_shift -= 13;
            }
            else {
                xb_local = xb_encode & 0x3fff;
                xb_encode >>= 14;
                ni_shift -= 14;
            }
            s_out += SX_CHARS_BASE93[xb_local % 93] + SX_CHARS_BASE93[(xb_local / 93) | 0];
        }
    }
    if (ni_shift > 0) {
        s_out += SX_CHARS_BASE93[xb_encode % 93];
        if (ni_shift > 7 || xb_encode > 92) {
            s_out += SX_CHARS_BASE93[(xb_encode / 93) | 0];
        }
    }
    return s_out;
};
/**
 * Converts the given base93-encoded string to a buffer.
 * @param sx_buffer input base93-encoded string
 * @returns output buffer
 */
const base93_to_buffer = (sx_buffer) => {
    const nl_buffer = sx_buffer.length;
    const a_out = [];
    let xb_decode = 0;
    let ni_shift = 0;
    let xb_work = -1;
    for (let i_each = 0; i_each < nl_buffer; i_each++) {
        const xb_char = SX_CHARS_BASE93.indexOf(sx_buffer[i_each]);
        if (-1 === xb_char)
            throw new Error(`Invalid base93 string`);
        if (-1 === xb_work) {
            xb_work = xb_char;
            continue;
        }
        xb_work += xb_char * 93;
        xb_decode |= xb_work << ni_shift;
        ni_shift += (xb_work & 0x1fff) > 456 ? 13 : 14;
        do {
            a_out.push(xb_decode & 0xff);
            xb_decode >>= 8;
            ni_shift -= 8;
        } while (ni_shift > 7);
        xb_work = -1;
    }
    if (-1 !== xb_work)
        a_out.push(xb_decode | (xb_work << ni_shift));
    return Uint8Array.from(a_out.slice(0, Math.ceil(sx_buffer.length * 7 / 8)));
};
// inspired by <https://github.com/pur3miish/base58-js>
// eslint-disable-next-line @typescript-eslint/naming-convention
const SX_CHARS_BASE58 = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
// eslint-disable-next-line @typescript-eslint/naming-convention
const A_CHARS_BASE58 = Array(256).fill(-1);
{
    let i_char = 0;
    // eslint-disable-next-line prefer-const
    for (let s_char of SX_CHARS_BASE58) {
        A_CHARS_BASE58[s_char.charCodeAt(0)] = i_char++;
    }
}
const buffer_to_base58 = (atu8_buffer) => {
    const a_out = [];
    for (const xb_char of atu8_buffer) {
        let xb_carry = xb_char;
        for (let ib_sweep = 0; ib_sweep < a_out.length; ++ib_sweep) {
            const xb_value = (A_CHARS_BASE58[a_out[ib_sweep]] << 8) + xb_carry;
            a_out[ib_sweep] = SX_CHARS_BASE58.charCodeAt(xb_value % 58);
            xb_carry = (xb_value / 58) | 0;
        }
        while (xb_carry) {
            a_out.push(SX_CHARS_BASE58.charCodeAt(xb_carry % 58));
            xb_carry = (xb_carry / 58) | 0;
        }
    }
    for (const xb_char of atu8_buffer) {
        if (xb_char) {
            break;
        }
        else {
            a_out.push('1'.charCodeAt(0));
        }
    }
    a_out.reverse();
    return String.fromCharCode(...a_out);
};
const base58_to_buffer = (sb58_buffer) => {
    if (!sb58_buffer || 'string' !== typeof sb58_buffer) {
        throw new Error(`Expected base58 string but got “${sb58_buffer}”`);
    }
    const m_invalid = sb58_buffer.match(/[IOl0]/gmu);
    if (m_invalid) {
        throw new Error(`Invalid base58 character “${String(m_invalid)}”`);
    }
    const m_lz = sb58_buffer.match(/^1+/gmu);
    const nl_psz = m_lz ? m_lz[0].length : 0;
    const nb_out = (((sb58_buffer.length - nl_psz) * (Math.log(58) / Math.log(256))) + 1) >>> 0;
    return buffer([
        ...buffer(nl_psz),
        ...sb58_buffer
            .match(/.{1}/gmu)
            .map(sxb58 => SX_CHARS_BASE58.indexOf(sxb58))
            .reduce((atu8_out, ib_pos) => atu8_out.map((xb_char) => {
            const xb_tmp = (xb_char * 58) + ib_pos;
            ib_pos = xb_tmp >> 8;
            return xb_tmp;
        }), buffer(nb_out))
            .reverse()
            .filter((b_last => xb_each => (b_last = b_last || !!xb_each))(false)),
    ]);
};

export { ATU8_NIL, F_IDENTITY, F_NOOP, base58_to_buffer, base64_to_buffer, base64_to_text, base93_to_buffer, buffer, buffer_to_base58, buffer_to_base64, buffer_to_base93, buffer_to_hex, buffer_to_json, buffer_to_text, buffer_to_uint32_be, canonicalize_json, concat, concat2, crypto_random, crypto_random_int, decode_length_prefix_u16, deduplicate, defer, defer_many, encode_length_prefix_u16, escape_regex, fodemtv, fold, forever, hex_to_buffer, hmac, interjoin, is_dict, is_dict_es, json_to_buffer, microtask, ode, oder, oderac, oderaf, oderom, ofe, proper, random_int, remove, sha256, sha256d, sha384, sha512, shuffle, string8_to_buffer, text_to_base64, text_to_buffer, timeout, timeout_exec, uint32_to_buffer_be, uuid_v4, with_timeout, zero_out };
