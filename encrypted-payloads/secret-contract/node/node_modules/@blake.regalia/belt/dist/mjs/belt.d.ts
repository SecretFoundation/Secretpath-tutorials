import type { Dict, JsonObject } from './types';
/**
 * Utility nil buffer constant
 */
export declare const ATU8_NIL: Uint8Array;
export declare const __UNDEFINED: undefined;
/**
 * The value `8n`
 */
export declare const XG_8 = 8n;
/**
 * The value `16n`
 */
export declare const XG_16 = 8n;
/**
 * The value `32n`
 */
export declare const XG_32 = 8n;
/**
 * The frequently-used "no-operation" function
 */
export declare const F_NOOP: () => void;
/**
 * The seldomnly-used "identity" function
 */
export declare const F_IDENTITY: (w: any) => any;
/**
 * Creates a proper-case string
 */
export declare const proper: (s_input: string) => string;
/**
 * Converts given identifier to "snake_case"
 */
export declare const snake: (s_ident: string) => string;
/**
 * Converts given identifier to "PascalCase"
 */
export declare const pascal: (s_ident: string) => string;
/**
 * Simple test for whether a value is a Uint8Array or not
 */
export declare const is_bytes: (z: unknown) => z is Uint8Array;
/**
 * Simple test for whether a value is an array or not
 */
export declare const is_array: <w_type = unknown>(z: unknown) => z is w_type[];
/**
 * Simple test for whether a deserialized JSON value is a plain object (dict) or not
 */
export declare const is_dict: (z: unknown) => z is JsonObject<never>;
/**
 * Strict test for whether an ES object is a plain object (dict) or not
 */
export declare const is_dict_es: (z: unknown) => z is JsonObject<never>;
/**
 * Fold array into an object
 */
export declare const fold: <w_out, w_value>(a_in: Iterable<w_value>, f_fold: (z_value: w_value, i_each: number) => Dict<w_out>) => Dict<w_out>;
/**
 * Creates a new array by inserting an item in between every existing item
 */
export declare const interjoin: <w_item extends unknown, w_insert extends unknown>(a_input: w_item[], w_insert: w_insert) => (w_item | w_insert)[];
/**
 * Removes duplicates from an array, keeping only the first occurrence.
 * @param z_identify - if specified and a string, identifies the key of each item to use as an identifier
 * if specified and a function, used as a callback to produce the comparison key
 * if omitted, compares items using full equality `===`
 */
export declare const deduplicate: <z_item extends unknown, s_key extends keyof z_item = keyof z_item>(a_items: z_item[], z_identify?: s_key | ((z_item: z_item) => any) | undefined) => z_item[];
/**
 * Escape all special regex characters to turn a string into a verbatim match pattern
 * @param s_input input string
 * @returns escaped string ready for RegExp constructor
 */
export declare const escape_regex: (s_input: string) => string;
/**
 * Typed alias to `Object.create`
 */
export declare const oc: <h_source extends object | null>(h_object: h_source, gc_props?: PropertyDescriptorMap) => object;
/**
 * Typed alias to `Object.assign`
 */
export declare const oda: <h_object extends {}, h_extend extends {}>(h_object: h_object, h_extend: h_extend) => h_object & h_extend;
/**
 * Typed alias to `Object.keys`
 */
export declare const odk: <si_key extends string, w_value extends any>(h_object: Record<si_key, w_value>) => si_key[];
/**
 * Typed alias to `Object.values`
 */
export declare const odv: <w_value extends any>(h_object: Record<any, w_value>) => w_value[];
/**
 * Typed alias to `Object.entries`
 */
export declare const ode: <si_key extends string, w_value extends any>(h_object: Record<si_key, w_value>) => [si_key, w_value][];
/**
 * Typed alias to `Object.fromEntries`
 */
export declare const ofe: <as_keys extends string, w_values extends any>(a_entries: Iterable<[as_keys, w_values]>) => Record<as_keys, w_values>;
/**
 * Map object entries
 */
export declare const odem: <w_out extends unknown, si_key extends string, w_value extends unknown>(h_object: Record<si_key, w_value>, f_map: (g_entry: [si_key, w_value], i_index: number, a_all: [si_key, w_value][]) => w_out) => w_out[];
/**
 * Reduce object entries to an arbitrary type
 */
export declare const oder: <w_out extends unknown, si_key extends string, w_value extends unknown>(h_thing: Record<si_key, w_value>, f_reduce: (w_prev: w_out, g_entry: [si_key, w_value], i_index: number, a_all: [si_key, w_value][]) => w_out, w_init: w_out) => w_out;
/**
 * Reduce object entries to an array via concatenation (with filtering)
 */
export declare const oderac: <w_out extends unknown, si_key extends string, w_value extends unknown>(h_thing: Record<si_key, w_value>, f_concat: (si_key: si_key, w_value: w_value, i_entry: number) => w_out, b_add_undefs?: boolean) => w_out[];
/**
 * Reduce object entries to an array via flattening
 */
export declare const oderaf: <w_out extends unknown, si_key extends string, w_value extends unknown>(h_thing: Record<si_key, w_value>, f_concat: (si_key: si_key, w_value: w_value, i_entry: number) => w_out[]) => w_out[];
/**
 * Reduce object entries to an object via merging
 */
export declare const oderom: <w_value_out extends unknown, si_key_in extends string, w_value_in extends unknown, si_key_out extends string>(h_thing: Record<si_key_in, w_value_in>, f_merge: (si_key: si_key_in, w_value: w_value_in, i_index: number) => Record<si_key_in, w_value_out>) => Record<si_key_out, w_value_out>;
/**
 * Reduce object entries to an object via transforming value function
 */
export declare const fodemtv: <w_out extends unknown, si_key extends string, w_value extends unknown>(h_thing: Record<si_key, w_value>, f_transform: (w_value: w_value, si_key: si_key, i_entry: number) => w_out) => { [si_key_out in keyof Record<si_key, w_value>]: w_out; };
/**
 * Promise-based version of `setTimeout()`
 */
export declare const timeout: (xt_wait: number) => Promise<void>;
export declare const timeout_exec: <w_return extends unknown = any>(xt_wait: number, f_attempt?: (() => Promise<w_return>) | undefined) => Promise<[w_return | undefined, 0 | 1]>;
export interface WithTimeoutConfig<w_value extends any> {
    duration: number;
    trip: () => void;
    run: () => Promise<w_value>;
}
export declare const with_timeout: <w_value extends unknown>(g_with: WithTimeoutConfig<w_value>) => Promise<w_value>;
/**
 * A Promise that never fulfills nor rejects
 */
export declare const forever: <w_type = void>(w_type?: w_type | undefined) => Promise<w_type>;
/**
 * Promse-based version of `queueMicrotask()`
 */
export declare const microtask: () => Promise<void>;
export declare const defer: <w_return extends unknown = any>() => [Promise<w_return>, (w_return: w_return, e_reject?: Error) => void];
export declare const defer_many: <h_input extends Dict<unknown>>(h_input: h_input) => {
    promises: { [si_each in keyof h_input]: Promise<h_input[si_each]>; };
    resolve(h_resolves: { [si_each_1 in keyof h_input]?: h_input[si_each_1]; }): void;
    reject(h_rejects: { [si_each_2 in keyof h_input]?: Error; }): void;
};
/**
 * Cryptographically strong random number
 */
export declare const crypto_random: () => number;
/**
 * Generate a random int within a given range
 */
export declare const random_int: (x_a: number, x_b?: number) => number;
/**
 * Generate a cryptographically strong random int within a given range
 */
export declare const crypto_random_int: (x_a: number, x_b?: number) => number;
type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array;
/**
 * Shuffles an array
 */
export declare const shuffle: <w_list extends any[] | TypedArray>(a_items: w_list, f_random?: (x_a: number, x_b?: number) => number) => w_list;
/**
 * Removes the first occurrence of the given item from the array
 * @param a_items
 * @param w_item
 * @returns
 */
export declare const remove: <w_item>(a_items: w_item[], w_item: w_item) => w_item[];
/**
 * Throws an error, accepting an optional piece of data to attach to the object
 * @param s_msg
 * @param w_data
 */
export declare const die: (s_msg: string, w_data?: unknown) => never;
export {};
