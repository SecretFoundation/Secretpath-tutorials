/* eslint-disable prefer-const, no-sequences, @typescript-eslint/naming-convention */
import { __UNDEFINED } from './belt.js';
import { bytes_to_bigint_be, bytes_to_text, dataview } from './data.js';
/**
 * Decodes a CBOR buffer into its ES equivalent. It does not support floating point numbers.
 *
 * Please note that only a specific subset of tags are supported: {@link https://www.rfc-editor.org/rfc/rfc8949.html#name-tagging-of-items}
 *  - 3.4.1. Standard Date/Time String - decoded as `number`
 *  - 3.4.2. Epoch-Based Date/Time - decoded as `number`
 *  - 3.4.3. Bignums - decoded as `bigint`
 *
 * @param atu8_data
 * @param ib_read
 * @returns a tuple of the decoded value and number of bytes read: `[z_value:`{@link CborValue `CborValue`}`, nb_read: number]`
 */
export const cbor_decode_trivial = (atu8_data, ib_read = 0) => {
    let xb_initial = atu8_data[ib_read++];
    let xc_additional = xb_initial & 0x1f;
    let xc_major = xb_initial >> 5;
    // only used in next if block, but placed in outer scope join declaration sequence
    let nb_ahead = 1 << (xc_additional - 24);
    let dv_data = dataview(atu8_data.buffer);
    // default to low uint value
    let xn_value = xc_additional;
    if (xc_additional > 23) {
        // read network-order bytes
        xn_value = dv_data['getUint' + (8 * nb_ahead)](ib_read);
        ib_read += nb_ahead;
    }
    /* eslint-disable @typescript-eslint/no-unused-vars */
    let f_bytes = (_) => atu8_data.subarray(ib_read, ib_read += xn_value);
    let a_parsers = [
        // uint
        (_) => xn_value,
        // negative int
        (_) => -xn_value - 1,
        // byte string
        f_bytes,
        // text string
        (_) => bytes_to_text(a_parsers[2]()),
        // array
        (a_items = []) => {
            for (let i_item = 0; i_item < xn_value; i_item++) {
                [a_items[i_item], ib_read] = cbor_decode_trivial(atu8_data, ib_read);
            }
            return a_items;
        },
        // map
        (hm_out = new Map()) => {
            for (let i_item = 0, z_key, z_value; i_item < xn_value; i_item++) {
                [z_key, ib_read] = cbor_decode_trivial(atu8_data, ib_read);
                [z_value, ib_read] = cbor_decode_trivial(atu8_data, ib_read);
                // save entry to map
                hm_out.set(z_key, z_value);
            }
            return hm_out;
        },
        // tagged item
        (__) => [
            // date/time string
            (_) => bytes_to_text(f_bytes()),
            // epoch-based date/time as number of seconds (integer or float)
            (xn_timestamp = 0) => ([xn_timestamp, ib_read] = cbor_decode_trivial(atu8_data, ib_read), xn_timestamp),
            // unsigned bigint
            (_) => bytes_to_bigint_be(f_bytes()),
            // negative bigint
            (_) => -bytes_to_bigint_be(f_bytes()) - 1n,
        ][xc_additional](),
        // major type 7
        (__) => [
            false,
            true,
            null,
            __UNDEFINED,
        ][xc_additional - 20],
    ];
    /* eslint-enable */
    return [
        a_parsers[xc_major](),
        ib_read,
    ];
};
//# sourceMappingURL=cbor.js.map