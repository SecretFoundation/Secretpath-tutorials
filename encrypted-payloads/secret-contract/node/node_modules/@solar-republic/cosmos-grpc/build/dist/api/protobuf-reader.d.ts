import type { NestedArrayable } from '@blake.regalia/belt';
import type { SlimCoin } from '@solar-republic/types';
export type DecodedProtobufFieldPrimitive<w_inject = never> = w_inject | number | string | Uint8Array;
export type DecodedProtobufField<w_inject = never> = NestedArrayable<DecodedProtobufFieldPrimitive<w_inject>>;
export type DecodedProtobufMessage<w_inject = never> = DecodedProtobufField<w_inject>[];
/**
 * Hints control the handling of decoded fields
 */
export declare const enum ProtoHint {
    /**
     * No hint, use default behavior
     */
    NONE = 0,
    /**
     * Indicates that field is not repeated, returns the last value under that field instead of an array
     */
    SINGULAR = 1,
    /**
     * Indicates that the varint could exceed precision of `number` so it should be converted into a string for ES compatibility
     */
    BIGINT = 2,
    /**
     * Shortcut for `ProtoHint.SINGULAR | ProtoHint.BIGINT`
     */
    SINGULAR_BIGINT = 3,// SINGULAR | BIGINT
    /**
     * Indicates that the bytes should be converted into a string
     */
    STRING = 4,
    /**
     * Shortcut for `ProtoHint.SINGULAR | ProtoHint.STRING`
     */
    SINGULAR_STRING = 5,// SINGULAR | STRING
    /**
     * Indicates that the bytes should be decoded as a nested protobuf message
     */
    MESSAGE = 8,
    /**
     * Shortcut for `ProtoHint.SINGULAR | ProtoHint.STRING`
     */
    SINGULAR_MESSAGE = 9
}
export type ProtobufNestedDecoder = (atu8_payload: Uint8Array) => any;
/**
 * Decodes a protobuf buffer without requiring a schema. By default, every field is assumed to be repeatable,
 * and thus is returned as an array of values (without a schema, the decoder has no way of knowing if there
 * will be more values for any given field).
 *
 * However, 'hints' can be provided to control the handling of decoded fields: see {@link ProtoHint}
 *
 * @returns an Array of decoded fields, where the field's number corresponds to its position in the (possibly sparse) Array.
 *
 * For example:
 * ```protobuf
 * message Info {
 *   uint32 foo = 1;
 *   repeated string bar = 2;
 *   uint64 baz = 5;
 *   string high = 1025;
 * }
 * ```
 *  becomes:
 * ```
 * [foo, bar, ..empty x 2, baz]
 * ```
 * where `foo`, `bar` and `baz` are all Arrays,
 *  e.g., `foo[0]` contains the single item for the `foo` field.
 *
 * Decoding an instance of the `Info` message example above with hints might look like this:
 * ```
 * // notice the two empty elements in the middle denoted by `,,`
 * const [, foo, bar, ,, baz] = decode_protobuf<
 * 	[number, string[], ,, string]
 * >(atu8_msg, [ProtoHint.SINGULAR, ProtoHing.STRING, ,, ProtoHint.SINGULAR_BIGINT])
 * ```
 *
 * Notice that the field index is offset by one for the return value compared to its original 1-based index
 * used in the protobuf field definition. Arbitrarily high indexes can be accessed using their id - 1.
 *
 * ```
 * const a_arbitrary = decode_protobuf(atu8_msg);
 *
 * a_arbitrary[1025-1];  // <-- [string]
 * ```
 */
export declare const decode_protobuf: <w_return extends DecodedProtobufMessage<void> = DecodedProtobufMessage<never>>(atu8_data: Uint8Array, a_hints?: NestedArrayable<ProtoHint>[], a_decoders?: Array<ProtobufNestedDecoder | 0 | undefined>) => w_return;
export declare const decode_protobuf_r0: <w_return extends DecodedProtobufField<never>>(atu8_payload: Uint8Array, a_hints?: ProtoHint[]) => w_return;
export declare const decode_protobuf_r0_0: <w_return extends DecodedProtobufField<never>>(atu8_payload: Uint8Array, a_hints?: ProtoHint[]) => w_return;
export declare const decode_coin: <s_denom extends string = string>(atu8_payload: Uint8Array, [s_denom, s_amount]?: [string, string]) => SlimCoin<s_denom>;
/**
 * Reduces a parsed google.protobuf.Timestamp into whole milliseconds
 */
export declare const reduce_temporal: ([sg_seconds, xn_nanos]: [string, number]) => number;
/**
 * Reduces a parsed google.protobuf.Timestamp into whole milliseconds
 */
export declare const decode_temporal: (atu8_payload: Uint8Array) => number;
