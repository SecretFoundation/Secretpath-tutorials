/* eslint-disable prefer-const */
import { bytes_to_text, is_array } from '@blake.regalia/belt';
/**
 * Hints control the handling of decoded fields
 */
export var ProtoHint;
(function (ProtoHint) {
    /**
     * No hint, use default behavior
     */
    ProtoHint[ProtoHint["NONE"] = 0] = "NONE";
    /**
     * Indicates that field is not repeated, returns the last value under that field instead of an array
     */
    ProtoHint[ProtoHint["SINGULAR"] = 1] = "SINGULAR";
    /**
     * Indicates that the varint could exceed precision of `number` so it should be converted into a string for ES compatibility
     */
    ProtoHint[ProtoHint["BIGINT"] = 2] = "BIGINT";
    /**
     * Shortcut for `ProtoHint.SINGULAR | ProtoHint.BIGINT`
     */
    ProtoHint[ProtoHint["SINGULAR_BIGINT"] = 3] = "SINGULAR_BIGINT";
    /**
     * Indicates that the bytes should be converted into a string
     */
    ProtoHint[ProtoHint["STRING"] = 4] = "STRING";
    /**
     * Shortcut for `ProtoHint.SINGULAR | ProtoHint.STRING`
     */
    ProtoHint[ProtoHint["SINGULAR_STRING"] = 5] = "SINGULAR_STRING";
    /**
     * Indicates that the bytes should be decoded as a nested protobuf message
     */
    ProtoHint[ProtoHint["MESSAGE"] = 8] = "MESSAGE";
    /**
     * Shortcut for `ProtoHint.SINGULAR | ProtoHint.STRING`
     */
    ProtoHint[ProtoHint["SINGULAR_MESSAGE"] = 9] = "SINGULAR_MESSAGE";
})(ProtoHint || (ProtoHint = {}));
/**
 * Decodes a protobuf buffer without requiring a schema. By default, every field is assumed to be repeatable,
 * and thus is returned as an array of values (without a schema, the decoder has no way of knowing if there
 * will be more values for any given field).
 *
 * However, 'hints' can be provided to control the handling of decoded fields: see {@link ProtoHint}
 *
 * @returns an Array of decoded fields, where the field's number corresponds to its position in the (possibly sparse) Array.
 *
 * For example:
 * ```protobuf
 * message Info {
 *   uint32 foo = 1;
 *   repeated string bar = 2;
 *   uint64 baz = 5;
 *   string high = 1025;
 * }
 * ```
 *  becomes:
 * ```
 * [foo, bar, ..empty x 2, baz]
 * ```
 * where `foo`, `bar` and `baz` are all Arrays,
 *  e.g., `foo[0]` contains the single item for the `foo` field.
 *
 * Decoding an instance of the `Info` message example above with hints might look like this:
 * ```
 * // notice the two empty elements in the middle denoted by `,,`
 * const [, foo, bar, ,, baz] = decode_protobuf<
 * 	[number, string[], ,, string]
 * >(atu8_msg, [ProtoHint.SINGULAR, ProtoHing.STRING, ,, ProtoHint.SINGULAR_BIGINT])
 * ```
 *
 * Notice that the field index is offset by one for the return value compared to its original 1-based index
 * used in the protobuf field definition. Arbitrarily high indexes can be accessed using their id - 1.
 *
 * ```
 * const a_arbitrary = decode_protobuf(atu8_msg);
 *
 * a_arbitrary[1025-1];  // <-- [string]
 * ```
 */
export const decode_protobuf = (atu8_data, a_hints, a_decoders) => {
    // decode a varint from the next position in the input
    let varint = (xc_hint) => {
        let xn_out = 0;
        let xi_shift = -7;
        // until terminal byte is encountered (or exceed the bounds of the buffer and throw)
        for (;;) {
            // read the byte
            let xb_read = atu8_data[ib_read++];
            // OR into place
            xn_out |= (xb_read & 0x7f) << (xi_shift += 7);
            // terminal byte
            if (!(xb_read & 0x80))
                return (ProtoHint.BIGINT & xc_hint ? xn_out + '' : xn_out);
        }
    };
    // read position in bytes
    let ib_read = 0;
    // 0-based protobuf field index
    let i_field = 0;
    // outputs of decoded fields
    let a_out = [];
    // while bytes remain in input buffer
    for (; ib_read < atu8_data.length;) {
        // decode field & type
        let xn_field_and_type = varint();
        let xn_field = (xn_field_and_type >> 3) - 1;
        let xn_type = xn_field_and_type & 0x07;
        // invalid field index (precedes previous or lowest) or not the expected field type
        if (xn_field < i_field || xn_type > 2) {
            debugger;
            throw Error(`Failed to decode message`);
            // return atu8_data as unknown as w_return;
        }
        // update field index
        i_field = xn_field;
        // ref provided hint, if any
        let xc_hint_local = a_hints?.[i_field];
        // length-delimited
        let w_value = [
            // varint
            varint,
            // i64
            // @ts-expect-error paren-less param
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            _ => 'i64',
            // len (string, bytes, embedded, etc.)
            // eslint-disable-next-line @typescript-eslint/no-loop-func
            (w_hint) => {
                // decode len prefix
                let nb_read = varint();
                // init start position
                let ib_start = ib_read;
                // advance read pointer byte len bytes to end position
                ib_read += nb_read;
                // extract section
                const atu8_section = atu8_data.subarray(ib_start, ib_read);
                // decoder supplied; apply it
                {
                    if (a_decoders?.[i_field])
                        return a_decoders[i_field](atu8_section);
                }
                // message hint
                if (is_array(w_hint) || ProtoHint.MESSAGE & w_hint) {
                    // // decode that section of the buffer
                    // const w_read = decode_protobuf(
                    // 	atu8_section,
                    // 	((w_hint as number) > 0? []: w_hint) as ProtoHint[]
                    // );
                    return decode_protobuf(atu8_section, (w_hint > 0 ? [] : w_hint));
                }
                // apply hint, expecting non-protobuf messages to be returned as raw bytes
                return ProtoHint.STRING & w_hint ? bytes_to_text(atu8_section) : atu8_section;
                // // apply hint, expecting non-protobuf messages to be returned as raw bytes
                // return ProtoHint.STRING & (w_hint as number)? bytes_to_text(w_read as unknown as Uint8Array): w_read;
            },
        ][xn_type](xc_hint_local);
        // hint is that field is not repeated; set directly instead of pushing to result slot array
        if (xc_hint_local & ProtoHint.SINGULAR) {
            a_out[i_field] = w_value;
        }
        // field can possibly repeat; add to slot array
        else {
            (a_out[i_field] ??= []).push(w_value);
        }
    }
    return a_out;
};
export const decode_protobuf_r0 = (atu8_payload, a_hints) => decode_protobuf(atu8_payload, a_hints)[0];
export const decode_protobuf_r0_0 = (atu8_payload, a_hints) => decode_protobuf(atu8_payload, a_hints)[0][0];
export const decode_coin = (atu8_payload, [s_denom, s_amount] = decode_protobuf(atu8_payload, [ProtoHint.SINGULAR_STRING, ProtoHint.SINGULAR_STRING])) => [s_amount, s_denom];
/**
 * Reduces a parsed google.protobuf.Timestamp into whole milliseconds
 */
export const reduce_temporal = ([sg_seconds, xn_nanos]) => (+sg_seconds * 1e3) + ((xn_nanos / 1e6) | 0);
/**
 * Reduces a parsed google.protobuf.Timestamp into whole milliseconds
 */
export const decode_temporal = (atu8_payload) => reduce_temporal(decode_protobuf(atu8_payload, [ProtoHint.SINGULAR_BIGINT, ProtoHint.SINGULAR]));
//# sourceMappingURL=protobuf-reader.js.map