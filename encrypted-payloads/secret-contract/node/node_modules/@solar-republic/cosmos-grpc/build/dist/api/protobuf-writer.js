import { ATU8_NIL, __UNDEFINED, bytes, dataview, text_to_bytes } from '@blake.regalia/belt';
const encode_varint32 = (atu8_out, ib_write, n_value) => {
    while (n_value > 127) {
        atu8_out[ib_write++] = (n_value & 0x7f) | 0x80;
        n_value >>>= 7;
    }
    atu8_out[ib_write] = n_value;
};
const encode_biguint = (atu8_out, ib_write, xg_value) => {
    while (xg_value > 127n) {
        atu8_out[ib_write++] = Number(xg_value & 0x7fn) | 0x80;
        xg_value >>= 7n;
    }
    atu8_out[ib_write] = Number(xg_value);
};
const encode_bytes = (atu8_out, ib_write, atu8_data) => atu8_out.set(atu8_data, ib_write);
// eslint-disable-next-line @typescript-eslint/naming-convention
export const Protobuf = () => {
    // @ts-expect-error low-opt
    // eslint-disable-next-line prefer-const
    let a_head = [];
    // eslint-disable-next-line prefer-const
    let a_tail = a_head;
    // output buffer byte count
    let cb_buffer = 0;
    // auto-incrementing field index
    let i_auto = 1;
    // write a varint to the output
    const varint = (xn_value) => push([
        encode_varint32,
        xn_value,
        xn_value < 0x80 ? 1
            : xn_value < 0x4000 ? 2
                : xn_value < 0x200000 ? 3
                    : xn_value < 0x10000000 ? 4
                        : 5,
    ]);
    // write the (field | wire type) byte
    const field = (i_field, xn_wire = 2) => ((i_auto = i_field + 1, varint((i_field << 3) | xn_wire)));
    // eslint-disable-next-line @typescript-eslint/naming-convention
    const push = (a_node) => {
        // add to cumulative length
        cb_buffer += a_node[2];
        // set pointer to next node in linked list
        a_tail[3] = a_node;
        // advance floating tail
        a_tail = a_node;
        // for chaining
        return g_self;
    };
    // map an array of items to a repeated field type
    const map_self = (si_key) => (a_items, i_field = i_auto) => ((a_items?.map(w_item => g_self[si_key](w_item, i_field)),
        g_self));
    const g_self = {
        // eslint-disable-next-line @typescript-eslint/naming-convention
        v: (xn_value, i_field = i_auto++) => xn_value && +xn_value ? (field(i_field, 0), varint(xn_value)) : g_self,
        g: (xg_value, i_field = i_auto++) => {
            if (!xg_value)
                return g_self;
            // normalize possible string
            xg_value = BigInt(xg_value);
            // count how many bytes are needed to store this biguint
            let nb_biguint = 1;
            let xg_copy = xg_value;
            while (xg_copy > 127n) {
                nb_biguint++;
                xg_copy >>= 7n;
            }
            return 0n === xg_value ? g_self : (field(i_field, 0), push([
                encode_biguint,
                xg_value,
                nb_biguint,
            ]));
        },
        i: (x_value, i_field = i_auto++, atu8_data = bytes(8), dv_view = dataview(atu8_data.buffer)) => x_value
            ? (field(i_field, 5), dv_view.setFloat64(0, x_value), push([encode_bytes, atu8_data, 8]))
            : g_self,
        b: (atu8_bytes, i_field = i_auto++) => {
            if (!atu8_bytes?.length)
                return g_self;
            const nb_bytes = atu8_bytes.length;
            return (field(i_field),
                varint(nb_bytes),
                push([
                    encode_bytes,
                    atu8_bytes,
                    nb_bytes,
                ]));
        },
        s: (s_data, i_field = i_auto++) => s_data ? g_self.b(text_to_bytes(s_data), i_field) : g_self,
        V: map_self('v'),
        G: map_self('g'),
        I: map_self('i'),
        B: map_self('b'),
        S: map_self('s'),
        // eslint-disable-next-line @typescript-eslint/naming-convention
        // n: (i_field, xn_wire_sub, f_call, ...a_args) => g_self.b(f_call(Protobuf(xn_wire_sub), ...a_args).o(), i_field),
        get o() {
            // eslint-disable-next-line prefer-const
            let atu8_out = bytes(cb_buffer);
            // write offset
            let ib_write = 0;
            // node pointer
            let a_node = a_head[3];
            // iterate thru linked list
            while (a_node) {
                const [f_encode, w_value, nb_length, a_next] = a_node;
                // commit node to output
                f_encode(atu8_out, ib_write, w_value);
                // advance write head by internal length
                ib_write += nb_length;
                // traverse linked list
                a_node = a_next;
            }
            return atu8_out;
        },
    };
    return g_self;
};
export const map = (a_items, f_call) => a_items?.map(w => f_call(w));
export const apply_opt = (w_item, f_call) => w_item ? f_call(w_item) : __UNDEFINED;
export const temporal = (xn_milliseconds) => xn_milliseconds ? Protobuf()
    .v((xn_milliseconds / 1e3) | 0)
    .v((xn_milliseconds % 1e3) * 1e6)
    .o : ATU8_NIL;
export const any = (si_type, atu8_value) => Protobuf()
    .s(si_type)
    .b(atu8_value)
    .o;
export const coin = (a_coin) => (a_coin
    ? Protobuf()
        .s(a_coin[1])
        .s(a_coin[0])
        .o
    : __UNDEFINED);
export const coins = (a_coins) => map(a_coins, coin);
export const slimify_coin = (g_coin) => g_coin ? [g_coin.amount, g_coin.denom] : __UNDEFINED;
//# sourceMappingURL=protobuf-writer.js.map