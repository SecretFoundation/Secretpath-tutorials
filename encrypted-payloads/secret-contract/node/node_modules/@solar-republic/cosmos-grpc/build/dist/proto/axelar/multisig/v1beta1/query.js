import { parse_timestamp } from '../../../../api/json.js';
import { decode_protobuf, decode_temporal } from '../../../../api/protobuf-reader.js';
import { Protobuf, temporal } from '../../../../api/protobuf-writer.js';
import { safe_base64_to_bytes } from '../../../../api/util.js';
import { decodeAxelarMultisigParams } from './params.js';
/**
 * Encodes a `KeyIDRequest` protobuf message:
 * @param s_chain - `chain`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarMultisigKeyIDRequest = (s_chain) => Protobuf() // ...
    .s(s_chain) // string chain = 1
    .o;
/**
 * Encodes a `KeyIDResponse` protobuf message: contains the key ID of the key assigned to a given chain.
 * @param si_key - `key_id`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarMultisigKeyIDResponse = (si_key) => Protobuf() // ...
    .s(si_key) // string key_id = 1
    .o;
/**
 * Encodes a `NextKeyIDRequest` protobuf message:
 * @param s_chain - `chain`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarMultisigNextKeyIDRequest = (s_chain) => Protobuf() // ...
    .s(s_chain) // string chain = 1
    .o;
/**
 * Encodes a `NextKeyIDResponse` protobuf message: contains the key ID for the next rotation on the given chain
 * @param si_key - `key_id`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarMultisigNextKeyIDResponse = (si_key) => Protobuf() // ...
    .s(si_key) // string key_id = 1
    .o;
/**
 * Encodes a `KeyRequest` protobuf message:
 * @param si_key - `key_id`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarMultisigKeyRequest = (si_key) => Protobuf() // ...
    .s(si_key) // string key_id = 1
    .o;
/**
 * Encodes a `KeygenParticipant` protobuf message:
 * @param sa_address - `address`:
 * @param atu8_weight - `weight`:
 * @param s_pub_key - `pub_key`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarMultisigKeygenParticipant = (sa_address, atu8_weight, s_pub_key) => Protobuf() // ...
    .s(sa_address) // string address = 1
    .b(atu8_weight) // bytes weight = 2
    .s(s_pub_key) // string pub_key = 3
    .o;
/**
 * Encodes a `KeyResponse` protobuf message: contains the key corresponding to a given key id.
 * @param si_key - `key_id`:
 * @param xc_state - `state`:
 * @param sg_started_at - `started_at`:
 * @param xt_started_at_timestamp - `started_at_timestamp`:
 * @param atu8_threshold_weight - `threshold_weight`:
 * @param atu8_bonded_weight - `bonded_weight`:
 * @param a_participants - `participants`: Keygen participants in descending order by weight
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarMultisigKeyResponse = (si_key, xc_state, sg_started_at, xt_started_at_timestamp, atu8_threshold_weight, atu8_bonded_weight, a_participants) => Protobuf() // ...
    .s(si_key) // string key_id = 1
    .v(xc_state) // KeyState state = 2
    .g(sg_started_at) // int32 started_at = 3
    .b(temporal(xt_started_at_timestamp)) // Timestamp started_at_timestamp = 4
    .b(atu8_threshold_weight) // bytes threshold_weight = 5
    .b(atu8_bonded_weight) // bytes bonded_weight = 6
    .B(a_participants) // KeygenParticipant[] participants = 7
    .o;
/**
 * Encodes a `KeygenSessionRequest` protobuf message:
 * @param si_key - `key_id`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarMultisigKeygenSessionRequest = (si_key) => Protobuf() // ...
    .s(si_key) // string key_id = 1
    .o;
/**
 * Encodes a `KeygenSessionResponse` protobuf message: contains the keygen session info for a given key ID.
 * @param sg_started_at - `started_at`:
 * @param xt_started_at_timestamp - `started_at_timestamp`:
 * @param sg_expires_at - `expires_at`:
 * @param sg_completed_at - `completed_at`:
 * @param sg_grace_period - `grace_period`:
 * @param xc_state - `state`:
 * @param atu8_keygen_threshold_weight - `keygen_threshold_weight`:
 * @param atu8_signing_threshold_weight - `signing_threshold_weight`:
 * @param atu8_bonded_weight - `bonded_weight`:
 * @param a_participants - `participants`: Keygen candidates in descending order by weight
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarMultisigKeygenSessionResponse = (sg_started_at, xt_started_at_timestamp, sg_expires_at, sg_completed_at, sg_grace_period, xc_state, atu8_keygen_threshold_weight, atu8_signing_threshold_weight, atu8_bonded_weight, a_participants) => Protobuf() // ...
    .g(sg_started_at) // int32 started_at = 1
    .b(temporal(xt_started_at_timestamp)) // Timestamp started_at_timestamp = 2
    .g(sg_expires_at) // int32 expires_at = 3
    .g(sg_completed_at) // int32 completed_at = 4
    .g(sg_grace_period) // int32 grace_period = 5
    .v(xc_state) // MultisigState state = 6
    .b(atu8_keygen_threshold_weight) // bytes keygen_threshold_weight = 7
    .b(atu8_signing_threshold_weight) // bytes signing_threshold_weight = 8
    .b(atu8_bonded_weight) // bytes bonded_weight = 9
    .B(a_participants) // KeygenParticipant[] participants = 10
    .o;
/**
 * Encodes a `ParamsRequest` protobuf message: represents a message that queries the params
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarMultisigParamsRequest = () => Protobuf() // ...
    .o;
/**
 * Encodes a `ParamsResponse` protobuf message:
 * @param g_params - `params`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarMultisigParamsResponse = (atu8_params) => Protobuf() // ...
    .b(atu8_params) // Params params = 1
    .o;
/**
 * Decodes a protobuf KeyIDRequest message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarMultisigKeyIDRequest}
 */
export const decodeAxelarMultisigKeyIDRequest = (atu8_payload) => decode_protobuf(atu8_payload, [5]);
/**
 * Decodes a protobuf KeyID message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarMultisigKeyIDResponse}
 */
export const decodeAxelarMultisigKeyIDResponse = (atu8_payload) => decode_protobuf(atu8_payload, [5]);
/**
 * Decodes a protobuf NextKeyIDRequest message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarMultisigNextKeyIDRequest}
 */
export const decodeAxelarMultisigNextKeyIDRequest = (atu8_payload) => decode_protobuf(atu8_payload, [5]);
/**
 * Decodes a protobuf NextKeyID message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarMultisigNextKeyIDResponse}
 */
export const decodeAxelarMultisigNextKeyIDResponse = (atu8_payload) => decode_protobuf(atu8_payload, [5]);
/**
 * Decodes a protobuf KeyRequest message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarMultisigKeyRequest}
 */
export const decodeAxelarMultisigKeyRequest = (atu8_payload) => decode_protobuf(atu8_payload, [5]);
/**
 * Decodes a protobuf KeygenParticipant message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarMultisigKeygenParticipant}
 */
export const decodeAxelarMultisigKeygenParticipant = (atu8_payload) => decode_protobuf(atu8_payload, [5, 1, 5]);
/**
 * Decodes a protobuf Key message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarMultisigKeyResponse}
 */
export const decodeAxelarMultisigKeyResponse = (atu8_payload) => decode_protobuf(atu8_payload, [5, 1, 3, [3, 1], 1, 1, 0], [0, 0, 0, decode_temporal, 0, 0, decodeAxelarMultisigKeygenParticipant]);
/**
 * Decodes a protobuf KeygenSessionRequest message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarMultisigKeygenSessionRequest}
 */
export const decodeAxelarMultisigKeygenSessionRequest = (atu8_payload) => decode_protobuf(atu8_payload, [5]);
/**
 * Decodes a protobuf KeygenSession message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarMultisigKeygenSessionResponse}
 */
export const decodeAxelarMultisigKeygenSessionResponse = (atu8_payload) => decode_protobuf(atu8_payload, [3, [3, 1], 3, 3, 3, 1, 1, 1, 1, 0], [0, decode_temporal, 0, 0, 0, 0, 0, 0, 0, decodeAxelarMultisigKeygenParticipant]);
/**
 * Decodes a protobuf ParamsRequest message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarMultisigParamsRequest}
 */
export const decodeAxelarMultisigParamsRequest = (atu8_payload) => decode_protobuf(atu8_payload);
/**
 * Decodes a protobuf Params message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarMultisigParamsResponse}
 */
export const decodeAxelarMultisigParamsResponse = (atu8_payload) => decode_protobuf(atu8_payload, [1], [decodeAxelarMultisigParams]);
/**
 * Destructures the fields of a {@link AxelarMultisigKeyIDRequest} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: chain -
 */
export const destructAxelarMultisigKeyIDRequest = (g_struct) => [g_struct.chain];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_MULTISIG_KEY_I_D_REQUEST = '/axelar.multisig.v1beta1.KeyIDRequest';
/**
 * Destructures the fields of a {@link AxelarMultisigKeyIDResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: key_id -
 */
export const destructAxelarMultisigKeyIDResponse = (g_struct) => [g_struct.key_id];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_MULTISIG_KEY_I_D_RESPONSE = '/axelar.multisig.v1beta1.KeyIDResponse';
/**
 * Destructures the fields of a {@link AxelarMultisigNextKeyIDRequest} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: chain -
 */
export const destructAxelarMultisigNextKeyIDRequest = (g_struct) => [g_struct.chain];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_MULTISIG_NEXT_KEY_I_D_REQUEST = '/axelar.multisig.v1beta1.NextKeyIDRequest';
/**
 * Destructures the fields of a {@link AxelarMultisigNextKeyIDResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: key_id -
 */
export const destructAxelarMultisigNextKeyIDResponse = (g_struct) => [g_struct.key_id];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_MULTISIG_NEXT_KEY_I_D_RESPONSE = '/axelar.multisig.v1beta1.NextKeyIDResponse';
/**
 * Destructures the fields of a {@link AxelarMultisigKeyRequest} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: key_id -
 */
export const destructAxelarMultisigKeyRequest = (g_struct) => [g_struct.key_id];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_MULTISIG_KEY_REQUEST = '/axelar.multisig.v1beta1.KeyRequest';
/**
 * Destructures the fields of a {@link AxelarMultisigKeygenParticipant} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: address -
 *   - 1: weight -
 *   - 2: pub_key -
 */
export const destructAxelarMultisigKeygenParticipant = (g_struct) => [g_struct.address, safe_base64_to_bytes(g_struct.weight), g_struct.pub_key];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_MULTISIG_KEYGEN_PARTICIPANT = '/axelar.multisig.v1beta1.KeygenParticipant';
/**
 * Destructures the fields of a {@link AxelarMultisigKeyResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: key_id -
 *   - 1: state -
 *   - 2: started_at -
 *   - 3: started_at_timestamp -
 *   - 4: threshold_weight -
 *   - 5: bonded_weight -
 *   - 6: participants - Keygen participants in descending order by weight
 */
export const destructAxelarMultisigKeyResponse = (g_struct) => [g_struct.key_id, g_struct.state, g_struct.started_at, parse_timestamp(g_struct.started_at_timestamp), safe_base64_to_bytes(g_struct.threshold_weight), safe_base64_to_bytes(g_struct.bonded_weight), g_struct.participants];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_MULTISIG_KEY_RESPONSE = '/axelar.multisig.v1beta1.KeyResponse';
/**
 * Destructures the fields of a {@link AxelarMultisigKeygenSessionRequest} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: key_id -
 */
export const destructAxelarMultisigKeygenSessionRequest = (g_struct) => [g_struct.key_id];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_MULTISIG_KEYGEN_SESSION_REQUEST = '/axelar.multisig.v1beta1.KeygenSessionRequest';
/**
 * Destructures the fields of a {@link AxelarMultisigKeygenSessionResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: started_at -
 *   - 1: started_at_timestamp -
 *   - 2: expires_at -
 *   - 3: completed_at -
 *   - 4: grace_period -
 *   - 5: state -
 *   - 6: keygen_threshold_weight -
 *   - 7: signing_threshold_weight -
 *   - 8: bonded_weight -
 *   - 9: participants - Keygen candidates in descending order by weight
 */
export const destructAxelarMultisigKeygenSessionResponse = (g_struct) => [g_struct.started_at, parse_timestamp(g_struct.started_at_timestamp), g_struct.expires_at, g_struct.completed_at, g_struct.grace_period, g_struct.state, safe_base64_to_bytes(g_struct.keygen_threshold_weight), safe_base64_to_bytes(g_struct.signing_threshold_weight), safe_base64_to_bytes(g_struct.bonded_weight), g_struct.participants];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_MULTISIG_KEYGEN_SESSION_RESPONSE = '/axelar.multisig.v1beta1.KeygenSessionResponse';
/**
 * Destructures the fields of a {@link AxelarMultisigParamsRequest} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 */
export const destructAxelarMultisigParamsRequest = (g_struct) => [];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_MULTISIG_PARAMS_REQUEST = '/axelar.multisig.v1beta1.ParamsRequest';
/**
 * Destructures the fields of a {@link AxelarMultisigParamsResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: params -
 */
export const destructAxelarMultisigParamsResponse = (g_struct) => [g_struct.params];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_MULTISIG_PARAMS_RESPONSE = '/axelar.multisig.v1beta1.ParamsResponse';
//# sourceMappingURL=query.js.map