import { __UNDEFINED } from '@blake.regalia/belt';
import { parse_duration } from '../../../../api/json.js';
import { decode_protobuf, decode_coin, decode_temporal } from '../../../../api/protobuf-reader.js';
import { Protobuf, temporal, coin } from '../../../../api/protobuf-writer.js';
import { safe_base64_to_bytes } from '../../../../api/util.js';
import { decodeAxelarNexusExportedChain, decodeAxelarNexusExportedAsset, decodeAxelarNexusExportedCrossChainAddress } from '../exported/v1beta1/types.js';
import { decodeAxelarUtilsBitmap } from '../../utils/v1beta1/bitmap.js';
/**
 * Encodes a `MaintainerState` protobuf message:
 * @param atu8_address - `address`:
 * @param g_missing_votes - `missing_votes`:
 * @param g_incorrect_votes - `incorrect_votes`:
 * @param s_chain - `chain`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarNexusMaintainerState = (atu8_address, atu8_missing_votes, atu8_incorrect_votes, s_chain) => Protobuf() // ...
    .b(atu8_address) // bytes address = 1
    .b(atu8_missing_votes) // Bitmap missing_votes = 2
    .b(atu8_incorrect_votes) // Bitmap incorrect_votes = 3
    .s(s_chain) // string chain = 4
    .o;
/**
 * Encodes a `ChainState` protobuf message: represents the state of a registered blockchain
 * @param g_chain - `chain`:
 * @param b_activated - `activated`:
 * @param a_assets - `assets`:
 * @param a_maintainer_states - `maintainer_states`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarNexusChainState = (atu8_chain, b_activated, a_assets, a_maintainer_states) => Protobuf() // ...
    .b(atu8_chain) // Chain chain = 1
    .v(b_activated, 3) // boolean activated = 3
    .B(a_assets, 5) // Asset[] assets = 5
    .B(a_maintainer_states, 6) // MaintainerState[] maintainer_states = 6
    .o;
/**
 * Encodes a `LinkedAddresses` protobuf message:
 * @param g_deposit_address - `deposit_address`:
 * @param g_recipient_address - `recipient_address`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarNexusLinkedAddresses = (atu8_deposit_address, atu8_recipient_address) => Protobuf() // ...
    .b(atu8_deposit_address) // CrossChainAddress deposit_address = 1
    .b(atu8_recipient_address) // CrossChainAddress recipient_address = 2
    .o;
/**
 * Encodes a `RateLimit` protobuf message:
 * @param s_chain - `chain`:
 * @param a_limit - `limit`:
 * @param xt_window - `window`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarNexusRateLimit = (s_chain, a_limit, xt_window) => Protobuf() // ...
    .s(s_chain) // string chain = 1
    .b(coin(a_limit)) // Coin limit = 2
    .b(temporal(xt_window)) // Duration window = 3
    .o;
/**
 * Encodes a `TransferEpoch` protobuf message:
 * @param s_chain - `chain`:
 * @param a_amount - `amount`:
 * @param sg_epoch - `epoch`:
 * @param xc_direction - `direction`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarNexusTransferEpoch = (s_chain, a_amount, sg_epoch, xc_direction) => Protobuf() // ...
    .s(s_chain) // string chain = 1
    .b(coin(a_amount)) // Coin amount = 2
    .g(sg_epoch) // uint64 epoch = 3
    .v(xc_direction) // TransferDirection direction = 4
    .o;
/**
 * Decodes a protobuf MaintainerState message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarNexusMaintainerState}
 */
export const decodeAxelarNexusMaintainerState = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1, 1, 5], [0, decodeAxelarUtilsBitmap, decodeAxelarUtilsBitmap]);
/**
 * Decodes a protobuf ChainState message
 * @param atu8_payload - raw bytes to decode
 * @param RESERVED - a second argument is explicitly forbidden. make sure not to pass this function by reference to some callback argument
 * @returns a {@link DecodedAxelarNexusChainState}
 */
export const decodeAxelarNexusChainState = ((atu8_payload, [a_chain, , b_activated, , a_assets, a_maintainer_states] = decode_protobuf(atu8_payload, [1, 0, 1, 0, 0, 0], [decodeAxelarNexusExportedChain, 0, 0, 0, decodeAxelarNexusExportedAsset, decodeAxelarNexusMaintainerState])) => [a_chain, __UNDEFINED, b_activated, __UNDEFINED, a_assets, a_maintainer_states]);
/**
 * Decodes a protobuf LinkedAddresses message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarNexusLinkedAddresses}
 */
export const decodeAxelarNexusLinkedAddresses = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1], [decodeAxelarNexusExportedCrossChainAddress, decodeAxelarNexusExportedCrossChainAddress]);
/**
 * Decodes a protobuf RateLimit message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarNexusRateLimit}
 */
export const decodeAxelarNexusRateLimit = (atu8_payload) => decode_protobuf(atu8_payload, [5, 1, [3, 1]], [0, decode_coin, decode_temporal]);
/**
 * Decodes a protobuf TransferEpoch message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarNexusTransferEpoch}
 */
export const decodeAxelarNexusTransferEpoch = (atu8_payload) => decode_protobuf(atu8_payload, [5, 1, 3, 1], [0, decode_coin]);
/**
 * Destructures the fields of a {@link AxelarNexusMaintainerState} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: address -
 *   - 1: missing_votes -
 *   - 2: incorrect_votes -
 *   - 3: chain -
 */
export const destructAxelarNexusMaintainerState = (g_struct) => [safe_base64_to_bytes(g_struct.address), g_struct.missing_votes, g_struct.incorrect_votes, g_struct.chain];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_NEXUS_MAINTAINER_STATE = '/axelar.nexus.v1beta1.MaintainerState';
/**
 * Destructures the fields of a {@link AxelarNexusChainState} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: chain -
 *   - 2: activated -
 *   - 4: assets -
 *   - 5: maintainer_states -
 */
export const destructAxelarNexusChainState = (g_struct) => [g_struct.chain, __UNDEFINED, g_struct.activated, __UNDEFINED, g_struct.assets, g_struct.maintainer_states];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_NEXUS_CHAIN_STATE = '/axelar.nexus.v1beta1.ChainState';
/**
 * Destructures the fields of a {@link AxelarNexusLinkedAddresses} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: deposit_address -
 *   - 1: recipient_address -
 */
export const destructAxelarNexusLinkedAddresses = (g_struct) => [g_struct.deposit_address, g_struct.recipient_address];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_NEXUS_LINKED_ADDRESSES = '/axelar.nexus.v1beta1.LinkedAddresses';
/**
 * Destructures the fields of a {@link AxelarNexusRateLimit} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: chain -
 *   - 1: limit -
 *   - 2: window -
 */
export const destructAxelarNexusRateLimit = (g_struct) => [g_struct.chain, g_struct.limit, parse_duration(g_struct.window)];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_NEXUS_RATE_LIMIT = '/axelar.nexus.v1beta1.RateLimit';
/**
 * Destructures the fields of a {@link AxelarNexusTransferEpoch} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: chain -
 *   - 1: amount -
 *   - 2: epoch -
 *   - 3: direction -
 */
export const destructAxelarNexusTransferEpoch = (g_struct) => [g_struct.chain, g_struct.amount, g_struct.epoch, g_struct.direction];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_NEXUS_TRANSFER_EPOCH = '/axelar.nexus.v1beta1.TransferEpoch';
//# sourceMappingURL=types.js.map