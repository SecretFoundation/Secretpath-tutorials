import type { WeakInt64Str, CwInt64 } from '@solar-republic/types';
import type { Encoded, Opt } from '../../../../api/types.js';
export type EncodedAxelarUtilsThreshold = Encoded<'/axelar.utils.v1beta1.Threshold'>;
/**
 * Encodes a `Threshold` protobuf message:
 * @param sg_numerator - `numerator`: split threshold into Numerator and denominator to avoid floating point errors down the line
 * @param sg_denominator - `denominator`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeAxelarUtilsThreshold: (sg_numerator?: Opt<WeakInt64Str>, sg_denominator?: Opt<WeakInt64Str>) => EncodedAxelarUtilsThreshold;
/**
 * A decoded protobuf Threshold message
 *
 * Tuple where:
 *   - 0: numerator - split threshold into Numerator and denominator to avoid floating point errors down the line
 *   - 1: denominator -
 */
export type DecodedAxelarUtilsThreshold = [
    sg_numerator?: CwInt64,
    sg_denominator?: CwInt64
];
/**
 * Decodes a protobuf Threshold message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarUtilsThreshold}
 */
export declare const decodeAxelarUtilsThreshold: (atu8_payload: Uint8Array) => DecodedAxelarUtilsThreshold;
/**
 * Destructures the fields of a {@link AxelarUtilsThreshold} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: numerator - split threshold into Numerator and denominator to avoid floating point errors down the line
 *   - 1: denominator -
 */
export declare const destructAxelarUtilsThreshold: (g_struct: AxelarUtilsThreshold) => [numerator?: CwInt64, denominator?: CwInt64];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_AXELAR_UTILS_THRESHOLD = "/axelar.utils.v1beta1.Threshold";
/**
 * JSON serialization of `axelar.utils.v1beta1.Threshold` -
 */
export type AxelarUtilsThreshold = {
    numerator?: CwInt64 | undefined;
    denominator?: CwInt64 | undefined;
};
