import { decode_protobuf } from '../../../../api/protobuf-reader.js';
import { Protobuf } from '../../../../api/protobuf-writer.js';
/**
 * Encodes a `Threshold` protobuf message:
 * @param sg_numerator - `numerator`: split threshold into Numerator and denominator to avoid floating point errors down the line
 * @param sg_denominator - `denominator`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarUtilsThreshold = (sg_numerator, sg_denominator) => Protobuf() // ...
    .g(sg_numerator) // int32 numerator = 1
    .g(sg_denominator) // int32 denominator = 2
    .o;
/**
 * Decodes a protobuf Threshold message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarUtilsThreshold}
 */
export const decodeAxelarUtilsThreshold = (atu8_payload) => decode_protobuf(atu8_payload, [3, 3]);
/**
 * Destructures the fields of a {@link AxelarUtilsThreshold} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: numerator - split threshold into Numerator and denominator to avoid floating point errors down the line
 *   - 1: denominator -
 */
export const destructAxelarUtilsThreshold = (g_struct) => [g_struct.numerator, g_struct.denominator];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_UTILS_THRESHOLD = '/axelar.utils.v1beta1.Threshold';
//# sourceMappingURL=threshold.js.map