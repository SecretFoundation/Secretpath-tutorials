import type { Encoded, JsonAny, Opt } from '../../../../api/types.js';
import type { DecodedGoogleProtobufAny } from '../../../google/protobuf/any.js';
export type EncodedCosmosAppConfig = Encoded<'/cosmos.app.v1alpha1.Config'>;
export type EncodedCosmosAppModuleConfig = Encoded<'/cosmos.app.v1alpha1.ModuleConfig'>;
export type EncodedCosmosAppGolangBinding = Encoded<'/cosmos.app.v1alpha1.GolangBinding'>;
/**
 * Encodes a `Config` protobuf message: represents the configuration for a Cosmos SDK ABCI app. It is intended that all state machine logic including the version of baseapp and tx handlers (and possibly even Tendermint) that an app needs can be described in a config object. For compatibility, the framework should allow a mixture of declarative and imperative app wiring, however, apps that strive for the maximum ease of maintainability should be able to describe their state machine with a config object alone.
 * @param a_modules - `modules`: the module configurations for the app.
 * @param a_golang_bindings - `golang_bindings`: specifies explicit interface to implementation type bindings which depinject uses to resolve interface inputs to provider functions.  The scope of this field's configuration is global (not module specific).
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosAppConfig: (a_modules?: Opt<Encoded<'/cosmos.app.v1alpha1.ModuleConfig'>[]>, a_golang_bindings?: Opt<Encoded<'/cosmos.app.v1alpha1.GolangBinding'>[]>) => EncodedCosmosAppConfig;
/**
 * Encodes a `ModuleConfig` protobuf message: a module configuration for an app.
 * @param s_name - `name`: the unique name of the module within the app. It should be a name that persists between different versions of a module so that modules can be smoothly upgraded to new versions. For example, for the module cosmos.bank.module.v1.Module, we may chose to simply name the module "bank" in the app. When we upgrade to cosmos.bank.module.v2.Module, the app-specific name "bank" stays the same and the framework knows that the v2 module should receive all the same state that the v1 module had. Note: modules should provide info on which versions they can migrate from in the ModuleDescriptor.can_migration_from field.
 * @param atu8_config - `config`: the config object for the module. Module config messages should define a ModuleDescriptor using the cosmos.app.v1alpha1.is_module extension.
 * @param a_golang_bindings - `golang_bindings`: specifies explicit interface to implementation type bindings which depinject uses to resolve interface inputs to provider functions.  The scope of this field's configuration is module specific.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosAppModuleConfig: (s_name?: Opt<string>, atu8_config?: Opt<Uint8Array>, a_golang_bindings?: Opt<Encoded<'/cosmos.app.v1alpha1.GolangBinding'>[]>) => EncodedCosmosAppModuleConfig;
/**
 * Encodes a `GolangBinding` protobuf message: an explicit interface type to implementing type binding for dependency injection.
 * @param s_interface_type - `interface_type`: the interface type which will be bound to a specific implementation type
 * @param s_implementation - `implementation`: the implementing type which will be supplied when an input of type interface is requested
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosAppGolangBinding: (s_interface_type?: Opt<string>, s_implementation?: Opt<string>) => EncodedCosmosAppGolangBinding;
/**
 * A decoded protobuf Config message
 *
 * Tuple where:
 *   - 0: modules - the module configurations for the app.
 *   - 1: golang_bindings - specifies explicit interface to implementation type bindings which depinject uses to resolve interface inputs to provider functions.  The scope of this field's configuration is global (not module specific).
 */
export type DecodedCosmosAppConfig = [
    a_modules?: DecodedCosmosAppModuleConfig[],
    a_golang_bindings?: DecodedCosmosAppGolangBinding[]
];
/**
 * Decodes a protobuf Config message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosAppConfig}
 */
export declare const decodeCosmosAppConfig: (atu8_payload: Uint8Array) => DecodedCosmosAppConfig;
/**
 * A decoded protobuf ModuleConfig message
 *
 * Tuple where:
 *   - 0: name - the unique name of the module within the app. It should be a name that persists between different versions of a module so that modules can be smoothly upgraded to new versions. For example, for the module cosmos.bank.module.v1.Module, we may chose to simply name the module "bank" in the app. When we upgrade to cosmos.bank.module.v2.Module, the app-specific name "bank" stays the same and the framework knows that the v2 module should receive all the same state that the v1 module had. Note: modules should provide info on which versions they can migrate from in the ModuleDescriptor.can_migration_from field.
 *   - 1: config - the config object for the module. Module config messages should define a ModuleDescriptor using the cosmos.app.v1alpha1.is_module extension.
 *   - 2: golang_bindings - specifies explicit interface to implementation type bindings which depinject uses to resolve interface inputs to provider functions.  The scope of this field's configuration is module specific.
 */
export type DecodedCosmosAppModuleConfig = [
    s_name?: string,
    a_config?: DecodedGoogleProtobufAny,
    a_golang_bindings?: DecodedCosmosAppGolangBinding[]
];
/**
 * Decodes a protobuf ModuleConfig message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosAppModuleConfig}
 */
export declare const decodeCosmosAppModuleConfig: (atu8_payload: Uint8Array) => DecodedCosmosAppModuleConfig;
/**
 * A decoded protobuf GolangBinding message
 *
 * Tuple where:
 *   - 0: interface_type - the interface type which will be bound to a specific implementation type
 *   - 1: implementation - the implementing type which will be supplied when an input of type interface is requested
 */
export type DecodedCosmosAppGolangBinding = [
    s_interface_type?: string,
    s_implementation?: string
];
/**
 * Decodes a protobuf GolangBinding message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosAppGolangBinding}
 */
export declare const decodeCosmosAppGolangBinding: (atu8_payload: Uint8Array) => DecodedCosmosAppGolangBinding;
/**
 * Destructures the fields of a {@link CosmosAppConfig} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: modules - the module configurations for the app.
 *   - 1: golang_bindings - specifies explicit interface to implementation type bindings which depinject uses to resolve interface inputs to provider functions.  The scope of this field's configuration is global (not module specific).
 */
export declare const destructCosmosAppConfig: (g_struct: CosmosAppConfig) => [modules?: CosmosAppModuleConfig[], golang_bindings?: CosmosAppGolangBinding[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_APP_CONFIG = "/cosmos.app.v1alpha1.Config";
/**
 * JSON serialization of `cosmos.app.v1alpha1.Config` - represents the configuration for a Cosmos SDK ABCI app. It is intended that all state machine logic including the version of baseapp and tx handlers (and possibly even Tendermint) that an app needs can be described in a config object. For compatibility, the framework should allow a mixture of declarative and imperative app wiring, however, apps that strive for the maximum ease of maintainability should be able to describe their state machine with a config object alone.
 */
export type CosmosAppConfig = {
    modules?: CosmosAppModuleConfig[] | undefined;
    golang_bindings?: CosmosAppGolangBinding[] | undefined;
};
/**
 * Destructures the fields of a {@link CosmosAppModuleConfig} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: name - the unique name of the module within the app. It should be a name that persists between different versions of a module so that modules can be smoothly upgraded to new versions. For example, for the module cosmos.bank.module.v1.Module, we may chose to simply name the module "bank" in the app. When we upgrade to cosmos.bank.module.v2.Module, the app-specific name "bank" stays the same and the framework knows that the v2 module should receive all the same state that the v1 module had. Note: modules should provide info on which versions they can migrate from in the ModuleDescriptor.can_migration_from field.
 *   - 1: config - the config object for the module. Module config messages should define a ModuleDescriptor using the cosmos.app.v1alpha1.is_module extension.
 *   - 2: golang_bindings - specifies explicit interface to implementation type bindings which depinject uses to resolve interface inputs to provider functions.  The scope of this field's configuration is module specific.
 */
export declare const destructCosmosAppModuleConfig: (g_struct: CosmosAppModuleConfig) => [name?: string, config?: JsonAny, golang_bindings?: CosmosAppGolangBinding[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_APP_MODULE_CONFIG = "/cosmos.app.v1alpha1.ModuleConfig";
/**
 * JSON serialization of `cosmos.app.v1alpha1.ModuleConfig` - a module configuration for an app.
 */
export type CosmosAppModuleConfig = {
    name?: string | undefined;
    config?: JsonAny | undefined;
    golang_bindings?: CosmosAppGolangBinding[] | undefined;
};
/**
 * Destructures the fields of a {@link CosmosAppGolangBinding} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: interface_type - the interface type which will be bound to a specific implementation type
 *   - 1: implementation - the implementing type which will be supplied when an input of type interface is requested
 */
export declare const destructCosmosAppGolangBinding: (g_struct: CosmosAppGolangBinding) => [interface_type?: string, implementation?: string];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_APP_GOLANG_BINDING = "/cosmos.app.v1alpha1.GolangBinding";
/**
 * JSON serialization of `cosmos.app.v1alpha1.GolangBinding` - an explicit interface type to implementing type binding for dependency injection.
 */
export type CosmosAppGolangBinding = {
    interface_type?: string | undefined;
    implementation?: string | undefined;
};
