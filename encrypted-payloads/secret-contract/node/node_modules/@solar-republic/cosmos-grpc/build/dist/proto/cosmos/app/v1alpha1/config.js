/*
* ================================
*     GENERATED FILE WARNING
* Do not edit this file manually.
* ================================
*/
import { decode_protobuf } from '../../../../api/protobuf-reader.js';
import { Protobuf } from '../../../../api/protobuf-writer.js';
import { decodeGoogleProtobufAny } from '../../../google/protobuf/any.js';
/**
 * Encodes a `Config` protobuf message: represents the configuration for a Cosmos SDK ABCI app. It is intended that all state machine logic including the version of baseapp and tx handlers (and possibly even Tendermint) that an app needs can be described in a config object. For compatibility, the framework should allow a mixture of declarative and imperative app wiring, however, apps that strive for the maximum ease of maintainability should be able to describe their state machine with a config object alone.
 * @param a_modules - `modules`: the module configurations for the app.
 * @param a_golang_bindings - `golang_bindings`: specifies explicit interface to implementation type bindings which depinject uses to resolve interface inputs to provider functions.  The scope of this field's configuration is global (not module specific).
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosAppConfig = (a_modules, a_golang_bindings) => Protobuf() // ...
    .B(a_modules) // ModuleConfig[] modules = 1
    .B(a_golang_bindings) // GolangBinding[] golang_bindings = 2
    .o;
/**
 * Encodes a `ModuleConfig` protobuf message: a module configuration for an app.
 * @param s_name - `name`: the unique name of the module within the app. It should be a name that persists between different versions of a module so that modules can be smoothly upgraded to new versions. For example, for the module cosmos.bank.module.v1.Module, we may chose to simply name the module "bank" in the app. When we upgrade to cosmos.bank.module.v2.Module, the app-specific name "bank" stays the same and the framework knows that the v2 module should receive all the same state that the v1 module had. Note: modules should provide info on which versions they can migrate from in the ModuleDescriptor.can_migration_from field.
 * @param atu8_config - `config`: the config object for the module. Module config messages should define a ModuleDescriptor using the cosmos.app.v1alpha1.is_module extension.
 * @param a_golang_bindings - `golang_bindings`: specifies explicit interface to implementation type bindings which depinject uses to resolve interface inputs to provider functions.  The scope of this field's configuration is module specific.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosAppModuleConfig = (s_name, atu8_config, a_golang_bindings) => Protobuf() // ...
    .s(s_name) // string name = 1
    .b(atu8_config) // Any config = 2
    .B(a_golang_bindings) // GolangBinding[] golang_bindings = 3
    .o;
/**
 * Encodes a `GolangBinding` protobuf message: an explicit interface type to implementing type binding for dependency injection.
 * @param s_interface_type - `interface_type`: the interface type which will be bound to a specific implementation type
 * @param s_implementation - `implementation`: the implementing type which will be supplied when an input of type interface is requested
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosAppGolangBinding = (s_interface_type, s_implementation) => Protobuf() // ...
    .s(s_interface_type) // string interface_type = 1
    .s(s_implementation) // string implementation = 2
    .o;
/**
 * Decodes a protobuf Config message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosAppConfig}
 */
export const decodeCosmosAppConfig = (atu8_payload) => decode_protobuf(atu8_payload, [0, 0], [decodeCosmosAppModuleConfig, decodeCosmosAppGolangBinding]);
/**
 * Decodes a protobuf ModuleConfig message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosAppModuleConfig}
 */
export const decodeCosmosAppModuleConfig = (atu8_payload) => decode_protobuf(atu8_payload, [5, 1, 0], [0, decodeGoogleProtobufAny, decodeCosmosAppGolangBinding]);
/**
 * Decodes a protobuf GolangBinding message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosAppGolangBinding}
 */
export const decodeCosmosAppGolangBinding = (atu8_payload) => decode_protobuf(atu8_payload, [5, 5]);
/**
 * Destructures the fields of a {@link CosmosAppConfig} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: modules - the module configurations for the app.
 *   - 1: golang_bindings - specifies explicit interface to implementation type bindings which depinject uses to resolve interface inputs to provider functions.  The scope of this field's configuration is global (not module specific).
 */
export const destructCosmosAppConfig = (g_struct) => [g_struct.modules, g_struct.golang_bindings];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_APP_CONFIG = '/cosmos.app.v1alpha1.Config';
/**
 * Destructures the fields of a {@link CosmosAppModuleConfig} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: name - the unique name of the module within the app. It should be a name that persists between different versions of a module so that modules can be smoothly upgraded to new versions. For example, for the module cosmos.bank.module.v1.Module, we may chose to simply name the module "bank" in the app. When we upgrade to cosmos.bank.module.v2.Module, the app-specific name "bank" stays the same and the framework knows that the v2 module should receive all the same state that the v1 module had. Note: modules should provide info on which versions they can migrate from in the ModuleDescriptor.can_migration_from field.
 *   - 1: config - the config object for the module. Module config messages should define a ModuleDescriptor using the cosmos.app.v1alpha1.is_module extension.
 *   - 2: golang_bindings - specifies explicit interface to implementation type bindings which depinject uses to resolve interface inputs to provider functions.  The scope of this field's configuration is module specific.
 */
export const destructCosmosAppModuleConfig = (g_struct) => [g_struct.name, g_struct.config, g_struct.golang_bindings];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_APP_MODULE_CONFIG = '/cosmos.app.v1alpha1.ModuleConfig';
/**
 * Destructures the fields of a {@link CosmosAppGolangBinding} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: interface_type - the interface type which will be bound to a specific implementation type
 *   - 1: implementation - the implementing type which will be supplied when an input of type interface is requested
 */
export const destructCosmosAppGolangBinding = (g_struct) => [g_struct.interface_type, g_struct.implementation];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_APP_GOLANG_BINDING = '/cosmos.app.v1alpha1.GolangBinding';
//# sourceMappingURL=config.js.map