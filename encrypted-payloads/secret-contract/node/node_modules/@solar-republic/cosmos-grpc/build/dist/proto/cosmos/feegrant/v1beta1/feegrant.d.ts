import type { WeakAccountAddr, SlimCoin, CwAccountAddr } from '@solar-republic/types';
import type { Encoded, JsonAny, Opt, WeakTimestampStr, WeakDurationStr } from '../../../../api/types.js';
import type { CosmosBaseCoin } from '../../base/v1beta1/coin.js';
import type { DecodedGoogleProtobufAny } from '../../../google/protobuf/any.js';
export type AnyCosmosFeegrantBasicAllowance = Encoded<'cosmos.feegrant.v1beta1.FeeAllowanceI'>;
export type AnyCosmosFeegrantPeriodicAllowance = Encoded<'cosmos.feegrant.v1beta1.FeeAllowanceI'>;
export type AnyCosmosFeegrantAllowedMsgAllowance = Encoded<'cosmos.feegrant.v1beta1.FeeAllowanceI'>;
export type EncodedCosmosFeegrantBasicAllowance = Encoded<'/cosmos.feegrant.v1beta1.BasicAllowance' | 'cosmos.feegrant.v1beta1.FeeAllowanceI'>;
export type EncodedCosmosFeegrantPeriodicAllowance = Encoded<'/cosmos.feegrant.v1beta1.PeriodicAllowance' | 'cosmos.feegrant.v1beta1.FeeAllowanceI'>;
export type EncodedCosmosFeegrantAllowedMsgAllowance = Encoded<'/cosmos.feegrant.v1beta1.AllowedMsgAllowance' | 'cosmos.feegrant.v1beta1.FeeAllowanceI'>;
export type EncodedCosmosFeegrantGrant = Encoded<'/cosmos.feegrant.v1beta1.Grant'>;
/**
 * Encodes a `BasicAllowance` protobuf message wrapped in the `Any` container: implements Allowance with a one-time grant of coins that optionally expires. The grantee can use up to SpendLimit to cover fees.
 * @param a_spend_limits - `spend_limit`: specifies the maximum amount of coins that can be spent by this allowance and will be updated as coins are spent. If it is empty, there is no spend limit and any amount of coins can be spent.
 * @param xt_expiration - `expiration`: specifies an optional time when this allowance expires
 * @returns a strongly subtyped Uint8Array representing an `Any` protobuf message
 */
export declare const anyBasicAllowance: (a_spend_limits?: Opt<SlimCoin[]>, xt_expiration?: Opt<number>) => AnyCosmosFeegrantBasicAllowance;
/**
 * Encodes a `PeriodicAllowance` protobuf message wrapped in the `Any` container: extends Allowance to allow for both a maximum cap, as well as a limit per time period.
 * @param g_basic - `basic`: specifies a struct of `BasicAllowance`
 * @param xt_period - `period`: specifies the time duration in which period_spend_limit coins can be spent before that allowance is reset
 * @param a_period_spend_limits - `period_spend_limit`: specifies the maximum number of coins that can be spent in the period
 * @param a_period_can_spends - `period_can_spend`: the number of coins left to be spent before the period_reset time
 * @param xt_period_reset - `period_reset`: the time at which this period resets and a new one begins, it is calculated from the start time of the first transaction after the last period ended
 * @returns a strongly subtyped Uint8Array representing an `Any` protobuf message
 */
export declare const anyPeriodicAllowance: (atu8_basic?: Opt<Encoded<'/cosmos.feegrant.v1beta1.BasicAllowance'>>, xt_period?: Opt<number>, a_period_spend_limits?: Opt<SlimCoin[]>, a_period_can_spends?: Opt<SlimCoin[]>, xt_period_reset?: Opt<number>) => AnyCosmosFeegrantPeriodicAllowance;
/**
 * Encodes a `AllowedMsgAllowance` protobuf message wrapped in the `Any` container: creates allowance only for specified message types.
 * @param atu8_allowance - `allowance`: can be any of basic and periodic fee allowance.
 * @param a_allowed_messages - `allowed_messages`: the messages for which the grantee has the access.
 * @returns a strongly subtyped Uint8Array representing an `Any` protobuf message
 */
export declare const anyAllowedMsgAllowance: (atu8_allowance?: Opt<Encoded<'cosmos.feegrant.v1beta1.FeeAllowanceI'>>, a_allowed_messages?: Opt<string[]>) => AnyCosmosFeegrantAllowedMsgAllowance;
/**
 * Encodes a `BasicAllowance` protobuf message: implements Allowance with a one-time grant of coins that optionally expires. The grantee can use up to SpendLimit to cover fees.
 * @param a_spend_limits - `spend_limit`: specifies the maximum amount of coins that can be spent by this allowance and will be updated as coins are spent. If it is empty, there is no spend limit and any amount of coins can be spent.
 * @param xt_expiration - `expiration`: specifies an optional time when this allowance expires
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosFeegrantBasicAllowance: (a_spend_limits?: Opt<SlimCoin[]>, xt_expiration?: Opt<number>) => EncodedCosmosFeegrantBasicAllowance;
/**
 * Encodes a `PeriodicAllowance` protobuf message: extends Allowance to allow for both a maximum cap, as well as a limit per time period.
 * @param g_basic - `basic`: specifies a struct of `BasicAllowance`
 * @param xt_period - `period`: specifies the time duration in which period_spend_limit coins can be spent before that allowance is reset
 * @param a_period_spend_limits - `period_spend_limit`: specifies the maximum number of coins that can be spent in the period
 * @param a_period_can_spends - `period_can_spend`: the number of coins left to be spent before the period_reset time
 * @param xt_period_reset - `period_reset`: the time at which this period resets and a new one begins, it is calculated from the start time of the first transaction after the last period ended
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosFeegrantPeriodicAllowance: (atu8_basic?: Opt<Encoded<'/cosmos.feegrant.v1beta1.BasicAllowance'>>, xt_period?: Opt<number>, a_period_spend_limits?: Opt<SlimCoin[]>, a_period_can_spends?: Opt<SlimCoin[]>, xt_period_reset?: Opt<number>) => EncodedCosmosFeegrantPeriodicAllowance;
/**
 * Encodes a `AllowedMsgAllowance` protobuf message: creates allowance only for specified message types.
 * @param atu8_allowance - `allowance`: can be any of basic and periodic fee allowance.
 * @param a_allowed_messages - `allowed_messages`: the messages for which the grantee has the access.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosFeegrantAllowedMsgAllowance: (atu8_allowance?: Opt<Encoded<'cosmos.feegrant.v1beta1.FeeAllowanceI'>>, a_allowed_messages?: Opt<string[]>) => EncodedCosmosFeegrantAllowedMsgAllowance;
/**
 * Encodes a `Grant` protobuf message: stored in the KVStore to record a grant with full context
 * @param sa_granter - `granter`: the address of the user granting an allowance of their funds.
 * @param sa_grantee - `grantee`: the address of the user being granted an allowance of another user's funds.
 * @param atu8_allowance - `allowance`: can be any of basic, periodic, allowed fee allowance.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosFeegrantGrant: (sa_granter?: Opt<WeakAccountAddr>, sa_grantee?: Opt<WeakAccountAddr>, atu8_allowance?: Opt<Encoded<'cosmos.feegrant.v1beta1.FeeAllowanceI'>>) => EncodedCosmosFeegrantGrant;
/**
 * A decoded protobuf BasicAllowance message
 *
 * Tuple where:
 *   - 0: spend_limit - specifies the maximum amount of coins that can be spent by this allowance and will be updated as coins are spent. If it is empty, there is no spend limit and any amount of coins can be spent.
 *   - 1: expiration - specifies an optional time when this allowance expires
 */
export type DecodedCosmosFeegrantBasicAllowance = [
    a_spend_limit?: [
        string,
        string
    ][],
    a_expiration?: [
        string,
        number
    ]
];
/**
 * Decodes a protobuf BasicAllowance message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosFeegrantBasicAllowance}
 */
export declare const decodeCosmosFeegrantBasicAllowance: (atu8_payload: Uint8Array) => DecodedCosmosFeegrantBasicAllowance;
/**
 * A decoded protobuf PeriodicAllowance message
 *
 * Tuple where:
 *   - 0: basic - specifies a struct of `BasicAllowance`
 *   - 1: period - specifies the time duration in which period_spend_limit coins can be spent before that allowance is reset
 *   - 2: period_spend_limit - specifies the maximum number of coins that can be spent in the period
 *   - 3: period_can_spend - the number of coins left to be spent before the period_reset time
 *   - 4: period_reset - the time at which this period resets and a new one begins, it is calculated from the start time of the first transaction after the last period ended
 */
export type DecodedCosmosFeegrantPeriodicAllowance = [
    a_basic?: DecodedCosmosFeegrantBasicAllowance,
    a_period?: [
        string,
        number
    ],
    a_period_spend_limit?: [
        string,
        string
    ][],
    a_period_can_spend?: [
        string,
        string
    ][],
    a_period_reset?: [
        string,
        number
    ]
];
/**
 * Decodes a protobuf PeriodicAllowance message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosFeegrantPeriodicAllowance}
 */
export declare const decodeCosmosFeegrantPeriodicAllowance: (atu8_payload: Uint8Array) => DecodedCosmosFeegrantPeriodicAllowance;
/**
 * A decoded protobuf AllowedMsgAllowance message
 *
 * Tuple where:
 *   - 0: allowance - can be any of basic and periodic fee allowance.
 *   - 1: allowed_messages - the messages for which the grantee has the access.
 */
export type DecodedCosmosFeegrantAllowedMsgAllowance = [
    a_allowance?: DecodedGoogleProtobufAny,
    a_allowed_messages?: string[]
];
/**
 * Decodes a protobuf AllowedMsgAllowance message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosFeegrantAllowedMsgAllowance}
 */
export declare const decodeCosmosFeegrantAllowedMsgAllowance: (atu8_payload: Uint8Array) => DecodedCosmosFeegrantAllowedMsgAllowance;
/**
 * A decoded protobuf Grant message
 *
 * Tuple where:
 *   - 0: granter - the address of the user granting an allowance of their funds.
 *   - 1: grantee - the address of the user being granted an allowance of another user's funds.
 *   - 2: allowance - can be any of basic, periodic, allowed fee allowance.
 */
export type DecodedCosmosFeegrantGrant = [
    sa_granter?: CwAccountAddr,
    sa_grantee?: CwAccountAddr,
    a_allowance?: DecodedGoogleProtobufAny
];
/**
 * Decodes a protobuf Grant message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosFeegrantGrant}
 */
export declare const decodeCosmosFeegrantGrant: (atu8_payload: Uint8Array) => DecodedCosmosFeegrantGrant;
/**
 * Destructures the fields of a {@link CosmosFeegrantGrant} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: granter - the address of the user granting an allowance of their funds.
 *   - 1: grantee - the address of the user being granted an allowance of another user's funds.
 *   - 2: allowance - can be any of basic, periodic, allowed fee allowance.
 */
export declare const destructCosmosFeegrantGrant: (g_struct: CosmosFeegrantGrant) => [granter?: CwAccountAddr, grantee?: CwAccountAddr, allowance?: JsonAny<string, CosmosFeegrantBasicAllowance | CosmosFeegrantPeriodicAllowance | CosmosFeegrantAllowedMsgAllowance>];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_FEEGRANT_GRANT = "/cosmos.feegrant.v1beta1.Grant";
/**
 * JSON serialization of `cosmos.feegrant.v1beta1.Grant` - stored in the KVStore to record a grant with full context
 */
export type CosmosFeegrantGrant = {
    granter?: CwAccountAddr | undefined;
    grantee?: CwAccountAddr | undefined;
    allowance?: JsonAny<string, CosmosFeegrantBasicAllowance | CosmosFeegrantPeriodicAllowance | CosmosFeegrantAllowedMsgAllowance> | undefined;
};
/**
 * Destructures the fields of a {@link CosmosFeegrantBasicAllowance} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: spend_limit - specifies the maximum amount of coins that can be spent by this allowance and will be updated as coins are spent. If it is empty, there is no spend limit and any amount of coins can be spent.
 *   - 1: expiration - specifies an optional time when this allowance expires
 */
export declare const destructCosmosFeegrantBasicAllowance: (g_struct: CosmosFeegrantBasicAllowance) => [spend_limit?: CosmosBaseCoin[], expiration?: number];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_FEEGRANT_BASIC_ALLOWANCE = "/cosmos.feegrant.v1beta1.BasicAllowance";
/**
 * JSON serialization of `cosmos.feegrant.v1beta1.BasicAllowance` - implements Allowance with a one-time grant of coins that optionally expires. The grantee can use up to SpendLimit to cover fees.
 */
export type CosmosFeegrantBasicAllowance = {
    spend_limit?: CosmosBaseCoin[] | undefined;
    expiration?: WeakTimestampStr | undefined;
};
/**
 * Destructures the fields of a {@link CosmosFeegrantPeriodicAllowance} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: basic - specifies a struct of `BasicAllowance`
 *   - 1: period - specifies the time duration in which period_spend_limit coins can be spent before that allowance is reset
 *   - 2: period_spend_limit - specifies the maximum number of coins that can be spent in the period
 *   - 3: period_can_spend - the number of coins left to be spent before the period_reset time
 *   - 4: period_reset - the time at which this period resets and a new one begins, it is calculated from the start time of the first transaction after the last period ended
 */
export declare const destructCosmosFeegrantPeriodicAllowance: (g_struct: CosmosFeegrantPeriodicAllowance) => [basic?: CosmosFeegrantBasicAllowance, period?: number, period_spend_limit?: CosmosBaseCoin[], period_can_spend?: CosmosBaseCoin[], period_reset?: number];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_FEEGRANT_PERIODIC_ALLOWANCE = "/cosmos.feegrant.v1beta1.PeriodicAllowance";
/**
 * JSON serialization of `cosmos.feegrant.v1beta1.PeriodicAllowance` - extends Allowance to allow for both a maximum cap, as well as a limit per time period.
 */
export type CosmosFeegrantPeriodicAllowance = {
    basic?: CosmosFeegrantBasicAllowance | undefined;
    period?: WeakDurationStr | undefined;
    period_spend_limit?: CosmosBaseCoin[] | undefined;
    period_can_spend?: CosmosBaseCoin[] | undefined;
    period_reset?: WeakTimestampStr | undefined;
};
/**
 * Destructures the fields of a {@link CosmosFeegrantAllowedMsgAllowance} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: allowance - can be any of basic and periodic fee allowance.
 *   - 1: allowed_messages - the messages for which the grantee has the access.
 */
export declare const destructCosmosFeegrantAllowedMsgAllowance: (g_struct: CosmosFeegrantAllowedMsgAllowance) => [allowance?: JsonAny<string, CosmosFeegrantBasicAllowance | CosmosFeegrantPeriodicAllowance | CosmosFeegrantAllowedMsgAllowance>, allowed_messages?: string[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_FEEGRANT_ALLOWED_MSG_ALLOWANCE = "/cosmos.feegrant.v1beta1.AllowedMsgAllowance";
/**
 * JSON serialization of `cosmos.feegrant.v1beta1.AllowedMsgAllowance` - creates allowance only for specified message types.
 */
export type CosmosFeegrantAllowedMsgAllowance = {
    allowance?: JsonAny<string, CosmosFeegrantBasicAllowance | CosmosFeegrantPeriodicAllowance | CosmosFeegrantAllowedMsgAllowance> | undefined;
    allowed_messages?: string[] | undefined;
};
