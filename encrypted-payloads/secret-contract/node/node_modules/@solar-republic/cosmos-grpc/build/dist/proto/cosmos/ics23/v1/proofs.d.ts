import type { CwBase64 } from '@solar-republic/types';
import type { Encoded, Opt } from '../../../../api/types.js';
export type EncodedCosmosIcs23ExistenceProof = Encoded<'/cosmos.ics23.v1.ExistenceProof'>;
export type EncodedCosmosIcs23NonExistenceProof = Encoded<'/cosmos.ics23.v1.NonExistenceProof'>;
export type EncodedCosmosIcs23CommitmentProof = Encoded<'/cosmos.ics23.v1.CommitmentProof'>;
export type EncodedCosmosIcs23LeafOp = Encoded<'/cosmos.ics23.v1.LeafOp'>;
export type EncodedCosmosIcs23InnerOp = Encoded<'/cosmos.ics23.v1.InnerOp'>;
export type EncodedCosmosIcs23ProofSpec = Encoded<'/cosmos.ics23.v1.ProofSpec'>;
export type EncodedCosmosIcs23InnerSpec = Encoded<'/cosmos.ics23.v1.InnerSpec'>;
export type EncodedCosmosIcs23BatchProof = Encoded<'/cosmos.ics23.v1.BatchProof'>;
export type EncodedCosmosIcs23BatchEntry = Encoded<'/cosmos.ics23.v1.BatchEntry'>;
export type EncodedCosmosIcs23CompressedBatchProof = Encoded<'/cosmos.ics23.v1.CompressedBatchProof'>;
export type EncodedCosmosIcs23CompressedBatchEntry = Encoded<'/cosmos.ics23.v1.CompressedBatchEntry'>;
export type EncodedCosmosIcs23CompressedExistenceProof = Encoded<'/cosmos.ics23.v1.CompressedExistenceProof'>;
export type EncodedCosmosIcs23CompressedNonExistenceProof = Encoded<'/cosmos.ics23.v1.CompressedNonExistenceProof'>;
/**
 * Encodes a `ExistenceProof` protobuf message: * ExistenceProof takes a key and a value and a set of steps to perform on it. The result of peforming all these steps will provide a "root hash", which can be compared to the value in a header. Since it is computationally infeasible to produce a hash collission for any of the used cryptographic hash functions, if someone can provide a series of operations to transform a given key and value into a root hash that matches some trusted root, these key and values must be in the referenced merkle tree. The only possible issue is maliablity in LeafOp, such as providing extra prefix data, which should be controlled by a spec. Eg. with lengthOp as NONE, prefix = FOO, key = BAR, value = CHOICE and prefix = F, key = OOBAR, value = CHOICE would produce the same value. With LengthOp this is tricker but not impossible. Which is why the "leafPrefixEqual" field in the ProofSpec is valuable to prevent this mutability. And why all trees should length-prefix the data before hashing it.
 * @param atu8_key - `key`:
 * @param atu8_value - `value`:
 * @param g_leaf - `leaf`:
 * @param a_paths - `path`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosIcs23ExistenceProof: (atu8_key?: Opt<Uint8Array>, atu8_value?: Opt<Uint8Array>, atu8_leaf?: Opt<Encoded<'/cosmos.ics23.v1.LeafOp'>>, a_paths?: Opt<Encoded<'/cosmos.ics23.v1.InnerOp'>[]>) => EncodedCosmosIcs23ExistenceProof;
/**
 * Encodes a `NonExistenceProof` protobuf message: takes a proof of two neighbors, one left of the desired key, one right of the desired key. If both proofs are valid AND they are neighbors, then there is no valid proof for the given key.
 * @param atu8_key - `key`:
 * @param g_left - `left`:
 * @param g_right - `right`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosIcs23NonExistenceProof: (atu8_key?: Opt<Uint8Array>, atu8_left?: Opt<Encoded<'/cosmos.ics23.v1.ExistenceProof'>>, atu8_right?: Opt<Encoded<'/cosmos.ics23.v1.ExistenceProof'>>) => EncodedCosmosIcs23NonExistenceProof;
/**
 * Encodes a `CommitmentProof` protobuf message: either an ExistenceProof or a NonExistenceProof, or a Batch of such messages
 * @param g_exist - `exist`:
 * @param g_nonexist - `nonexist`:
 * @param g_batch - `batch`:
 * @param g_compressed - `compressed`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosIcs23CommitmentProof: (atu8_exist?: Opt<Encoded<'/cosmos.ics23.v1.ExistenceProof'>>, atu8_nonexist?: Opt<Encoded<'/cosmos.ics23.v1.NonExistenceProof'>>, atu8_batch?: Opt<Encoded<'/cosmos.ics23.v1.BatchProof'>>, atu8_compressed?: Opt<Encoded<'/cosmos.ics23.v1.CompressedBatchProof'>>) => EncodedCosmosIcs23CommitmentProof;
/**
 * Encodes a `LeafOp` protobuf message: * LeafOp represents the raw key-value data we wish to prove, and must be flexible to represent the internal transformation from the original key-value pairs into the basis hash, for many existing merkle trees. key and value are passed in. So that the signature of this operation is: leafOp(key, value) -> output To process this, first prehash the keys and values if needed (ANY means no hash in this case): hkey = prehashKey(key) hvalue = prehashValue(value) Then combine the bytes, and hash it output = hash(prefix || length(hkey) || hkey || length(hvalue) || hvalue)
 * @param xc_hash - `hash`:
 * @param xc_prehash_key - `prehash_key`:
 * @param xc_prehash_value - `prehash_value`:
 * @param xc_length - `length`:
 * @param atu8_prefix - `prefix`: a fixed bytes that may optionally be included at the beginning to differentiate a leaf node from an inner node.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosIcs23LeafOp: (xc_hash?: Opt<ProtoEnumCosmosIcs23HashOp>, xc_prehash_key?: Opt<ProtoEnumCosmosIcs23HashOp>, xc_prehash_value?: Opt<ProtoEnumCosmosIcs23HashOp>, xc_length?: Opt<ProtoEnumCosmosIcs23LengthOp>, atu8_prefix?: Opt<Uint8Array>) => EncodedCosmosIcs23LeafOp;
/**
 * Encodes a `InnerOp` protobuf message: * InnerOp represents a merkle-proof step that is not a leaf. It represents concatenating two children and hashing them to provide the next result. The result of the previous step is passed in, so the signature of this op is: innerOp(child) -> output The result of applying InnerOp should be: output = op.hash(op.prefix || child || op.suffix) where the || operator is concatenation of binary data, and child is the result of hashing all the tree below this step. Any special data, like prepending child with the length, or prepending the entire operation with some value to differentiate from leaf nodes, should be included in prefix and suffix. If either of prefix or suffix is empty, we just treat it as an empty string
 * @param xc_hash - `hash`:
 * @param atu8_prefix - `prefix`:
 * @param atu8_suffix - `suffix`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosIcs23InnerOp: (xc_hash?: Opt<ProtoEnumCosmosIcs23HashOp>, atu8_prefix?: Opt<Uint8Array>, atu8_suffix?: Opt<Uint8Array>) => EncodedCosmosIcs23InnerOp;
/**
 * Encodes a `ProofSpec` protobuf message: * ProofSpec defines what the expected parameters are for a given proof type. This can be stored in the client and used to validate any incoming proofs. verify(ProofSpec, Proof) -> Proof | Error As demonstrated in tests, if we don't fix the algorithm used to calculate the LeafHash for a given tree, there are many possible key-value pairs that can generate a given hash (by interpretting the preimage differently). We need this for proper security, requires client knows a priori what tree format server uses. But not in code, rather a configuration object.
 * @param g_leaf_spec - `leaf_spec`: any field in the ExistenceProof must be the same as in this spec. except Prefix, which is just the first bytes of prefix (spec can be longer)
 * @param g_inner_spec - `inner_spec`:
 * @param n_max_depth - `max_depth`: (if > 0) is the maximum number of InnerOps allowed (mainly for fixed-depth tries)
 * @param n_min_depth - `min_depth`: (if > 0) is the minimum number of InnerOps allowed (mainly for fixed-depth tries)
 * @param b_prehash_key_before_comparison - `prehash_key_before_comparison`: a flag that indicates whether to use the prehash_key specified by LeafOp to compare lexical ordering of keys for non-existence proofs.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosIcs23ProofSpec: (atu8_leaf_spec?: Opt<Encoded<'/cosmos.ics23.v1.LeafOp'>>, atu8_inner_spec?: Opt<Encoded<'/cosmos.ics23.v1.InnerSpec'>>, n_max_depth?: Opt<number>, n_min_depth?: Opt<number>, b_prehash_key_before_comparison?: Opt<boolean | 0 | 1>) => EncodedCosmosIcs23ProofSpec;
/**
 * Encodes a `InnerSpec` protobuf message: contains all store-specific structure info to determine if two proofs from a given store are neighbors. This enables: isLeftMost(spec: InnerSpec, op: InnerOp) isRightMost(spec: InnerSpec, op: InnerOp) isLeftNeighbor(spec: InnerSpec, left: InnerOp, right: InnerOp)
 * @param a_child_orders - `child_order`: Child order is the ordering of the children node, must count from 0 iavl tree is [0, 1] (left then right) merk is [0, 2, 1] (left, right, here)
 * @param n_child_size - `child_size`:
 * @param n_min_prefix_length - `min_prefix_length`:
 * @param n_max_prefix_length - `max_prefix_length`:
 * @param atu8_empty_child - `empty_child`: empty child is the prehash image that is used when one child is nil (eg. 20 bytes of 0)
 * @param xc_hash - `hash`: the algorithm that must be used for each InnerOp
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosIcs23InnerSpec: (a_child_orders?: Opt<number[]>, n_child_size?: Opt<number>, n_min_prefix_length?: Opt<number>, n_max_prefix_length?: Opt<number>, atu8_empty_child?: Opt<Uint8Array>, xc_hash?: Opt<ProtoEnumCosmosIcs23HashOp>) => EncodedCosmosIcs23InnerSpec;
/**
 * Encodes a `BatchProof` protobuf message: a group of multiple proof types than can be compressed
 * @param a_entries - `entries`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosIcs23BatchProof: (a_entries?: Opt<Encoded<'/cosmos.ics23.v1.BatchEntry'>[]>) => EncodedCosmosIcs23BatchProof;
/**
 * Encodes a `BatchEntry` protobuf message: Use BatchEntry not CommitmentProof, to avoid recursion
 * @param g_exist - `exist`:
 * @param g_nonexist - `nonexist`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosIcs23BatchEntry: (atu8_exist?: Opt<Encoded<'/cosmos.ics23.v1.ExistenceProof'>>, atu8_nonexist?: Opt<Encoded<'/cosmos.ics23.v1.NonExistenceProof'>>) => EncodedCosmosIcs23BatchEntry;
/**
 * Encodes a `CompressedBatchProof` protobuf message:
 * @param a_entries - `entries`:
 * @param a_lookup_inners - `lookup_inners`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosIcs23CompressedBatchProof: (a_entries?: Opt<Encoded<'/cosmos.ics23.v1.CompressedBatchEntry'>[]>, a_lookup_inners?: Opt<Encoded<'/cosmos.ics23.v1.InnerOp'>[]>) => EncodedCosmosIcs23CompressedBatchProof;
/**
 * Encodes a `CompressedBatchEntry` protobuf message: Use BatchEntry not CommitmentProof, to avoid recursion
 * @param g_exist - `exist`:
 * @param g_nonexist - `nonexist`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosIcs23CompressedBatchEntry: (atu8_exist?: Opt<Encoded<'/cosmos.ics23.v1.CompressedExistenceProof'>>, atu8_nonexist?: Opt<Encoded<'/cosmos.ics23.v1.CompressedNonExistenceProof'>>) => EncodedCosmosIcs23CompressedBatchEntry;
/**
 * Encodes a `CompressedExistenceProof` protobuf message:
 * @param atu8_key - `key`:
 * @param atu8_value - `value`:
 * @param g_leaf - `leaf`:
 * @param a_paths - `path`: these are indexes into the lookup_inners table in CompressedBatchProof
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosIcs23CompressedExistenceProof: (atu8_key?: Opt<Uint8Array>, atu8_value?: Opt<Uint8Array>, atu8_leaf?: Opt<Encoded<'/cosmos.ics23.v1.LeafOp'>>, a_paths?: Opt<number[]>) => EncodedCosmosIcs23CompressedExistenceProof;
/**
 * Encodes a `CompressedNonExistenceProof` protobuf message:
 * @param atu8_key - `key`:
 * @param g_left - `left`:
 * @param g_right - `right`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosIcs23CompressedNonExistenceProof: (atu8_key?: Opt<Uint8Array>, atu8_left?: Opt<Encoded<'/cosmos.ics23.v1.CompressedExistenceProof'>>, atu8_right?: Opt<Encoded<'/cosmos.ics23.v1.CompressedExistenceProof'>>) => EncodedCosmosIcs23CompressedNonExistenceProof;
/**
 * A decoded protobuf ExistenceProof message
 *
 * Tuple where:
 *   - 0: key -
 *   - 1: value -
 *   - 2: leaf -
 *   - 3: path -
 */
export type DecodedCosmosIcs23ExistenceProof = [
    atu8_key?: Uint8Array,
    atu8_value?: Uint8Array,
    a_leaf?: DecodedCosmosIcs23LeafOp,
    a_path?: DecodedCosmosIcs23InnerOp[]
];
/**
 * Decodes a protobuf ExistenceProof message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosIcs23ExistenceProof}
 */
export declare const decodeCosmosIcs23ExistenceProof: (atu8_payload: Uint8Array) => DecodedCosmosIcs23ExistenceProof;
/**
 * A decoded protobuf NonExistenceProof message
 *
 * Tuple where:
 *   - 0: key -
 *   - 1: left -
 *   - 2: right -
 */
export type DecodedCosmosIcs23NonExistenceProof = [
    atu8_key?: Uint8Array,
    a_left?: DecodedCosmosIcs23ExistenceProof,
    a_right?: DecodedCosmosIcs23ExistenceProof
];
/**
 * Decodes a protobuf NonExistenceProof message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosIcs23NonExistenceProof}
 */
export declare const decodeCosmosIcs23NonExistenceProof: (atu8_payload: Uint8Array) => DecodedCosmosIcs23NonExistenceProof;
/**
 * A decoded protobuf CommitmentProof message
 *
 * Tuple where:
 *   - 0: exist -
 *   - 1: nonexist -
 *   - 2: batch -
 *   - 3: compressed -
 */
export type DecodedCosmosIcs23CommitmentProof = [
    a_exist?: DecodedCosmosIcs23ExistenceProof,
    a_nonexist?: DecodedCosmosIcs23NonExistenceProof,
    a_batch?: DecodedCosmosIcs23BatchProof,
    a_compressed?: DecodedCosmosIcs23CompressedBatchProof
];
/**
 * Decodes a protobuf CommitmentProof message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosIcs23CommitmentProof}
 */
export declare const decodeCosmosIcs23CommitmentProof: (atu8_payload: Uint8Array) => DecodedCosmosIcs23CommitmentProof;
/**
 * A decoded protobuf LeafOp message
 *
 * Tuple where:
 *   - 0: hash -
 *   - 1: prehash_key -
 *   - 2: prehash_value -
 *   - 3: length -
 *   - 4: prefix - a fixed bytes that may optionally be included at the beginning to differentiate a leaf node from an inner node.
 */
export type DecodedCosmosIcs23LeafOp = [
    xc_hash?: ProtoEnumCosmosIcs23HashOp,
    xc_prehash_key?: ProtoEnumCosmosIcs23HashOp,
    xc_prehash_value?: ProtoEnumCosmosIcs23HashOp,
    xc_length?: ProtoEnumCosmosIcs23LengthOp,
    atu8_prefix?: Uint8Array
];
/**
 * Decodes a protobuf LeafOp message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosIcs23LeafOp}
 */
export declare const decodeCosmosIcs23LeafOp: (atu8_payload: Uint8Array) => DecodedCosmosIcs23LeafOp;
/**
 * A decoded protobuf InnerOp message
 *
 * Tuple where:
 *   - 0: hash -
 *   - 1: prefix -
 *   - 2: suffix -
 */
export type DecodedCosmosIcs23InnerOp = [
    xc_hash?: ProtoEnumCosmosIcs23HashOp,
    atu8_prefix?: Uint8Array,
    atu8_suffix?: Uint8Array
];
/**
 * Decodes a protobuf InnerOp message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosIcs23InnerOp}
 */
export declare const decodeCosmosIcs23InnerOp: (atu8_payload: Uint8Array) => DecodedCosmosIcs23InnerOp;
/**
 * A decoded protobuf ProofSpec message
 *
 * Tuple where:
 *   - 0: leaf_spec - any field in the ExistenceProof must be the same as in this spec. except Prefix, which is just the first bytes of prefix (spec can be longer)
 *   - 1: inner_spec -
 *   - 2: max_depth - (if > 0) is the maximum number of InnerOps allowed (mainly for fixed-depth tries)
 *   - 3: min_depth - (if > 0) is the minimum number of InnerOps allowed (mainly for fixed-depth tries)
 *   - 4: prehash_key_before_comparison - a flag that indicates whether to use the prehash_key specified by LeafOp to compare lexical ordering of keys for non-existence proofs.
 */
export type DecodedCosmosIcs23ProofSpec = [
    a_leaf_spec?: DecodedCosmosIcs23LeafOp,
    a_inner_spec?: DecodedCosmosIcs23InnerSpec,
    n_max_depth?: number,
    n_min_depth?: number,
    b_prehash_key_before_comparison?: 0 | 1
];
/**
 * Decodes a protobuf ProofSpec message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosIcs23ProofSpec}
 */
export declare const decodeCosmosIcs23ProofSpec: (atu8_payload: Uint8Array) => DecodedCosmosIcs23ProofSpec;
/**
 * A decoded protobuf InnerSpec message
 *
 * Tuple where:
 *   - 0: child_order - Child order is the ordering of the children node, must count from 0 iavl tree is [0, 1] (left then right) merk is [0, 2, 1] (left, right, here)
 *   - 1: child_size -
 *   - 2: min_prefix_length -
 *   - 3: max_prefix_length -
 *   - 4: empty_child - empty child is the prehash image that is used when one child is nil (eg. 20 bytes of 0)
 *   - 5: hash - the algorithm that must be used for each InnerOp
 */
export type DecodedCosmosIcs23InnerSpec = [
    a_child_orders?: number[],
    n_child_size?: number,
    n_min_prefix_length?: number,
    n_max_prefix_length?: number,
    atu8_empty_child?: Uint8Array,
    xc_hash?: ProtoEnumCosmosIcs23HashOp
];
/**
 * Decodes a protobuf InnerSpec message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosIcs23InnerSpec}
 */
export declare const decodeCosmosIcs23InnerSpec: (atu8_payload: Uint8Array) => DecodedCosmosIcs23InnerSpec;
/**
 * A decoded protobuf BatchProof message
 *
 * Alias for: entries -
 */
export type DecodedCosmosIcs23BatchProof = [
    a_entries?: DecodedCosmosIcs23BatchEntry[]
];
/**
 * Decodes a protobuf BatchProof message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosIcs23BatchProof}
 */
export declare const decodeCosmosIcs23BatchProof: (atu8_payload: Uint8Array) => DecodedCosmosIcs23BatchProof;
/**
 * A decoded protobuf BatchEntry message
 *
 * Tuple where:
 *   - 0: exist -
 *   - 1: nonexist -
 */
export type DecodedCosmosIcs23BatchEntry = [
    a_exist?: DecodedCosmosIcs23ExistenceProof,
    a_nonexist?: DecodedCosmosIcs23NonExistenceProof
];
/**
 * Decodes a protobuf BatchEntry message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosIcs23BatchEntry}
 */
export declare const decodeCosmosIcs23BatchEntry: (atu8_payload: Uint8Array) => DecodedCosmosIcs23BatchEntry;
/**
 * A decoded protobuf CompressedBatchProof message
 *
 * Tuple where:
 *   - 0: entries -
 *   - 1: lookup_inners -
 */
export type DecodedCosmosIcs23CompressedBatchProof = [
    a_entries?: DecodedCosmosIcs23CompressedBatchEntry[],
    a_lookup_inners?: DecodedCosmosIcs23InnerOp[]
];
/**
 * Decodes a protobuf CompressedBatchProof message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosIcs23CompressedBatchProof}
 */
export declare const decodeCosmosIcs23CompressedBatchProof: (atu8_payload: Uint8Array) => DecodedCosmosIcs23CompressedBatchProof;
/**
 * A decoded protobuf CompressedBatchEntry message
 *
 * Tuple where:
 *   - 0: exist -
 *   - 1: nonexist -
 */
export type DecodedCosmosIcs23CompressedBatchEntry = [
    a_exist?: DecodedCosmosIcs23CompressedExistenceProof,
    a_nonexist?: DecodedCosmosIcs23CompressedNonExistenceProof
];
/**
 * Decodes a protobuf CompressedBatchEntry message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosIcs23CompressedBatchEntry}
 */
export declare const decodeCosmosIcs23CompressedBatchEntry: (atu8_payload: Uint8Array) => DecodedCosmosIcs23CompressedBatchEntry;
/**
 * A decoded protobuf CompressedExistenceProof message
 *
 * Tuple where:
 *   - 0: key -
 *   - 1: value -
 *   - 2: leaf -
 *   - 3: path - these are indexes into the lookup_inners table in CompressedBatchProof
 */
export type DecodedCosmosIcs23CompressedExistenceProof = [
    atu8_key?: Uint8Array,
    atu8_value?: Uint8Array,
    a_leaf?: DecodedCosmosIcs23LeafOp,
    a_paths?: number[]
];
/**
 * Decodes a protobuf CompressedExistenceProof message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosIcs23CompressedExistenceProof}
 */
export declare const decodeCosmosIcs23CompressedExistenceProof: (atu8_payload: Uint8Array) => DecodedCosmosIcs23CompressedExistenceProof;
/**
 * A decoded protobuf CompressedNonExistenceProof message
 *
 * Tuple where:
 *   - 0: key -
 *   - 1: left -
 *   - 2: right -
 */
export type DecodedCosmosIcs23CompressedNonExistenceProof = [
    atu8_key?: Uint8Array,
    a_left?: DecodedCosmosIcs23CompressedExistenceProof,
    a_right?: DecodedCosmosIcs23CompressedExistenceProof
];
/**
 * Decodes a protobuf CompressedNonExistenceProof message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosIcs23CompressedNonExistenceProof}
 */
export declare const decodeCosmosIcs23CompressedNonExistenceProof: (atu8_payload: Uint8Array) => DecodedCosmosIcs23CompressedNonExistenceProof;
/**
 * Destructures the fields of a {@link CosmosIcs23ExistenceProof} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: key -
 *   - 1: value -
 *   - 2: leaf -
 *   - 3: path -
 */
export declare const destructCosmosIcs23ExistenceProof: (g_struct: CosmosIcs23ExistenceProof) => [key?: Uint8Array, value?: Uint8Array, leaf?: CosmosIcs23LeafOp, path?: CosmosIcs23InnerOp[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_ICS23_EXISTENCE_PROOF = "/cosmos.ics23.v1.ExistenceProof";
/**
 * JSON serialization of `cosmos.ics23.v1.ExistenceProof` - * ExistenceProof takes a key and a value and a set of steps to perform on it. The result of peforming all these steps will provide a "root hash", which can be compared to the value in a header. Since it is computationally infeasible to produce a hash collission for any of the used cryptographic hash functions, if someone can provide a series of operations to transform a given key and value into a root hash that matches some trusted root, these key and values must be in the referenced merkle tree. The only possible issue is maliablity in LeafOp, such as providing extra prefix data, which should be controlled by a spec. Eg. with lengthOp as NONE, prefix = FOO, key = BAR, value = CHOICE and prefix = F, key = OOBAR, value = CHOICE would produce the same value. With LengthOp this is tricker but not impossible. Which is why the "leafPrefixEqual" field in the ProofSpec is valuable to prevent this mutability. And why all trees should length-prefix the data before hashing it.
 */
export type CosmosIcs23ExistenceProof = {
    key?: CwBase64 | undefined;
    value?: CwBase64 | undefined;
    leaf?: CosmosIcs23LeafOp | undefined;
    path?: CosmosIcs23InnerOp[] | undefined;
};
/**
 * Destructures the fields of a {@link CosmosIcs23LeafOp} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: hash -
 *   - 1: prehash_key -
 *   - 2: prehash_value -
 *   - 3: length -
 *   - 4: prefix - a fixed bytes that may optionally be included at the beginning to differentiate a leaf node from an inner node.
 */
export declare const destructCosmosIcs23LeafOp: (g_struct: CosmosIcs23LeafOp) => [hash?: JsonEnumCosmosIcs23HashOp, prehash_key?: JsonEnumCosmosIcs23HashOp, prehash_value?: JsonEnumCosmosIcs23HashOp, length?: JsonEnumCosmosIcs23LengthOp, prefix?: Uint8Array];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_ICS23_LEAF_OP = "/cosmos.ics23.v1.LeafOp";
/**
 * JSON serialization of `cosmos.ics23.v1.LeafOp` - * LeafOp represents the raw key-value data we wish to prove, and must be flexible to represent the internal transformation from the original key-value pairs into the basis hash, for many existing merkle trees. key and value are passed in. So that the signature of this operation is: leafOp(key, value) -> output To process this, first prehash the keys and values if needed (ANY means no hash in this case): hkey = prehashKey(key) hvalue = prehashValue(value) Then combine the bytes, and hash it output = hash(prefix || length(hkey) || hkey || length(hvalue) || hvalue)
 */
export type CosmosIcs23LeafOp = {
    hash?: JsonEnumCosmosIcs23HashOp | undefined;
    prehash_key?: JsonEnumCosmosIcs23HashOp | undefined;
    prehash_value?: JsonEnumCosmosIcs23HashOp | undefined;
    length?: JsonEnumCosmosIcs23LengthOp | undefined;
    prefix?: CwBase64 | undefined;
};
/**
 * Destructures the fields of a {@link CosmosIcs23InnerOp} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: hash -
 *   - 1: prefix -
 *   - 2: suffix -
 */
export declare const destructCosmosIcs23InnerOp: (g_struct: CosmosIcs23InnerOp) => [hash?: JsonEnumCosmosIcs23HashOp, prefix?: Uint8Array, suffix?: Uint8Array];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_ICS23_INNER_OP = "/cosmos.ics23.v1.InnerOp";
/**
 * JSON serialization of `cosmos.ics23.v1.InnerOp` - * InnerOp represents a merkle-proof step that is not a leaf. It represents concatenating two children and hashing them to provide the next result. The result of the previous step is passed in, so the signature of this op is: innerOp(child) -> output The result of applying InnerOp should be: output = op.hash(op.prefix || child || op.suffix) where the || operator is concatenation of binary data, and child is the result of hashing all the tree below this step. Any special data, like prepending child with the length, or prepending the entire operation with some value to differentiate from leaf nodes, should be included in prefix and suffix. If either of prefix or suffix is empty, we just treat it as an empty string
 */
export type CosmosIcs23InnerOp = {
    hash?: JsonEnumCosmosIcs23HashOp | undefined;
    prefix?: CwBase64 | undefined;
    suffix?: CwBase64 | undefined;
};
/**
 * Destructures the fields of a {@link CosmosIcs23NonExistenceProof} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: key -
 *   - 1: left -
 *   - 2: right -
 */
export declare const destructCosmosIcs23NonExistenceProof: (g_struct: CosmosIcs23NonExistenceProof) => [key?: Uint8Array, left?: CosmosIcs23ExistenceProof, right?: CosmosIcs23ExistenceProof];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_ICS23_NON_EXISTENCE_PROOF = "/cosmos.ics23.v1.NonExistenceProof";
/**
 * JSON serialization of `cosmos.ics23.v1.NonExistenceProof` - takes a proof of two neighbors, one left of the desired key, one right of the desired key. If both proofs are valid AND they are neighbors, then there is no valid proof for the given key.
 */
export type CosmosIcs23NonExistenceProof = {
    key?: CwBase64 | undefined;
    left?: CosmosIcs23ExistenceProof | undefined;
    right?: CosmosIcs23ExistenceProof | undefined;
};
/**
 * Destructures the fields of a {@link CosmosIcs23CommitmentProof} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: exist -
 *   - 1: nonexist -
 *   - 2: batch -
 *   - 3: compressed -
 */
export declare const destructCosmosIcs23CommitmentProof: (g_struct: CosmosIcs23CommitmentProof) => [exist?: CosmosIcs23ExistenceProof, nonexist?: CosmosIcs23NonExistenceProof, batch?: CosmosIcs23BatchProof, compressed?: CosmosIcs23CompressedBatchProof];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_ICS23_COMMITMENT_PROOF = "/cosmos.ics23.v1.CommitmentProof";
/**
 * JSON serialization of `cosmos.ics23.v1.CommitmentProof` - either an ExistenceProof or a NonExistenceProof, or a Batch of such messages
 */
export type CosmosIcs23CommitmentProof = {
    exist?: CosmosIcs23ExistenceProof | undefined;
    nonexist?: CosmosIcs23NonExistenceProof | undefined;
    batch?: CosmosIcs23BatchProof | undefined;
    compressed?: CosmosIcs23CompressedBatchProof | undefined;
};
/**
 * Destructures the fields of a {@link CosmosIcs23BatchProof} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: entries -
 */
export declare const destructCosmosIcs23BatchProof: (g_struct: CosmosIcs23BatchProof) => [entries?: CosmosIcs23BatchEntry[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_ICS23_BATCH_PROOF = "/cosmos.ics23.v1.BatchProof";
/**
 * JSON serialization of `cosmos.ics23.v1.BatchProof` - a group of multiple proof types than can be compressed
 */
export type CosmosIcs23BatchProof = {
    entries?: CosmosIcs23BatchEntry[] | undefined;
};
/**
 * Destructures the fields of a {@link CosmosIcs23BatchEntry} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: exist -
 *   - 1: nonexist -
 */
export declare const destructCosmosIcs23BatchEntry: (g_struct: CosmosIcs23BatchEntry) => [exist?: CosmosIcs23ExistenceProof, nonexist?: CosmosIcs23NonExistenceProof];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_ICS23_BATCH_ENTRY = "/cosmos.ics23.v1.BatchEntry";
/**
 * JSON serialization of `cosmos.ics23.v1.BatchEntry` - Use BatchEntry not CommitmentProof, to avoid recursion
 */
export type CosmosIcs23BatchEntry = {
    exist?: CosmosIcs23ExistenceProof | undefined;
    nonexist?: CosmosIcs23NonExistenceProof | undefined;
};
/**
 * Destructures the fields of a {@link CosmosIcs23CompressedBatchProof} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: entries -
 *   - 1: lookup_inners -
 */
export declare const destructCosmosIcs23CompressedBatchProof: (g_struct: CosmosIcs23CompressedBatchProof) => [entries?: CosmosIcs23CompressedBatchEntry[], lookup_inners?: CosmosIcs23InnerOp[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_ICS23_COMPRESSED_BATCH_PROOF = "/cosmos.ics23.v1.CompressedBatchProof";
/**
 * JSON serialization of `cosmos.ics23.v1.CompressedBatchProof` -
 */
export type CosmosIcs23CompressedBatchProof = {
    entries?: CosmosIcs23CompressedBatchEntry[] | undefined;
    lookup_inners?: CosmosIcs23InnerOp[] | undefined;
};
/**
 * Destructures the fields of a {@link CosmosIcs23CompressedBatchEntry} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: exist -
 *   - 1: nonexist -
 */
export declare const destructCosmosIcs23CompressedBatchEntry: (g_struct: CosmosIcs23CompressedBatchEntry) => [exist?: CosmosIcs23CompressedExistenceProof, nonexist?: CosmosIcs23CompressedNonExistenceProof];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_ICS23_COMPRESSED_BATCH_ENTRY = "/cosmos.ics23.v1.CompressedBatchEntry";
/**
 * JSON serialization of `cosmos.ics23.v1.CompressedBatchEntry` - Use BatchEntry not CommitmentProof, to avoid recursion
 */
export type CosmosIcs23CompressedBatchEntry = {
    exist?: CosmosIcs23CompressedExistenceProof | undefined;
    nonexist?: CosmosIcs23CompressedNonExistenceProof | undefined;
};
/**
 * Destructures the fields of a {@link CosmosIcs23CompressedExistenceProof} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: key -
 *   - 1: value -
 *   - 2: leaf -
 *   - 3: path - these are indexes into the lookup_inners table in CompressedBatchProof
 */
export declare const destructCosmosIcs23CompressedExistenceProof: (g_struct: CosmosIcs23CompressedExistenceProof) => [key?: Uint8Array, value?: Uint8Array, leaf?: CosmosIcs23LeafOp, path?: number[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_ICS23_COMPRESSED_EXISTENCE_PROOF = "/cosmos.ics23.v1.CompressedExistenceProof";
/**
 * JSON serialization of `cosmos.ics23.v1.CompressedExistenceProof` -
 */
export type CosmosIcs23CompressedExistenceProof = {
    key?: CwBase64 | undefined;
    value?: CwBase64 | undefined;
    leaf?: CosmosIcs23LeafOp | undefined;
    path?: number[] | undefined;
};
/**
 * Destructures the fields of a {@link CosmosIcs23CompressedNonExistenceProof} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: key -
 *   - 1: left -
 *   - 2: right -
 */
export declare const destructCosmosIcs23CompressedNonExistenceProof: (g_struct: CosmosIcs23CompressedNonExistenceProof) => [key?: Uint8Array, left?: CosmosIcs23CompressedExistenceProof, right?: CosmosIcs23CompressedExistenceProof];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_ICS23_COMPRESSED_NON_EXISTENCE_PROOF = "/cosmos.ics23.v1.CompressedNonExistenceProof";
/**
 * JSON serialization of `cosmos.ics23.v1.CompressedNonExistenceProof` -
 */
export type CosmosIcs23CompressedNonExistenceProof = {
    key?: CwBase64 | undefined;
    left?: CosmosIcs23CompressedExistenceProof | undefined;
    right?: CosmosIcs23CompressedExistenceProof | undefined;
};
/**
 * Destructures the fields of a {@link CosmosIcs23ProofSpec} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: leaf_spec - any field in the ExistenceProof must be the same as in this spec. except Prefix, which is just the first bytes of prefix (spec can be longer)
 *   - 1: inner_spec -
 *   - 2: max_depth - (if > 0) is the maximum number of InnerOps allowed (mainly for fixed-depth tries)
 *   - 3: min_depth - (if > 0) is the minimum number of InnerOps allowed (mainly for fixed-depth tries)
 *   - 4: prehash_key_before_comparison - a flag that indicates whether to use the prehash_key specified by LeafOp to compare lexical ordering of keys for non-existence proofs.
 */
export declare const destructCosmosIcs23ProofSpec: (g_struct: CosmosIcs23ProofSpec) => [leaf_spec?: CosmosIcs23LeafOp, inner_spec?: CosmosIcs23InnerSpec, max_depth?: number, min_depth?: number, prehash_key_before_comparison?: boolean];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_ICS23_PROOF_SPEC = "/cosmos.ics23.v1.ProofSpec";
/**
 * JSON serialization of `cosmos.ics23.v1.ProofSpec` - * ProofSpec defines what the expected parameters are for a given proof type. This can be stored in the client and used to validate any incoming proofs. verify(ProofSpec, Proof) -> Proof | Error As demonstrated in tests, if we don't fix the algorithm used to calculate the LeafHash for a given tree, there are many possible key-value pairs that can generate a given hash (by interpretting the preimage differently). We need this for proper security, requires client knows a priori what tree format server uses. But not in code, rather a configuration object.
 */
export type CosmosIcs23ProofSpec = {
    leaf_spec?: CosmosIcs23LeafOp | undefined;
    inner_spec?: CosmosIcs23InnerSpec | undefined;
    max_depth?: number | undefined;
    min_depth?: number | undefined;
    prehash_key_before_comparison?: boolean | undefined;
};
/**
 * Destructures the fields of a {@link CosmosIcs23InnerSpec} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: child_order - Child order is the ordering of the children node, must count from 0 iavl tree is [0, 1] (left then right) merk is [0, 2, 1] (left, right, here)
 *   - 1: child_size -
 *   - 2: min_prefix_length -
 *   - 3: max_prefix_length -
 *   - 4: empty_child - empty child is the prehash image that is used when one child is nil (eg. 20 bytes of 0)
 *   - 5: hash - the algorithm that must be used for each InnerOp
 */
export declare const destructCosmosIcs23InnerSpec: (g_struct: CosmosIcs23InnerSpec) => [child_order?: number[], child_size?: number, min_prefix_length?: number, max_prefix_length?: number, empty_child?: Uint8Array, hash?: JsonEnumCosmosIcs23HashOp];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_ICS23_INNER_SPEC = "/cosmos.ics23.v1.InnerSpec";
/**
 * JSON serialization of `cosmos.ics23.v1.InnerSpec` - contains all store-specific structure info to determine if two proofs from a given store are neighbors. This enables: isLeftMost(spec: InnerSpec, op: InnerOp) isRightMost(spec: InnerSpec, op: InnerOp) isLeftNeighbor(spec: InnerSpec, left: InnerOp, right: InnerOp)
 */
export type CosmosIcs23InnerSpec = {
    child_order?: number[] | undefined;
    child_size?: number | undefined;
    min_prefix_length?: number | undefined;
    max_prefix_length?: number | undefined;
    empty_child?: CwBase64 | undefined;
    hash?: JsonEnumCosmosIcs23HashOp | undefined;
};
/**
 * Protobuf enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **NO_HASH** - the default if no data passed. Note this is an illegal argument some places.
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23HashOp}
 */
export declare const XC_PROTO_COSMOS_ICS23HASH_OP_NO_HASH = 0;
/**
 * JSON enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **NO_HASH** - the default if no data passed. Note this is an illegal argument some places.
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23HashOp}
 */
export declare const SI_JSON_COSMOS_ICS23HASH_OP_NO_HASH = "NO_HASH";
/**
 * Protobuf enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **SHA256** -
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23HashOp}
 */
export declare const XC_PROTO_COSMOS_ICS23HASH_OP_SHA256 = 1;
/**
 * JSON enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **SHA256** -
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23HashOp}
 */
export declare const SI_JSON_COSMOS_ICS23HASH_OP_SHA256 = "SHA256";
/**
 * Protobuf enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **SHA512** -
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23HashOp}
 */
export declare const XC_PROTO_COSMOS_ICS23HASH_OP_SHA512 = 2;
/**
 * JSON enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **SHA512** -
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23HashOp}
 */
export declare const SI_JSON_COSMOS_ICS23HASH_OP_SHA512 = "SHA512";
/**
 * Protobuf enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **KECCAK256** -
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23HashOp}
 */
export declare const XC_PROTO_COSMOS_ICS23HASH_OP_KECCAK256 = 3;
/**
 * JSON enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **KECCAK256** -
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23HashOp}
 */
export declare const SI_JSON_COSMOS_ICS23HASH_OP_KECCAK256 = "KECCAK256";
/**
 * Protobuf enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **RIPEMD160** -
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23HashOp}
 */
export declare const XC_PROTO_COSMOS_ICS23HASH_OP_RIPEMD160 = 4;
/**
 * JSON enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **RIPEMD160** -
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23HashOp}
 */
export declare const SI_JSON_COSMOS_ICS23HASH_OP_RIPEMD160 = "RIPEMD160";
/**
 * Protobuf enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **BITCOIN** -
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23HashOp}
 */
export declare const XC_PROTO_COSMOS_ICS23HASH_OP_BITCOIN = 5;
/**
 * JSON enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **BITCOIN** -
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23HashOp}
 */
export declare const SI_JSON_COSMOS_ICS23HASH_OP_BITCOIN = "BITCOIN";
/**
 * Protobuf enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **SHA512_256** -
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23HashOp}
 */
export declare const XC_PROTO_COSMOS_ICS23HASH_OP_SHA512_256 = 6;
/**
 * JSON enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **SHA512_256** -
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23HashOp}
 */
export declare const SI_JSON_COSMOS_ICS23HASH_OP_SHA512_256 = "SHA512_256";
/**
 * Protobuf enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **BLAKE2B_512** -
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23HashOp}
 */
export declare const XC_PROTO_COSMOS_ICS23HASH_OP_BLAKE2B_512 = 7;
/**
 * JSON enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **BLAKE2B_512** -
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23HashOp}
 */
export declare const SI_JSON_COSMOS_ICS23HASH_OP_BLAKE2B_512 = "BLAKE2B_512";
/**
 * Protobuf enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **BLAKE2S_256** -
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23HashOp}
 */
export declare const XC_PROTO_COSMOS_ICS23HASH_OP_BLAKE2S_256 = 8;
/**
 * JSON enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **BLAKE2S_256** -
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23HashOp}
 */
export declare const SI_JSON_COSMOS_ICS23HASH_OP_BLAKE2S_256 = "BLAKE2S_256";
/**
 * Protobuf enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **BLAKE3** -
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23HashOp}
 */
export declare const XC_PROTO_COSMOS_ICS23HASH_OP_BLAKE3 = 9;
/**
 * JSON enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **BLAKE3** -
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23HashOp}
 */
export declare const SI_JSON_COSMOS_ICS23HASH_OP_BLAKE3 = "BLAKE3";
/**
 * Raw protobuf enum values for `cosmos.ics23.v1.HashOp` to be used when passing to an encoder or comparing to a decoded protobuf value.
 *
 * Values:
 *   - {@link XC_PROTO_COSMOS_ICS23HASH_OP_NO_HASH}
 *   - {@link XC_PROTO_COSMOS_ICS23HASH_OP_SHA256}
 *   - {@link XC_PROTO_COSMOS_ICS23HASH_OP_SHA512}
 *   - {@link XC_PROTO_COSMOS_ICS23HASH_OP_KECCAK256}
 *   - {@link XC_PROTO_COSMOS_ICS23HASH_OP_RIPEMD160}
 *   - {@link XC_PROTO_COSMOS_ICS23HASH_OP_BITCOIN}
 *   - {@link XC_PROTO_COSMOS_ICS23HASH_OP_SHA512_256}
 *   - {@link XC_PROTO_COSMOS_ICS23HASH_OP_BLAKE2B_512}
 *   - {@link XC_PROTO_COSMOS_ICS23HASH_OP_BLAKE2S_256}
 *   - {@link XC_PROTO_COSMOS_ICS23HASH_OP_BLAKE3}
 */
export type ProtoEnumCosmosIcs23HashOp = typeof XC_PROTO_COSMOS_ICS23HASH_OP_NO_HASH | typeof XC_PROTO_COSMOS_ICS23HASH_OP_SHA256 | typeof XC_PROTO_COSMOS_ICS23HASH_OP_SHA512 | typeof XC_PROTO_COSMOS_ICS23HASH_OP_KECCAK256 | typeof XC_PROTO_COSMOS_ICS23HASH_OP_RIPEMD160 | typeof XC_PROTO_COSMOS_ICS23HASH_OP_BITCOIN | typeof XC_PROTO_COSMOS_ICS23HASH_OP_SHA512_256 | typeof XC_PROTO_COSMOS_ICS23HASH_OP_BLAKE2B_512 | typeof XC_PROTO_COSMOS_ICS23HASH_OP_BLAKE2S_256 | typeof XC_PROTO_COSMOS_ICS23HASH_OP_BLAKE3;
/**
 * JSON enum values for `cosmos.ics23.v1.HashOp` to be used when passing to a gRPC-gateway method or comparing to a response value
 *
 * Values:
 *   - {@link SI_JSON_COSMOS_ICS23HASH_OP_NO_HASH}
 *   - {@link SI_JSON_COSMOS_ICS23HASH_OP_SHA256}
 *   - {@link SI_JSON_COSMOS_ICS23HASH_OP_SHA512}
 *   - {@link SI_JSON_COSMOS_ICS23HASH_OP_KECCAK256}
 *   - {@link SI_JSON_COSMOS_ICS23HASH_OP_RIPEMD160}
 *   - {@link SI_JSON_COSMOS_ICS23HASH_OP_BITCOIN}
 *   - {@link SI_JSON_COSMOS_ICS23HASH_OP_SHA512_256}
 *   - {@link SI_JSON_COSMOS_ICS23HASH_OP_BLAKE2B_512}
 *   - {@link SI_JSON_COSMOS_ICS23HASH_OP_BLAKE2S_256}
 *   - {@link SI_JSON_COSMOS_ICS23HASH_OP_BLAKE3}
 */
export type JsonEnumCosmosIcs23HashOp = typeof SI_JSON_COSMOS_ICS23HASH_OP_NO_HASH | typeof SI_JSON_COSMOS_ICS23HASH_OP_SHA256 | typeof SI_JSON_COSMOS_ICS23HASH_OP_SHA512 | typeof SI_JSON_COSMOS_ICS23HASH_OP_KECCAK256 | typeof SI_JSON_COSMOS_ICS23HASH_OP_RIPEMD160 | typeof SI_JSON_COSMOS_ICS23HASH_OP_BITCOIN | typeof SI_JSON_COSMOS_ICS23HASH_OP_SHA512_256 | typeof SI_JSON_COSMOS_ICS23HASH_OP_BLAKE2B_512 | typeof SI_JSON_COSMOS_ICS23HASH_OP_BLAKE2S_256 | typeof SI_JSON_COSMOS_ICS23HASH_OP_BLAKE3;
/**
 * Maps a protobuf enum int value for `cosmos.ics23.v1.HashOp` to is JSON equivalent enum string value
 */
export declare const ProtoToJsonEnumCosmosIcs23HashOp: Record<ProtoEnumCosmosIcs23HashOp, JsonEnumCosmosIcs23HashOp>;
/**
 * Maps a JSON enum string value for `cosmos.ics23.v1.HashOp` to is protobuf equivalent enum int value
 */
export declare const JsonToProtoEnumCosmosIcs23HashOp: Record<JsonEnumCosmosIcs23HashOp, ProtoEnumCosmosIcs23HashOp>;
/**
 * Protobuf enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **NO_PREFIX** - don't include any length info
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23LengthOp}
 */
export declare const XC_PROTO_COSMOS_ICS23LENGTH_OP_NO_PREFIX = 0;
/**
 * JSON enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **NO_PREFIX** - don't include any length info
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23LengthOp}
 */
export declare const SI_JSON_COSMOS_ICS23LENGTH_OP_NO_PREFIX = "NO_PREFIX";
/**
 * Protobuf enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **VAR_PROTO** - uses protobuf (and go-amino) varint encoding of the length
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23LengthOp}
 */
export declare const XC_PROTO_COSMOS_ICS23LENGTH_OP_VAR_PROTO = 1;
/**
 * JSON enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **VAR_PROTO** - uses protobuf (and go-amino) varint encoding of the length
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23LengthOp}
 */
export declare const SI_JSON_COSMOS_ICS23LENGTH_OP_VAR_PROTO = "VAR_PROTO";
/**
 * Protobuf enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **VAR_RLP** - uses rlp int encoding of the length
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23LengthOp}
 */
export declare const XC_PROTO_COSMOS_ICS23LENGTH_OP_VAR_RLP = 2;
/**
 * JSON enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **VAR_RLP** - uses rlp int encoding of the length
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23LengthOp}
 */
export declare const SI_JSON_COSMOS_ICS23LENGTH_OP_VAR_RLP = "VAR_RLP";
/**
 * Protobuf enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **FIXED32_BIG** - uses big-endian encoding of the length as a 32 bit integer
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23LengthOp}
 */
export declare const XC_PROTO_COSMOS_ICS23LENGTH_OP_FIXED32_BIG = 3;
/**
 * JSON enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **FIXED32_BIG** - uses big-endian encoding of the length as a 32 bit integer
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23LengthOp}
 */
export declare const SI_JSON_COSMOS_ICS23LENGTH_OP_FIXED32_BIG = "FIXED32_BIG";
/**
 * Protobuf enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **FIXED32_LITTLE** - uses little-endian encoding of the length as a 32 bit integer
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23LengthOp}
 */
export declare const XC_PROTO_COSMOS_ICS23LENGTH_OP_FIXED32_LITTLE = 4;
/**
 * JSON enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **FIXED32_LITTLE** - uses little-endian encoding of the length as a 32 bit integer
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23LengthOp}
 */
export declare const SI_JSON_COSMOS_ICS23LENGTH_OP_FIXED32_LITTLE = "FIXED32_LITTLE";
/**
 * Protobuf enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **FIXED64_BIG** - uses big-endian encoding of the length as a 64 bit integer
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23LengthOp}
 */
export declare const XC_PROTO_COSMOS_ICS23LENGTH_OP_FIXED64_BIG = 5;
/**
 * JSON enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **FIXED64_BIG** - uses big-endian encoding of the length as a 64 bit integer
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23LengthOp}
 */
export declare const SI_JSON_COSMOS_ICS23LENGTH_OP_FIXED64_BIG = "FIXED64_BIG";
/**
 * Protobuf enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **FIXED64_LITTLE** - uses little-endian encoding of the length as a 64 bit integer
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23LengthOp}
 */
export declare const XC_PROTO_COSMOS_ICS23LENGTH_OP_FIXED64_LITTLE = 6;
/**
 * JSON enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **FIXED64_LITTLE** - uses little-endian encoding of the length as a 64 bit integer
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23LengthOp}
 */
export declare const SI_JSON_COSMOS_ICS23LENGTH_OP_FIXED64_LITTLE = "FIXED64_LITTLE";
/**
 * Protobuf enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **REQUIRE_32_BYTES** - like NONE, but will fail if the input is not exactly 32 bytes (sha256 output)
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23LengthOp}
 */
export declare const XC_PROTO_COSMOS_ICS23LENGTH_OP_REQUIRE_32_BYTES = 7;
/**
 * JSON enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **REQUIRE_32_BYTES** - like NONE, but will fail if the input is not exactly 32 bytes (sha256 output)
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23LengthOp}
 */
export declare const SI_JSON_COSMOS_ICS23LENGTH_OP_REQUIRE_32_BYTES = "REQUIRE_32_BYTES";
/**
 * Protobuf enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **REQUIRE_64_BYTES** - like NONE, but will fail if the input is not exactly 64 bytes (sha512 output)
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23LengthOp}
 */
export declare const XC_PROTO_COSMOS_ICS23LENGTH_OP_REQUIRE_64_BYTES = 8;
/**
 * JSON enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **REQUIRE_64_BYTES** - like NONE, but will fail if the input is not exactly 64 bytes (sha512 output)
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23LengthOp}
 */
export declare const SI_JSON_COSMOS_ICS23LENGTH_OP_REQUIRE_64_BYTES = "REQUIRE_64_BYTES";
/**
 * Raw protobuf enum values for `cosmos.ics23.v1.LengthOp` to be used when passing to an encoder or comparing to a decoded protobuf value.
 *
 * Values:
 *   - {@link XC_PROTO_COSMOS_ICS23LENGTH_OP_NO_PREFIX}
 *   - {@link XC_PROTO_COSMOS_ICS23LENGTH_OP_VAR_PROTO}
 *   - {@link XC_PROTO_COSMOS_ICS23LENGTH_OP_VAR_RLP}
 *   - {@link XC_PROTO_COSMOS_ICS23LENGTH_OP_FIXED32_BIG}
 *   - {@link XC_PROTO_COSMOS_ICS23LENGTH_OP_FIXED32_LITTLE}
 *   - {@link XC_PROTO_COSMOS_ICS23LENGTH_OP_FIXED64_BIG}
 *   - {@link XC_PROTO_COSMOS_ICS23LENGTH_OP_FIXED64_LITTLE}
 *   - {@link XC_PROTO_COSMOS_ICS23LENGTH_OP_REQUIRE_32_BYTES}
 *   - {@link XC_PROTO_COSMOS_ICS23LENGTH_OP_REQUIRE_64_BYTES}
 */
export type ProtoEnumCosmosIcs23LengthOp = typeof XC_PROTO_COSMOS_ICS23LENGTH_OP_NO_PREFIX | typeof XC_PROTO_COSMOS_ICS23LENGTH_OP_VAR_PROTO | typeof XC_PROTO_COSMOS_ICS23LENGTH_OP_VAR_RLP | typeof XC_PROTO_COSMOS_ICS23LENGTH_OP_FIXED32_BIG | typeof XC_PROTO_COSMOS_ICS23LENGTH_OP_FIXED32_LITTLE | typeof XC_PROTO_COSMOS_ICS23LENGTH_OP_FIXED64_BIG | typeof XC_PROTO_COSMOS_ICS23LENGTH_OP_FIXED64_LITTLE | typeof XC_PROTO_COSMOS_ICS23LENGTH_OP_REQUIRE_32_BYTES | typeof XC_PROTO_COSMOS_ICS23LENGTH_OP_REQUIRE_64_BYTES;
/**
 * JSON enum values for `cosmos.ics23.v1.LengthOp` to be used when passing to a gRPC-gateway method or comparing to a response value
 *
 * Values:
 *   - {@link SI_JSON_COSMOS_ICS23LENGTH_OP_NO_PREFIX}
 *   - {@link SI_JSON_COSMOS_ICS23LENGTH_OP_VAR_PROTO}
 *   - {@link SI_JSON_COSMOS_ICS23LENGTH_OP_VAR_RLP}
 *   - {@link SI_JSON_COSMOS_ICS23LENGTH_OP_FIXED32_BIG}
 *   - {@link SI_JSON_COSMOS_ICS23LENGTH_OP_FIXED32_LITTLE}
 *   - {@link SI_JSON_COSMOS_ICS23LENGTH_OP_FIXED64_BIG}
 *   - {@link SI_JSON_COSMOS_ICS23LENGTH_OP_FIXED64_LITTLE}
 *   - {@link SI_JSON_COSMOS_ICS23LENGTH_OP_REQUIRE_32_BYTES}
 *   - {@link SI_JSON_COSMOS_ICS23LENGTH_OP_REQUIRE_64_BYTES}
 */
export type JsonEnumCosmosIcs23LengthOp = typeof SI_JSON_COSMOS_ICS23LENGTH_OP_NO_PREFIX | typeof SI_JSON_COSMOS_ICS23LENGTH_OP_VAR_PROTO | typeof SI_JSON_COSMOS_ICS23LENGTH_OP_VAR_RLP | typeof SI_JSON_COSMOS_ICS23LENGTH_OP_FIXED32_BIG | typeof SI_JSON_COSMOS_ICS23LENGTH_OP_FIXED32_LITTLE | typeof SI_JSON_COSMOS_ICS23LENGTH_OP_FIXED64_BIG | typeof SI_JSON_COSMOS_ICS23LENGTH_OP_FIXED64_LITTLE | typeof SI_JSON_COSMOS_ICS23LENGTH_OP_REQUIRE_32_BYTES | typeof SI_JSON_COSMOS_ICS23LENGTH_OP_REQUIRE_64_BYTES;
/**
 * Maps a protobuf enum int value for `cosmos.ics23.v1.LengthOp` to is JSON equivalent enum string value
 */
export declare const ProtoToJsonEnumCosmosIcs23LengthOp: Record<ProtoEnumCosmosIcs23LengthOp, JsonEnumCosmosIcs23LengthOp>;
/**
 * Maps a JSON enum string value for `cosmos.ics23.v1.LengthOp` to is protobuf equivalent enum int value
 */
export declare const JsonToProtoEnumCosmosIcs23LengthOp: Record<JsonEnumCosmosIcs23LengthOp, ProtoEnumCosmosIcs23LengthOp>;
