/*
* ================================
*     GENERATED FILE WARNING
* Do not edit this file manually.
* ================================
*/
import { decode_protobuf } from '../../../../api/protobuf-reader.js';
import { Protobuf } from '../../../../api/protobuf-writer.js';
/**
 * Encodes a `TableDescriptor` protobuf message: describes an ORM table.
 * @param g_primary_key - `primary_key`: defines the primary key for the table.
 * @param a_indexs - `index`: defines one or more secondary indexes.
 * @param n_id - `id`: a non-zero integer ID that must be unique within the tables and singletons in this file. It may be deprecated in the future when this can be auto-generated.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosOrmTableDescriptor = (atu8_primary_key, a_indexs, n_id) => Protobuf() // ...
    .b(atu8_primary_key) // PrimaryKeyDescriptor primary_key = 1
    .B(a_indexs) // SecondaryIndexDescriptor[] index = 2
    .v(n_id) // uint32 id = 3
    .o;
/**
 * Encodes a `PrimaryKeyDescriptor` protobuf message: describes a table primary key.
 * @param s_fields - `fields`: a comma-separated list of fields in the primary key. Spaces are not allowed. Supported field types, their encodings, and any applicable constraints are described below. - uint32 are encoded as 2,3,4 or 5 bytes using a compact encoding that is suitable for sorted iteration (not varint encoding). This type is well-suited for small integers. - uint64 are encoded as 2,4,6 or 9 bytes using a compact encoding that is suitable for sorted iteration (not varint encoding). This type is well-suited for small integers such as auto-incrementing sequences. - fixed32, fixed64 are encoded as big-endian fixed width bytes and support sorted iteration. These types are well-suited for encoding fixed with decimals as integers. - string's are encoded as raw bytes in terminal key segments and null-terminated in non-terminal segments. Null characters are thus forbidden in strings. string fields support sorted iteration. - bytes are encoded as raw bytes in terminal segments and length-prefixed with a 32-bit unsigned varint in non-terminal segments. - int32, sint32, int64, sint64, sfixed32, sfixed64 are encoded as fixed width bytes with an encoding that enables sorted iteration. - google.protobuf.Timestamp is encoded such that values with only seconds occupy 6 bytes, values including nanos occupy 9 bytes, and nil values occupy 1 byte. When iterating, nil values will always be ordered last. Seconds and nanos values must conform to the officially specified ranges of 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z and 0 to 999,999,999 respectively. - google.protobuf.Duration is encoded as 12 bytes using an encoding that enables sorted iteration. - enum fields are encoded using varint encoding and do not support sorted iteration. - bool fields are encoded as a single byte 0 or 1. All other fields types are unsupported in keys including repeated and oneof fields. Primary keys are prefixed by the varint encoded table id and the byte 0x0 plus any additional prefix specified by the schema.
 * @param b_auto_increment - `auto_increment`: specifies that the primary key is generated by an auto-incrementing integer. If this is set to true fields must only contain one field of that is of type uint64.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosOrmPrimaryKeyDescriptor = (s_fields, b_auto_increment) => Protobuf() // ...
    .s(s_fields) // string fields = 1
    .v(b_auto_increment) // boolean auto_increment = 2
    .o;
/**
 * Encodes a `SecondaryIndexDescriptor` protobuf message: PrimaryKeyDescriptor describes a table secondary index.
 * @param s_fields - `fields`: a comma-separated list of fields in the index. The supported field types are the same as those for PrimaryKeyDescriptor.fields. Index keys are prefixed by the varint encoded table id and the varint encoded index id plus any additional prefix specified by the schema. In addition the field segments, non-unique index keys are suffixed with any additional primary key fields not present in the index fields so that the primary key can be reconstructed. Unique indexes instead of being suffixed store the remaining primary key fields in the value..
 * @param n_id - `id`: a non-zero integer ID that must be unique within the indexes for this table and less than 32768. It may be deprecated in the future when this can be auto-generated.
 * @param b_unique - `unique`: specifies that this an unique index.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosOrmSecondaryIndexDescriptor = (s_fields, n_id, b_unique) => Protobuf() // ...
    .s(s_fields) // string fields = 1
    .v(n_id) // uint32 id = 2
    .v(b_unique) // boolean unique = 3
    .o;
/**
 * Encodes a `SingletonDescriptor` protobuf message: TableDescriptor describes an ORM singleton table which has at most one instance.
 * @param n_id - `id`: a non-zero integer ID that must be unique within the tables and singletons in this file. It may be deprecated in the future when this can be auto-generated.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosOrmSingletonDescriptor = (n_id) => Protobuf() // ...
    .v(n_id) // uint32 id = 1
    .o;
/**
 * Decodes a protobuf TableDescriptor message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosOrmTableDescriptor}
 */
export const decodeCosmosOrmTableDescriptor = (atu8_payload) => decode_protobuf(atu8_payload, [1, 0, 1], [decodeCosmosOrmPrimaryKeyDescriptor, decodeCosmosOrmSecondaryIndexDescriptor]);
/**
 * Decodes a protobuf PrimaryKeyDescriptor message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosOrmPrimaryKeyDescriptor}
 */
export const decodeCosmosOrmPrimaryKeyDescriptor = (atu8_payload) => decode_protobuf(atu8_payload, [5, 1]);
/**
 * Decodes a protobuf SecondaryIndexDescriptor message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosOrmSecondaryIndexDescriptor}
 */
export const decodeCosmosOrmSecondaryIndexDescriptor = (atu8_payload) => decode_protobuf(atu8_payload, [5, 1, 1]);
/**
 * Decodes a protobuf SingletonDescriptor message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosOrmSingletonDescriptor}
 */
export const decodeCosmosOrmSingletonDescriptor = (atu8_payload) => decode_protobuf(atu8_payload, [1]);
/**
 * Destructures the fields of a {@link CosmosOrmTableDescriptor} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: primary_key - defines the primary key for the table.
 *   - 1: index - defines one or more secondary indexes.
 *   - 2: id - a non-zero integer ID that must be unique within the tables and singletons in this file. It may be deprecated in the future when this can be auto-generated.
 */
export const destructCosmosOrmTableDescriptor = (g_struct) => [g_struct.primary_key, g_struct.index, g_struct.id];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_ORM_TABLE_DESCRIPTOR = '/cosmos.orm.v1.TableDescriptor';
/**
 * Destructures the fields of a {@link CosmosOrmPrimaryKeyDescriptor} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: fields - a comma-separated list of fields in the primary key. Spaces are not allowed. Supported field types, their encodings, and any applicable constraints are described below. - uint32 are encoded as 2,3,4 or 5 bytes using a compact encoding that is suitable for sorted iteration (not varint encoding). This type is well-suited for small integers. - uint64 are encoded as 2,4,6 or 9 bytes using a compact encoding that is suitable for sorted iteration (not varint encoding). This type is well-suited for small integers such as auto-incrementing sequences. - fixed32, fixed64 are encoded as big-endian fixed width bytes and support sorted iteration. These types are well-suited for encoding fixed with decimals as integers. - string's are encoded as raw bytes in terminal key segments and null-terminated in non-terminal segments. Null characters are thus forbidden in strings. string fields support sorted iteration. - bytes are encoded as raw bytes in terminal segments and length-prefixed with a 32-bit unsigned varint in non-terminal segments. - int32, sint32, int64, sint64, sfixed32, sfixed64 are encoded as fixed width bytes with an encoding that enables sorted iteration. - google.protobuf.Timestamp is encoded such that values with only seconds occupy 6 bytes, values including nanos occupy 9 bytes, and nil values occupy 1 byte. When iterating, nil values will always be ordered last. Seconds and nanos values must conform to the officially specified ranges of 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z and 0 to 999,999,999 respectively. - google.protobuf.Duration is encoded as 12 bytes using an encoding that enables sorted iteration. - enum fields are encoded using varint encoding and do not support sorted iteration. - bool fields are encoded as a single byte 0 or 1. All other fields types are unsupported in keys including repeated and oneof fields. Primary keys are prefixed by the varint encoded table id and the byte 0x0 plus any additional prefix specified by the schema.
 *   - 1: auto_increment - specifies that the primary key is generated by an auto-incrementing integer. If this is set to true fields must only contain one field of that is of type uint64.
 */
export const destructCosmosOrmPrimaryKeyDescriptor = (g_struct) => [g_struct.fields, g_struct.auto_increment];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_ORM_PRIMARY_KEY_DESCRIPTOR = '/cosmos.orm.v1.PrimaryKeyDescriptor';
/**
 * Destructures the fields of a {@link CosmosOrmSecondaryIndexDescriptor} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: fields - a comma-separated list of fields in the index. The supported field types are the same as those for PrimaryKeyDescriptor.fields. Index keys are prefixed by the varint encoded table id and the varint encoded index id plus any additional prefix specified by the schema. In addition the field segments, non-unique index keys are suffixed with any additional primary key fields not present in the index fields so that the primary key can be reconstructed. Unique indexes instead of being suffixed store the remaining primary key fields in the value..
 *   - 1: id - a non-zero integer ID that must be unique within the indexes for this table and less than 32768. It may be deprecated in the future when this can be auto-generated.
 *   - 2: unique - specifies that this an unique index.
 */
export const destructCosmosOrmSecondaryIndexDescriptor = (g_struct) => [g_struct.fields, g_struct.id, g_struct.unique];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_ORM_SECONDARY_INDEX_DESCRIPTOR = '/cosmos.orm.v1.SecondaryIndexDescriptor';
/**
 * Destructures the fields of a {@link CosmosOrmSingletonDescriptor} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: id - a non-zero integer ID that must be unique within the tables and singletons in this file. It may be deprecated in the future when this can be auto-generated.
 */
export const destructCosmosOrmSingletonDescriptor = (g_struct) => [g_struct.id];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_ORM_SINGLETON_DESCRIPTOR = '/cosmos.orm.v1.SingletonDescriptor';
//# sourceMappingURL=orm.js.map