import { oda } from '@blake.regalia/belt';
import { decode_protobuf } from '../../../../../api/protobuf-reader.js';
import { Protobuf } from '../../../../../api/protobuf-writer.js';
import { safe_base64_to_bytes } from '../../../../../api/util.js';
import { decodeIbcCoreClientHeight } from '../../client/v1/client.js';
/**
 * Encodes a `Channel` protobuf message: defines pipeline for exactly-once packet delivery between specific modules on separate blockchains, which has at least one end capable of sending packets and one end capable of receiving packets.
 * @param xc_state - `state`: current state of the channel end
 * @param xc_ordering - `ordering`: whether the channel is ordered or unordered
 * @param g_counterparty - `counterparty`: channel end
 * @param a_connection_hops - `connection_hops`: list of connection identifiers, in order, along which packets sent on this channel will travel
 * @param s_version - `version`: opaque channel version, which is agreed upon during the handshake
 * @param sg_upgrade_sequence - `upgrade_sequence`: upgrade sequence indicates the latest upgrade attempt performed by this channel the value of 0 indicates the channel has never been upgraded
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcCoreChannelChannel = (xc_state, xc_ordering, atu8_counterparty, a_connection_hops, s_version, sg_upgrade_sequence) => Protobuf() // ...
    .v(xc_state) // State state = 1
    .v(xc_ordering) // Order ordering = 2
    .b(atu8_counterparty) // Counterparty counterparty = 3
    .S(a_connection_hops) // string[] connection_hops = 4
    .s(s_version) // string version = 5
    .g(sg_upgrade_sequence) // uint64 upgrade_sequence = 6
    .o;
/**
 * Encodes a `IdentifiedChannel` protobuf message: defines a channel with additional port and channel identifier fields.
 * @param xc_state - `state`: current state of the channel end
 * @param xc_ordering - `ordering`: whether the channel is ordered or unordered
 * @param g_counterparty - `counterparty`: channel end
 * @param a_connection_hops - `connection_hops`: list of connection identifiers, in order, along which packets sent on this channel will travel
 * @param s_version - `version`: opaque channel version, which is agreed upon during the handshake
 * @param si_port - `port_id`: port identifier
 * @param si_channel - `channel_id`: channel identifier
 * @param sg_upgrade_sequence - `upgrade_sequence`: upgrade sequence indicates the latest upgrade attempt performed by this channel the value of 0 indicates the channel has never been upgraded
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcCoreChannelIdentifiedChannel = (xc_state, xc_ordering, atu8_counterparty, a_connection_hops, s_version, si_port, si_channel, sg_upgrade_sequence) => Protobuf() // ...
    .v(xc_state) // State state = 1
    .v(xc_ordering) // Order ordering = 2
    .b(atu8_counterparty) // Counterparty counterparty = 3
    .S(a_connection_hops) // string[] connection_hops = 4
    .s(s_version) // string version = 5
    .s(si_port) // string port_id = 6
    .s(si_channel) // string channel_id = 7
    .g(sg_upgrade_sequence) // uint64 upgrade_sequence = 8
    .o;
/**
 * Encodes a `Counterparty` protobuf message: defines a channel end counterparty
 * @param si_port - `port_id`: port on the counterparty chain which owns the other end of the channel.
 * @param si_channel - `channel_id`: channel end on the counterparty chain
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcCoreChannelCounterparty = (si_port, si_channel) => Protobuf() // ...
    .s(si_port) // string port_id = 1
    .s(si_channel) // string channel_id = 2
    .o;
/**
 * Encodes a `Packet` protobuf message: defines a type that carries data across different chains through IBC
 * @param sg_sequence - `sequence`: number corresponds to the order of sends and receives, where a Packet with an earlier sequence number must be sent and received before a Packet with a later sequence number.
 * @param s_source_port - `source_port`: identifies the port on the sending chain.
 * @param s_source_channel - `source_channel`: identifies the channel end on the sending chain.
 * @param s_destination_port - `destination_port`: identifies the port on the receiving chain.
 * @param s_destination_channel - `destination_channel`: identifies the channel end on the receiving chain.
 * @param atu8_data - `data`: actual opaque bytes transferred directly to the application module
 * @param g_timeout_height - `timeout_height`: block height after which the packet times out
 * @param sg_timeout_timestamp - `timeout_timestamp`: block timestamp (in nanoseconds) after which the packet times out
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcCoreChannelPacket = (sg_sequence, s_source_port, s_source_channel, s_destination_port, s_destination_channel, atu8_data, atu8_timeout_height, sg_timeout_timestamp) => Protobuf() // ...
    .g(sg_sequence) // uint64 sequence = 1
    .s(s_source_port) // string source_port = 2
    .s(s_source_channel) // string source_channel = 3
    .s(s_destination_port) // string destination_port = 4
    .s(s_destination_channel) // string destination_channel = 5
    .b(atu8_data) // bytes data = 6
    .b(atu8_timeout_height) // Height timeout_height = 7
    .g(sg_timeout_timestamp) // uint64 timeout_timestamp = 8
    .o;
/**
 * Encodes a `PacketState` protobuf message: defines the generic type necessary to retrieve and store packet commitments, acknowledgements, and receipts. Caller is responsible for knowing the context necessary to interpret this state as a commitment, acknowledgement, or a receipt.
 * @param si_port - `port_id`: channel port identifier.
 * @param si_channel - `channel_id`: channel unique identifier.
 * @param sg_sequence - `sequence`: packet sequence.
 * @param atu8_data - `data`: embedded data that represents packet state.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcCoreChannelPacketState = (si_port, si_channel, sg_sequence, atu8_data) => Protobuf() // ...
    .s(si_port) // string port_id = 1
    .s(si_channel) // string channel_id = 2
    .g(sg_sequence) // uint64 sequence = 3
    .b(atu8_data) // bytes data = 4
    .o;
/**
 * Encodes a `PacketId` protobuf message: an identifier for a unique Packet Source chains refer to packets by source port/channel Destination chains refer to packets by destination port/channel
 * @param si_port - `port_id`: channel port identifier
 * @param si_channel - `channel_id`: channel unique identifier
 * @param sg_sequence - `sequence`: packet sequence
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcCoreChannelPacketId = (si_port, si_channel, sg_sequence) => Protobuf() // ...
    .s(si_port) // string port_id = 1
    .s(si_channel) // string channel_id = 2
    .g(sg_sequence) // uint64 sequence = 3
    .o;
/**
 * Encodes a `Acknowledgement` protobuf message: the recommended acknowledgement format to be used by app-specific protocols. NOTE: The field numbers 21 and 22 were explicitly chosen to avoid accidental conflicts with other protobuf message formats used for acknowledgements. The first byte of any message with this format will be the non-ASCII values `0xaa` (result) or `0xb2` (error). Implemented as defined by ICS: https://github.com/cosmos/ibc/tree/master/spec/core/ics-004-channel-and-packet-semantics#acknowledgement-envelope
 * @param atu8_result - `result`:
 * @param s_error - `error`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcCoreChannelAcknowledgement = (atu8_result, s_error) => Protobuf() // ...
    .b(atu8_result, 21) // bytes result = 21
    .s(s_error, 22) // string error = 22
    .o;
/**
 * Encodes a `Timeout` protobuf message: defines an execution deadline structure for 04-channel handlers. This includes packet lifecycle handlers as well as the upgrade handshake handlers. A valid Timeout contains either one or both of a timestamp and block height (sequence).
 * @param g_height - `height`: block height after which the packet or upgrade times out
 * @param sg_timestamp - `timestamp`: block timestamp (in nanoseconds) after which the packet or upgrade times out
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcCoreChannelTimeout = (atu8_height, sg_timestamp) => Protobuf() // ...
    .b(atu8_height) // Height height = 1
    .g(sg_timestamp) // uint64 timestamp = 2
    .o;
/**
 * Encodes a `Params` protobuf message: defines the set of IBC channel parameters.
 * @param g_upgrade_timeout - `upgrade_timeout`: the relative timeout after which channel upgrades will time out.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcCoreChannelParams = (atu8_upgrade_timeout) => Protobuf() // ...
    .b(atu8_upgrade_timeout) // Timeout upgrade_timeout = 1
    .o;
/**
 * Decodes a protobuf Channel message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcCoreChannelChannel}
 */
export const decodeIbcCoreChannelChannel = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1, 1, 4, 5, 3], [0, 0, decodeIbcCoreChannelCounterparty]);
/**
 * Decodes a protobuf IdentifiedChannel message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcCoreChannelIdentifiedChannel}
 */
export const decodeIbcCoreChannelIdentifiedChannel = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1, 1, 4, 5, 5, 5, 3], [0, 0, decodeIbcCoreChannelCounterparty]);
/**
 * Decodes a protobuf Counterparty message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcCoreChannelCounterparty}
 */
export const decodeIbcCoreChannelCounterparty = (atu8_payload) => decode_protobuf(atu8_payload, [5, 5]);
/**
 * Decodes a protobuf Packet message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcCoreChannelPacket}
 */
export const decodeIbcCoreChannelPacket = (atu8_payload) => decode_protobuf(atu8_payload, [3, 5, 5, 5, 5, 1, 1, 3], [0, 0, 0, 0, 0, 0, decodeIbcCoreClientHeight]);
/**
 * Decodes a protobuf PacketState message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcCoreChannelPacketState}
 */
export const decodeIbcCoreChannelPacketState = (atu8_payload) => decode_protobuf(atu8_payload, [5, 5, 3, 1]);
/**
 * Decodes a protobuf PacketId message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcCoreChannelPacketId}
 */
export const decodeIbcCoreChannelPacketId = (atu8_payload) => decode_protobuf(atu8_payload, [5, 5, 3]);
/**
 * Decodes a protobuf Acknowledgement message
 * @param atu8_payload - raw bytes to decode
 * @param RESERVED - a second argument is explicitly forbidden. make sure not to pass this function by reference to some callback argument
 * @returns a {@link DecodedIbcCoreChannelAcknowledgement}
 */
export const decodeIbcCoreChannelAcknowledgement = ((atu8_payload, a_decoded = decode_protobuf(atu8_payload), { 20: atu8_result, 21: s_error } = a_decoded) => oda([], {
    20: atu8_result,
    21: s_error,
}));
/**
 * Decodes a protobuf Timeout message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcCoreChannelTimeout}
 */
export const decodeIbcCoreChannelTimeout = (atu8_payload) => decode_protobuf(atu8_payload, [1, 3], [decodeIbcCoreClientHeight]);
/**
 * Decodes a protobuf Params message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcCoreChannelParams}
 */
export const decodeIbcCoreChannelParams = (atu8_payload) => decode_protobuf(atu8_payload, [1], [decodeIbcCoreChannelTimeout]);
/**
 * Destructures the fields of a {@link IbcCoreChannelIdentifiedChannel} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: state - current state of the channel end
 *   - 1: ordering - whether the channel is ordered or unordered
 *   - 2: counterparty - channel end
 *   - 3: connection_hops - list of connection identifiers, in order, along which packets sent on this channel will travel
 *   - 4: version - opaque channel version, which is agreed upon during the handshake
 *   - 5: port_id - port identifier
 *   - 6: channel_id - channel identifier
 *   - 7: upgrade_sequence - upgrade sequence indicates the latest upgrade attempt performed by this channel the value of 0 indicates the channel has never been upgraded
 */
export const destructIbcCoreChannelIdentifiedChannel = (g_struct) => [g_struct.state, g_struct.ordering, g_struct.counterparty, g_struct.connection_hops, g_struct.version, g_struct.port_id, g_struct.channel_id, g_struct.upgrade_sequence];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_CORE_CHANNEL_IDENTIFIED_CHANNEL = '/ibc.core.channel.v1.IdentifiedChannel';
/**
 * Destructures the fields of a {@link IbcCoreChannelCounterparty} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: port_id - port on the counterparty chain which owns the other end of the channel.
 *   - 1: channel_id - channel end on the counterparty chain
 */
export const destructIbcCoreChannelCounterparty = (g_struct) => [g_struct.port_id, g_struct.channel_id];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_CORE_CHANNEL_COUNTERPARTY = '/ibc.core.channel.v1.Counterparty';
/**
 * Destructures the fields of a {@link IbcCoreChannelPacketState} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: port_id - channel port identifier.
 *   - 1: channel_id - channel unique identifier.
 *   - 2: sequence - packet sequence.
 *   - 3: data - embedded data that represents packet state.
 */
export const destructIbcCoreChannelPacketState = (g_struct) => [g_struct.port_id, g_struct.channel_id, g_struct.sequence, safe_base64_to_bytes(g_struct.data)];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_CORE_CHANNEL_PACKET_STATE = '/ibc.core.channel.v1.PacketState';
/**
 * Destructures the fields of a {@link IbcCoreChannelParams} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: upgrade_timeout - the relative timeout after which channel upgrades will time out.
 */
export const destructIbcCoreChannelParams = (g_struct) => [g_struct.upgrade_timeout];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_CORE_CHANNEL_PARAMS = '/ibc.core.channel.v1.Params';
/**
 * Destructures the fields of a {@link IbcCoreChannelTimeout} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: height - block height after which the packet or upgrade times out
 *   - 1: timestamp - block timestamp (in nanoseconds) after which the packet or upgrade times out
 */
export const destructIbcCoreChannelTimeout = (g_struct) => [g_struct.height, g_struct.timestamp];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_CORE_CHANNEL_TIMEOUT = '/ibc.core.channel.v1.Timeout';
/**
 * Destructures the fields of a {@link IbcCoreChannelChannel} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: state - current state of the channel end
 *   - 1: ordering - whether the channel is ordered or unordered
 *   - 2: counterparty - channel end
 *   - 3: connection_hops - list of connection identifiers, in order, along which packets sent on this channel will travel
 *   - 4: version - opaque channel version, which is agreed upon during the handshake
 *   - 5: upgrade_sequence - upgrade sequence indicates the latest upgrade attempt performed by this channel the value of 0 indicates the channel has never been upgraded
 */
export const destructIbcCoreChannelChannel = (g_struct) => [g_struct.state, g_struct.ordering, g_struct.counterparty, g_struct.connection_hops, g_struct.version, g_struct.upgrade_sequence];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_CORE_CHANNEL_CHANNEL = '/ibc.core.channel.v1.Channel';
/**
 * Destructures the fields of a {@link IbcCoreChannelPacket} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: sequence - number corresponds to the order of sends and receives, where a Packet with an earlier sequence number must be sent and received before a Packet with a later sequence number.
 *   - 1: source_port - identifies the port on the sending chain.
 *   - 2: source_channel - identifies the channel end on the sending chain.
 *   - 3: destination_port - identifies the port on the receiving chain.
 *   - 4: destination_channel - identifies the channel end on the receiving chain.
 *   - 5: data - actual opaque bytes transferred directly to the application module
 *   - 6: timeout_height - block height after which the packet times out
 *   - 7: timeout_timestamp - block timestamp (in nanoseconds) after which the packet times out
 */
export const destructIbcCoreChannelPacket = (g_struct) => [g_struct.sequence, g_struct.source_port, g_struct.source_channel, g_struct.destination_port, g_struct.destination_channel, safe_base64_to_bytes(g_struct.data), g_struct.timeout_height, g_struct.timeout_timestamp];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_CORE_CHANNEL_PACKET = '/ibc.core.channel.v1.Packet';
/**
 * Destructures the fields of a {@link IbcCoreChannelPacketId} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: port_id - channel port identifier
 *   - 1: channel_id - channel unique identifier
 *   - 2: sequence - packet sequence
 */
export const destructIbcCoreChannelPacketId = (g_struct) => [g_struct.port_id, g_struct.channel_id, g_struct.sequence];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_CORE_CHANNEL_PACKET_ID = '/ibc.core.channel.v1.PacketId';
/**
 * Destructures the fields of a {@link IbcCoreChannelAcknowledgement} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 20: result -
 *   - 21: error -
 */
export const destructIbcCoreChannelAcknowledgement = (g_struct) => oda([], {
    21: safe_base64_to_bytes(g_struct.result),
    22: g_struct.error,
});
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_CORE_CHANNEL_ACKNOWLEDGEMENT = '/ibc.core.channel.v1.Acknowledgement';
/**
 * Protobuf enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_UNINITIALIZED_UNSPECIFIED** - Default State
 *
 * Belongs to enum type {@link ProtoEnumIbcCoreChannelState}
 */
export const XC_PROTO_IBC_CORE_CHANNEL_STATE_UNINITIALIZED_UNSPECIFIED = 0;
/**
 * JSON enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_UNINITIALIZED_UNSPECIFIED** - Default State
 *
 * Belongs to enum type {@link JsonEnumIbcCoreChannelState}
 */
export const SI_JSON_IBC_CORE_CHANNEL_STATE_UNINITIALIZED_UNSPECIFIED = 'UNINITIALIZED';
/**
 * Protobuf enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_INIT** - A channel has just started the opening handshake.
 *
 * Belongs to enum type {@link ProtoEnumIbcCoreChannelState}
 */
export const XC_PROTO_IBC_CORE_CHANNEL_STATE_INIT = 1;
/**
 * JSON enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_INIT** - A channel has just started the opening handshake.
 *
 * Belongs to enum type {@link JsonEnumIbcCoreChannelState}
 */
export const SI_JSON_IBC_CORE_CHANNEL_STATE_INIT = 'INIT';
/**
 * Protobuf enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_TRYOPEN** - A channel has acknowledged the handshake step on the counterparty chain.
 *
 * Belongs to enum type {@link ProtoEnumIbcCoreChannelState}
 */
export const XC_PROTO_IBC_CORE_CHANNEL_STATE_TRYOPEN = 2;
/**
 * JSON enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_TRYOPEN** - A channel has acknowledged the handshake step on the counterparty chain.
 *
 * Belongs to enum type {@link JsonEnumIbcCoreChannelState}
 */
export const SI_JSON_IBC_CORE_CHANNEL_STATE_TRYOPEN = 'TRYOPEN';
/**
 * Protobuf enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_OPEN** - A channel has completed the handshake. Open channels are ready to send and receive packets.
 *
 * Belongs to enum type {@link ProtoEnumIbcCoreChannelState}
 */
export const XC_PROTO_IBC_CORE_CHANNEL_STATE_OPEN = 3;
/**
 * JSON enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_OPEN** - A channel has completed the handshake. Open channels are ready to send and receive packets.
 *
 * Belongs to enum type {@link JsonEnumIbcCoreChannelState}
 */
export const SI_JSON_IBC_CORE_CHANNEL_STATE_OPEN = 'OPEN';
/**
 * Protobuf enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_CLOSED** - A channel has been closed and can no longer be used to send or receive packets.
 *
 * Belongs to enum type {@link ProtoEnumIbcCoreChannelState}
 */
export const XC_PROTO_IBC_CORE_CHANNEL_STATE_CLOSED = 4;
/**
 * JSON enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_CLOSED** - A channel has been closed and can no longer be used to send or receive packets.
 *
 * Belongs to enum type {@link JsonEnumIbcCoreChannelState}
 */
export const SI_JSON_IBC_CORE_CHANNEL_STATE_CLOSED = 'CLOSED';
/**
 * Protobuf enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_FLUSHING** - A channel has just accepted the upgrade handshake attempt and is flushing in-flight packets.
 *
 * Belongs to enum type {@link ProtoEnumIbcCoreChannelState}
 */
export const XC_PROTO_IBC_CORE_CHANNEL_STATE_FLUSHING = 5;
/**
 * JSON enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_FLUSHING** - A channel has just accepted the upgrade handshake attempt and is flushing in-flight packets.
 *
 * Belongs to enum type {@link JsonEnumIbcCoreChannelState}
 */
export const SI_JSON_IBC_CORE_CHANNEL_STATE_FLUSHING = 'FLUSHING';
/**
 * Protobuf enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_FLUSHCOMPLETE** - A channel has just completed flushing any in-flight packets.
 *
 * Belongs to enum type {@link ProtoEnumIbcCoreChannelState}
 */
export const XC_PROTO_IBC_CORE_CHANNEL_STATE_FLUSHCOMPLETE = 6;
/**
 * JSON enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_FLUSHCOMPLETE** - A channel has just completed flushing any in-flight packets.
 *
 * Belongs to enum type {@link JsonEnumIbcCoreChannelState}
 */
export const SI_JSON_IBC_CORE_CHANNEL_STATE_FLUSHCOMPLETE = 'FLUSHCOMPLETE';
/**
 * Maps a protobuf enum int value for `ibc.core.channel.v1.State` to is JSON equivalent enum string value
 */
export const ProtoToJsonEnumIbcCoreChannelState = {
    [XC_PROTO_IBC_CORE_CHANNEL_STATE_UNINITIALIZED_UNSPECIFIED]: SI_JSON_IBC_CORE_CHANNEL_STATE_UNINITIALIZED_UNSPECIFIED,
    [XC_PROTO_IBC_CORE_CHANNEL_STATE_INIT]: SI_JSON_IBC_CORE_CHANNEL_STATE_INIT,
    [XC_PROTO_IBC_CORE_CHANNEL_STATE_TRYOPEN]: SI_JSON_IBC_CORE_CHANNEL_STATE_TRYOPEN,
    [XC_PROTO_IBC_CORE_CHANNEL_STATE_OPEN]: SI_JSON_IBC_CORE_CHANNEL_STATE_OPEN,
    [XC_PROTO_IBC_CORE_CHANNEL_STATE_CLOSED]: SI_JSON_IBC_CORE_CHANNEL_STATE_CLOSED,
    [XC_PROTO_IBC_CORE_CHANNEL_STATE_FLUSHING]: SI_JSON_IBC_CORE_CHANNEL_STATE_FLUSHING,
    [XC_PROTO_IBC_CORE_CHANNEL_STATE_FLUSHCOMPLETE]: SI_JSON_IBC_CORE_CHANNEL_STATE_FLUSHCOMPLETE,
};
/**
 * Maps a JSON enum string value for `ibc.core.channel.v1.State` to is protobuf equivalent enum int value
 */
export const JsonToProtoEnumIbcCoreChannelState = {
    [SI_JSON_IBC_CORE_CHANNEL_STATE_UNINITIALIZED_UNSPECIFIED]: XC_PROTO_IBC_CORE_CHANNEL_STATE_UNINITIALIZED_UNSPECIFIED,
    [SI_JSON_IBC_CORE_CHANNEL_STATE_INIT]: XC_PROTO_IBC_CORE_CHANNEL_STATE_INIT,
    [SI_JSON_IBC_CORE_CHANNEL_STATE_TRYOPEN]: XC_PROTO_IBC_CORE_CHANNEL_STATE_TRYOPEN,
    [SI_JSON_IBC_CORE_CHANNEL_STATE_OPEN]: XC_PROTO_IBC_CORE_CHANNEL_STATE_OPEN,
    [SI_JSON_IBC_CORE_CHANNEL_STATE_CLOSED]: XC_PROTO_IBC_CORE_CHANNEL_STATE_CLOSED,
    [SI_JSON_IBC_CORE_CHANNEL_STATE_FLUSHING]: XC_PROTO_IBC_CORE_CHANNEL_STATE_FLUSHING,
    [SI_JSON_IBC_CORE_CHANNEL_STATE_FLUSHCOMPLETE]: XC_PROTO_IBC_CORE_CHANNEL_STATE_FLUSHCOMPLETE,
};
/**
 * Protobuf enum value for `ibc.core.channel.v1.Order`.
 *
 * **ORDER_NONE_UNSPECIFIED** - zero-value for channel ordering
 *
 * Belongs to enum type {@link ProtoEnumIbcCoreChannelOrder}
 */
export const XC_PROTO_IBC_CORE_CHANNEL_ORDER_NONE_UNSPECIFIED = 0;
/**
 * JSON enum value for `ibc.core.channel.v1.Order`.
 *
 * **ORDER_NONE_UNSPECIFIED** - zero-value for channel ordering
 *
 * Belongs to enum type {@link JsonEnumIbcCoreChannelOrder}
 */
export const SI_JSON_IBC_CORE_CHANNEL_ORDER_NONE_UNSPECIFIED = 'NONE';
/**
 * Protobuf enum value for `ibc.core.channel.v1.Order`.
 *
 * **ORDER_UNORDERED** - packets can be delivered in any order, which may differ from the order in which they were sent.
 *
 * Belongs to enum type {@link ProtoEnumIbcCoreChannelOrder}
 */
export const XC_PROTO_IBC_CORE_CHANNEL_ORDER_UNORDERED = 1;
/**
 * JSON enum value for `ibc.core.channel.v1.Order`.
 *
 * **ORDER_UNORDERED** - packets can be delivered in any order, which may differ from the order in which they were sent.
 *
 * Belongs to enum type {@link JsonEnumIbcCoreChannelOrder}
 */
export const SI_JSON_IBC_CORE_CHANNEL_ORDER_UNORDERED = 'UNORDERED';
/**
 * Protobuf enum value for `ibc.core.channel.v1.Order`.
 *
 * **ORDER_ORDERED** - packets are delivered exactly in the order which they were sent
 *
 * Belongs to enum type {@link ProtoEnumIbcCoreChannelOrder}
 */
export const XC_PROTO_IBC_CORE_CHANNEL_ORDER_ORDERED = 2;
/**
 * JSON enum value for `ibc.core.channel.v1.Order`.
 *
 * **ORDER_ORDERED** - packets are delivered exactly in the order which they were sent
 *
 * Belongs to enum type {@link JsonEnumIbcCoreChannelOrder}
 */
export const SI_JSON_IBC_CORE_CHANNEL_ORDER_ORDERED = 'ORDERED';
/**
 * Maps a protobuf enum int value for `ibc.core.channel.v1.Order` to is JSON equivalent enum string value
 */
export const ProtoToJsonEnumIbcCoreChannelOrder = {
    [XC_PROTO_IBC_CORE_CHANNEL_ORDER_NONE_UNSPECIFIED]: SI_JSON_IBC_CORE_CHANNEL_ORDER_NONE_UNSPECIFIED,
    [XC_PROTO_IBC_CORE_CHANNEL_ORDER_UNORDERED]: SI_JSON_IBC_CORE_CHANNEL_ORDER_UNORDERED,
    [XC_PROTO_IBC_CORE_CHANNEL_ORDER_ORDERED]: SI_JSON_IBC_CORE_CHANNEL_ORDER_ORDERED,
};
/**
 * Maps a JSON enum string value for `ibc.core.channel.v1.Order` to is protobuf equivalent enum int value
 */
export const JsonToProtoEnumIbcCoreChannelOrder = {
    [SI_JSON_IBC_CORE_CHANNEL_ORDER_NONE_UNSPECIFIED]: XC_PROTO_IBC_CORE_CHANNEL_ORDER_NONE_UNSPECIFIED,
    [SI_JSON_IBC_CORE_CHANNEL_ORDER_UNORDERED]: XC_PROTO_IBC_CORE_CHANNEL_ORDER_UNORDERED,
    [SI_JSON_IBC_CORE_CHANNEL_ORDER_ORDERED]: XC_PROTO_IBC_CORE_CHANNEL_ORDER_ORDERED,
};
//# sourceMappingURL=channel.js.map