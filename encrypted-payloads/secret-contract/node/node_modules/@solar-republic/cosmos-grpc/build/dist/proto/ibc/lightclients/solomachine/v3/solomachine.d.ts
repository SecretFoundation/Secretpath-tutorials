import type { WeakUint64Str, CwUint64, CwBase64 } from '@solar-republic/types';
import type { Encoded, JsonAny, Opt } from '../../../../../api/types.js';
import type { DecodedGoogleProtobufAny } from '../../../../google/protobuf/any.js';
export type EncodedIbcLightclientsSolomachineClientState = Encoded<'/ibc.lightclients.solomachine.v3.ClientState'>;
export type EncodedIbcLightclientsSolomachineConsensusState = Encoded<'/ibc.lightclients.solomachine.v3.ConsensusState'>;
export type EncodedIbcLightclientsSolomachineHeader = Encoded<'/ibc.lightclients.solomachine.v3.Header'>;
export type EncodedIbcLightclientsSolomachineMisbehaviour = Encoded<'/ibc.lightclients.solomachine.v3.Misbehaviour'>;
export type EncodedIbcLightclientsSolomachineSignatureAndData = Encoded<'/ibc.lightclients.solomachine.v3.SignatureAndData'>;
export type EncodedIbcLightclientsSolomachineTimestampedSignatureData = Encoded<'/ibc.lightclients.solomachine.v3.TimestampedSignatureData'>;
export type EncodedIbcLightclientsSolomachineSignBytes = Encoded<'/ibc.lightclients.solomachine.v3.SignBytes'>;
export type EncodedIbcLightclientsSolomachineHeaderData = Encoded<'/ibc.lightclients.solomachine.v3.HeaderData'>;
/**
 * Encodes a `ClientState` protobuf message: defines a solo machine client that tracks the current consensus state and if the client is frozen.
 * @param sg_sequence - `sequence`: latest sequence of the client state
 * @param b_is_frozen - `is_frozen`: frozen sequence of the solo machine
 * @param g_consensus_state - `consensus_state`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeIbcLightclientsSolomachineClientState: (sg_sequence?: Opt<WeakUint64Str>, b_is_frozen?: Opt<boolean | 0 | 1>, atu8_consensus_state?: Opt<Encoded<'/ibc.lightclients.solomachine.v3.ConsensusState'>>) => EncodedIbcLightclientsSolomachineClientState;
/**
 * Encodes a `ConsensusState` protobuf message: defines a solo machine consensus state. The sequence of a consensus state is contained in the "height" key used in storing the consensus state.
 * @param atu8_public_key - `public_key`: public key of the solo machine
 * @param s_diversifier - `diversifier`: allows the same public key to be re-used across different solo machine clients (potentially on different chains) without being considered misbehaviour.
 * @param sg_timestamp - `timestamp`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeIbcLightclientsSolomachineConsensusState: (atu8_public_key?: Opt<Uint8Array>, s_diversifier?: Opt<string>, sg_timestamp?: Opt<WeakUint64Str>) => EncodedIbcLightclientsSolomachineConsensusState;
/**
 * Encodes a `Header` protobuf message: defines a solo machine consensus header
 * @param sg_timestamp - `timestamp`:
 * @param atu8_signature - `signature`:
 * @param atu8_new_public_key - `new_public_key`:
 * @param s_new_diversifier - `new_diversifier`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeIbcLightclientsSolomachineHeader: (sg_timestamp?: Opt<WeakUint64Str>, atu8_signature?: Opt<Uint8Array>, atu8_new_public_key?: Opt<Uint8Array>, s_new_diversifier?: Opt<string>) => EncodedIbcLightclientsSolomachineHeader;
/**
 * Encodes a `Misbehaviour` protobuf message: defines misbehaviour for a solo machine which consists of a sequence and two signatures over different messages at that sequence.
 * @param sg_sequence - `sequence`:
 * @param g_signature_one - `signature_one`:
 * @param g_signature_two - `signature_two`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeIbcLightclientsSolomachineMisbehaviour: (sg_sequence?: Opt<WeakUint64Str>, atu8_signature_one?: Opt<Encoded<'/ibc.lightclients.solomachine.v3.SignatureAndData'>>, atu8_signature_two?: Opt<Encoded<'/ibc.lightclients.solomachine.v3.SignatureAndData'>>) => EncodedIbcLightclientsSolomachineMisbehaviour;
/**
 * Encodes a `SignatureAndData` protobuf message: contains a signature and the data signed over to create that signature.
 * @param atu8_signature - `signature`:
 * @param atu8_path - `path`:
 * @param atu8_data - `data`:
 * @param sg_timestamp - `timestamp`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeIbcLightclientsSolomachineSignatureAndData: (atu8_signature?: Opt<Uint8Array>, atu8_path?: Opt<Uint8Array>, atu8_data?: Opt<Uint8Array>, sg_timestamp?: Opt<WeakUint64Str>) => EncodedIbcLightclientsSolomachineSignatureAndData;
/**
 * Encodes a `TimestampedSignatureData` protobuf message: contains the signature data and the timestamp of the signature.
 * @param atu8_signature_data - `signature_data`:
 * @param sg_timestamp - `timestamp`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeIbcLightclientsSolomachineTimestampedSignatureData: (atu8_signature_data?: Opt<Uint8Array>, sg_timestamp?: Opt<WeakUint64Str>) => EncodedIbcLightclientsSolomachineTimestampedSignatureData;
/**
 * Encodes a `SignBytes` protobuf message: defines the signed bytes used for signature verification.
 * @param sg_sequence - `sequence`: the sequence number
 * @param sg_timestamp - `timestamp`: the proof timestamp
 * @param s_diversifier - `diversifier`: the public key diversifier
 * @param atu8_path - `path`: the standardised path bytes
 * @param atu8_data - `data`: the marshaled data bytes
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeIbcLightclientsSolomachineSignBytes: (sg_sequence?: Opt<WeakUint64Str>, sg_timestamp?: Opt<WeakUint64Str>, s_diversifier?: Opt<string>, atu8_path?: Opt<Uint8Array>, atu8_data?: Opt<Uint8Array>) => EncodedIbcLightclientsSolomachineSignBytes;
/**
 * Encodes a `HeaderData` protobuf message: returns the SignBytes data for update verification.
 * @param atu8_new_pub_key - `new_pub_key`: header public key
 * @param s_new_diversifier - `new_diversifier`: header diversifier
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeIbcLightclientsSolomachineHeaderData: (atu8_new_pub_key?: Opt<Uint8Array>, s_new_diversifier?: Opt<string>) => EncodedIbcLightclientsSolomachineHeaderData;
/**
 * A decoded protobuf ClientState message
 *
 * Tuple where:
 *   - 0: sequence - latest sequence of the client state
 *   - 1: is_frozen - frozen sequence of the solo machine
 *   - 2: consensus_state -
 */
export type DecodedIbcLightclientsSolomachineClientState = [
    sg_sequence?: CwUint64,
    b_is_frozen?: 0 | 1,
    a_consensus_state?: DecodedIbcLightclientsSolomachineConsensusState
];
/**
 * Decodes a protobuf ClientState message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineClientState}
 */
export declare const decodeIbcLightclientsSolomachineClientState: (atu8_payload: Uint8Array) => DecodedIbcLightclientsSolomachineClientState;
/**
 * A decoded protobuf ConsensusState message
 *
 * Tuple where:
 *   - 0: public_key - public key of the solo machine
 *   - 1: diversifier - allows the same public key to be re-used across different solo machine clients (potentially on different chains) without being considered misbehaviour.
 *   - 2: timestamp -
 */
export type DecodedIbcLightclientsSolomachineConsensusState = [
    a_public_key?: DecodedGoogleProtobufAny,
    s_diversifier?: string,
    sg_timestamp?: CwUint64
];
/**
 * Decodes a protobuf ConsensusState message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineConsensusState}
 */
export declare const decodeIbcLightclientsSolomachineConsensusState: (atu8_payload: Uint8Array) => DecodedIbcLightclientsSolomachineConsensusState;
/**
 * A decoded protobuf Header message
 *
 * Tuple where:
 *   - 0: timestamp -
 *   - 1: signature -
 *   - 2: new_public_key -
 *   - 3: new_diversifier -
 */
export type DecodedIbcLightclientsSolomachineHeader = [
    sg_timestamp?: CwUint64,
    atu8_signature?: Uint8Array,
    a_new_public_key?: DecodedGoogleProtobufAny,
    s_new_diversifier?: string
];
/**
 * Decodes a protobuf Header message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineHeader}
 */
export declare const decodeIbcLightclientsSolomachineHeader: (atu8_payload: Uint8Array) => DecodedIbcLightclientsSolomachineHeader;
/**
 * A decoded protobuf Misbehaviour message
 *
 * Tuple where:
 *   - 0: sequence -
 *   - 1: signature_one -
 *   - 2: signature_two -
 */
export type DecodedIbcLightclientsSolomachineMisbehaviour = [
    sg_sequence?: CwUint64,
    a_signature_one?: DecodedIbcLightclientsSolomachineSignatureAndData,
    a_signature_two?: DecodedIbcLightclientsSolomachineSignatureAndData
];
/**
 * Decodes a protobuf Misbehaviour message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineMisbehaviour}
 */
export declare const decodeIbcLightclientsSolomachineMisbehaviour: (atu8_payload: Uint8Array) => DecodedIbcLightclientsSolomachineMisbehaviour;
/**
 * A decoded protobuf SignatureAndData message
 *
 * Tuple where:
 *   - 0: signature -
 *   - 1: path -
 *   - 2: data -
 *   - 3: timestamp -
 */
export type DecodedIbcLightclientsSolomachineSignatureAndData = [
    atu8_signature?: Uint8Array,
    atu8_path?: Uint8Array,
    atu8_data?: Uint8Array,
    sg_timestamp?: CwUint64
];
/**
 * Decodes a protobuf SignatureAndData message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineSignatureAndData}
 */
export declare const decodeIbcLightclientsSolomachineSignatureAndData: (atu8_payload: Uint8Array) => DecodedIbcLightclientsSolomachineSignatureAndData;
/**
 * A decoded protobuf TimestampedSignatureData message
 *
 * Tuple where:
 *   - 0: signature_data -
 *   - 1: timestamp -
 */
export type DecodedIbcLightclientsSolomachineTimestampedSignatureData = [
    atu8_signature_data?: Uint8Array,
    sg_timestamp?: CwUint64
];
/**
 * Decodes a protobuf TimestampedSignatureData message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineTimestampedSignatureData}
 */
export declare const decodeIbcLightclientsSolomachineTimestampedSignatureData: (atu8_payload: Uint8Array) => DecodedIbcLightclientsSolomachineTimestampedSignatureData;
/**
 * A decoded protobuf SignBytes message
 *
 * Tuple where:
 *   - 0: sequence - the sequence number
 *   - 1: timestamp - the proof timestamp
 *   - 2: diversifier - the public key diversifier
 *   - 3: path - the standardised path bytes
 *   - 4: data - the marshaled data bytes
 */
export type DecodedIbcLightclientsSolomachineSignBytes = [
    sg_sequence?: CwUint64,
    sg_timestamp?: CwUint64,
    s_diversifier?: string,
    atu8_path?: Uint8Array,
    atu8_data?: Uint8Array
];
/**
 * Decodes a protobuf SignBytes message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineSignBytes}
 */
export declare const decodeIbcLightclientsSolomachineSignBytes: (atu8_payload: Uint8Array) => DecodedIbcLightclientsSolomachineSignBytes;
/**
 * A decoded protobuf HeaderData message
 *
 * Tuple where:
 *   - 0: new_pub_key - header public key
 *   - 1: new_diversifier - header diversifier
 */
export type DecodedIbcLightclientsSolomachineHeaderData = [
    a_new_pub_key?: DecodedGoogleProtobufAny,
    s_new_diversifier?: string
];
/**
 * Decodes a protobuf HeaderData message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineHeaderData}
 */
export declare const decodeIbcLightclientsSolomachineHeaderData: (atu8_payload: Uint8Array) => DecodedIbcLightclientsSolomachineHeaderData;
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineClientState} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: sequence - latest sequence of the client state
 *   - 1: is_frozen - frozen sequence of the solo machine
 *   - 2: consensus_state -
 */
export declare const destructIbcLightclientsSolomachineClientState: (g_struct: IbcLightclientsSolomachineClientState) => [sequence?: CwUint64, is_frozen?: boolean, consensus_state?: IbcLightclientsSolomachineConsensusState];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_CLIENT_STATE = "/ibc.lightclients.solomachine.v3.ClientState";
/**
 * JSON serialization of `ibc.lightclients.solomachine.v3.ClientState` - defines a solo machine client that tracks the current consensus state and if the client is frozen.
 */
export type IbcLightclientsSolomachineClientState = {
    sequence?: CwUint64 | undefined;
    is_frozen?: boolean | undefined;
    consensus_state?: IbcLightclientsSolomachineConsensusState | undefined;
};
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineConsensusState} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: public_key - public key of the solo machine
 *   - 1: diversifier - allows the same public key to be re-used across different solo machine clients (potentially on different chains) without being considered misbehaviour.
 *   - 2: timestamp -
 */
export declare const destructIbcLightclientsSolomachineConsensusState: (g_struct: IbcLightclientsSolomachineConsensusState) => [public_key?: JsonAny, diversifier?: string, timestamp?: CwUint64];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_CONSENSUS_STATE = "/ibc.lightclients.solomachine.v3.ConsensusState";
/**
 * JSON serialization of `ibc.lightclients.solomachine.v3.ConsensusState` - defines a solo machine consensus state. The sequence of a consensus state is contained in the "height" key used in storing the consensus state.
 */
export type IbcLightclientsSolomachineConsensusState = {
    public_key?: JsonAny | undefined;
    diversifier?: string | undefined;
    timestamp?: CwUint64 | undefined;
};
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineHeader} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: timestamp -
 *   - 1: signature -
 *   - 2: new_public_key -
 *   - 3: new_diversifier -
 */
export declare const destructIbcLightclientsSolomachineHeader: (g_struct: IbcLightclientsSolomachineHeader) => [timestamp?: CwUint64, signature?: Uint8Array, new_public_key?: JsonAny, new_diversifier?: string];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_HEADER = "/ibc.lightclients.solomachine.v3.Header";
/**
 * JSON serialization of `ibc.lightclients.solomachine.v3.Header` - defines a solo machine consensus header
 */
export type IbcLightclientsSolomachineHeader = {
    timestamp?: CwUint64 | undefined;
    signature?: CwBase64 | undefined;
    new_public_key?: JsonAny | undefined;
    new_diversifier?: string | undefined;
};
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineMisbehaviour} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: sequence -
 *   - 1: signature_one -
 *   - 2: signature_two -
 */
export declare const destructIbcLightclientsSolomachineMisbehaviour: (g_struct: IbcLightclientsSolomachineMisbehaviour) => [sequence?: CwUint64, signature_one?: IbcLightclientsSolomachineSignatureAndData, signature_two?: IbcLightclientsSolomachineSignatureAndData];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_MISBEHAVIOUR = "/ibc.lightclients.solomachine.v3.Misbehaviour";
/**
 * JSON serialization of `ibc.lightclients.solomachine.v3.Misbehaviour` - defines misbehaviour for a solo machine which consists of a sequence and two signatures over different messages at that sequence.
 */
export type IbcLightclientsSolomachineMisbehaviour = {
    sequence?: CwUint64 | undefined;
    signature_one?: IbcLightclientsSolomachineSignatureAndData | undefined;
    signature_two?: IbcLightclientsSolomachineSignatureAndData | undefined;
};
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineSignatureAndData} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: signature -
 *   - 1: path -
 *   - 2: data -
 *   - 3: timestamp -
 */
export declare const destructIbcLightclientsSolomachineSignatureAndData: (g_struct: IbcLightclientsSolomachineSignatureAndData) => [signature?: Uint8Array, path?: Uint8Array, data?: Uint8Array, timestamp?: CwUint64];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_SIGNATURE_AND_DATA = "/ibc.lightclients.solomachine.v3.SignatureAndData";
/**
 * JSON serialization of `ibc.lightclients.solomachine.v3.SignatureAndData` - contains a signature and the data signed over to create that signature.
 */
export type IbcLightclientsSolomachineSignatureAndData = {
    signature?: CwBase64 | undefined;
    path?: CwBase64 | undefined;
    data?: CwBase64 | undefined;
    timestamp?: CwUint64 | undefined;
};
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineTimestampedSignatureData} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: signature_data -
 *   - 1: timestamp -
 */
export declare const destructIbcLightclientsSolomachineTimestampedSignatureData: (g_struct: IbcLightclientsSolomachineTimestampedSignatureData) => [signature_data?: Uint8Array, timestamp?: CwUint64];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_TIMESTAMPED_SIGNATURE_DATA = "/ibc.lightclients.solomachine.v3.TimestampedSignatureData";
/**
 * JSON serialization of `ibc.lightclients.solomachine.v3.TimestampedSignatureData` - contains the signature data and the timestamp of the signature.
 */
export type IbcLightclientsSolomachineTimestampedSignatureData = {
    signature_data?: CwBase64 | undefined;
    timestamp?: CwUint64 | undefined;
};
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineSignBytes} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: sequence - the sequence number
 *   - 1: timestamp - the proof timestamp
 *   - 2: diversifier - the public key diversifier
 *   - 3: path - the standardised path bytes
 *   - 4: data - the marshaled data bytes
 */
export declare const destructIbcLightclientsSolomachineSignBytes: (g_struct: IbcLightclientsSolomachineSignBytes) => [sequence?: CwUint64, timestamp?: CwUint64, diversifier?: string, path?: Uint8Array, data?: Uint8Array];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_SIGN_BYTES = "/ibc.lightclients.solomachine.v3.SignBytes";
/**
 * JSON serialization of `ibc.lightclients.solomachine.v3.SignBytes` - defines the signed bytes used for signature verification.
 */
export type IbcLightclientsSolomachineSignBytes = {
    sequence?: CwUint64 | undefined;
    timestamp?: CwUint64 | undefined;
    diversifier?: string | undefined;
    path?: CwBase64 | undefined;
    data?: CwBase64 | undefined;
};
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineHeaderData} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: new_pub_key - header public key
 *   - 1: new_diversifier - header diversifier
 */
export declare const destructIbcLightclientsSolomachineHeaderData: (g_struct: IbcLightclientsSolomachineHeaderData) => [new_pub_key?: JsonAny, new_diversifier?: string];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_HEADER_DATA = "/ibc.lightclients.solomachine.v3.HeaderData";
/**
 * JSON serialization of `ibc.lightclients.solomachine.v3.HeaderData` - returns the SignBytes data for update verification.
 */
export type IbcLightclientsSolomachineHeaderData = {
    new_pub_key?: JsonAny | undefined;
    new_diversifier?: string | undefined;
};
