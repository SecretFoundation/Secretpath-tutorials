import { decode_protobuf } from '../../../../../api/protobuf-reader.js';
import { Protobuf } from '../../../../../api/protobuf-writer.js';
import { safe_base64_to_bytes } from '../../../../../api/util.js';
import { decodeGoogleProtobufAny } from '../../../../google/protobuf/any.js';
/**
 * Encodes a `ClientState` protobuf message: defines a solo machine client that tracks the current consensus state and if the client is frozen.
 * @param sg_sequence - `sequence`: latest sequence of the client state
 * @param b_is_frozen - `is_frozen`: frozen sequence of the solo machine
 * @param g_consensus_state - `consensus_state`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcLightclientsSolomachineClientState = (sg_sequence, b_is_frozen, atu8_consensus_state) => Protobuf() // ...
    .g(sg_sequence) // uint64 sequence = 1
    .v(b_is_frozen) // boolean is_frozen = 2
    .b(atu8_consensus_state) // ConsensusState consensus_state = 3
    .o;
/**
 * Encodes a `ConsensusState` protobuf message: defines a solo machine consensus state. The sequence of a consensus state is contained in the "height" key used in storing the consensus state.
 * @param atu8_public_key - `public_key`: public key of the solo machine
 * @param s_diversifier - `diversifier`: allows the same public key to be re-used across different solo machine clients (potentially on different chains) without being considered misbehaviour.
 * @param sg_timestamp - `timestamp`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcLightclientsSolomachineConsensusState = (atu8_public_key, s_diversifier, sg_timestamp) => Protobuf() // ...
    .b(atu8_public_key) // Any public_key = 1
    .s(s_diversifier) // string diversifier = 2
    .g(sg_timestamp) // uint64 timestamp = 3
    .o;
/**
 * Encodes a `Header` protobuf message: defines a solo machine consensus header
 * @param sg_timestamp - `timestamp`:
 * @param atu8_signature - `signature`:
 * @param atu8_new_public_key - `new_public_key`:
 * @param s_new_diversifier - `new_diversifier`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcLightclientsSolomachineHeader = (sg_timestamp, atu8_signature, atu8_new_public_key, s_new_diversifier) => Protobuf() // ...
    .g(sg_timestamp) // uint64 timestamp = 1
    .b(atu8_signature) // bytes signature = 2
    .b(atu8_new_public_key) // Any new_public_key = 3
    .s(s_new_diversifier) // string new_diversifier = 4
    .o;
/**
 * Encodes a `Misbehaviour` protobuf message: defines misbehaviour for a solo machine which consists of a sequence and two signatures over different messages at that sequence.
 * @param sg_sequence - `sequence`:
 * @param g_signature_one - `signature_one`:
 * @param g_signature_two - `signature_two`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcLightclientsSolomachineMisbehaviour = (sg_sequence, atu8_signature_one, atu8_signature_two) => Protobuf() // ...
    .g(sg_sequence) // uint64 sequence = 1
    .b(atu8_signature_one) // SignatureAndData signature_one = 2
    .b(atu8_signature_two) // SignatureAndData signature_two = 3
    .o;
/**
 * Encodes a `SignatureAndData` protobuf message: contains a signature and the data signed over to create that signature.
 * @param atu8_signature - `signature`:
 * @param atu8_path - `path`:
 * @param atu8_data - `data`:
 * @param sg_timestamp - `timestamp`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcLightclientsSolomachineSignatureAndData = (atu8_signature, atu8_path, atu8_data, sg_timestamp) => Protobuf() // ...
    .b(atu8_signature) // bytes signature = 1
    .b(atu8_path) // bytes path = 2
    .b(atu8_data) // bytes data = 3
    .g(sg_timestamp) // uint64 timestamp = 4
    .o;
/**
 * Encodes a `TimestampedSignatureData` protobuf message: contains the signature data and the timestamp of the signature.
 * @param atu8_signature_data - `signature_data`:
 * @param sg_timestamp - `timestamp`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcLightclientsSolomachineTimestampedSignatureData = (atu8_signature_data, sg_timestamp) => Protobuf() // ...
    .b(atu8_signature_data) // bytes signature_data = 1
    .g(sg_timestamp) // uint64 timestamp = 2
    .o;
/**
 * Encodes a `SignBytes` protobuf message: defines the signed bytes used for signature verification.
 * @param sg_sequence - `sequence`: the sequence number
 * @param sg_timestamp - `timestamp`: the proof timestamp
 * @param s_diversifier - `diversifier`: the public key diversifier
 * @param atu8_path - `path`: the standardised path bytes
 * @param atu8_data - `data`: the marshaled data bytes
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcLightclientsSolomachineSignBytes = (sg_sequence, sg_timestamp, s_diversifier, atu8_path, atu8_data) => Protobuf() // ...
    .g(sg_sequence) // uint64 sequence = 1
    .g(sg_timestamp) // uint64 timestamp = 2
    .s(s_diversifier) // string diversifier = 3
    .b(atu8_path) // bytes path = 4
    .b(atu8_data) // bytes data = 5
    .o;
/**
 * Encodes a `HeaderData` protobuf message: returns the SignBytes data for update verification.
 * @param atu8_new_pub_key - `new_pub_key`: header public key
 * @param s_new_diversifier - `new_diversifier`: header diversifier
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcLightclientsSolomachineHeaderData = (atu8_new_pub_key, s_new_diversifier) => Protobuf() // ...
    .b(atu8_new_pub_key) // Any new_pub_key = 1
    .s(s_new_diversifier) // string new_diversifier = 2
    .o;
/**
 * Decodes a protobuf ClientState message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineClientState}
 */
export const decodeIbcLightclientsSolomachineClientState = (atu8_payload) => decode_protobuf(atu8_payload, [3, 1, 1], [0, 0, decodeIbcLightclientsSolomachineConsensusState]);
/**
 * Decodes a protobuf ConsensusState message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineConsensusState}
 */
export const decodeIbcLightclientsSolomachineConsensusState = (atu8_payload) => decode_protobuf(atu8_payload, [1, 5, 3], [decodeGoogleProtobufAny]);
/**
 * Decodes a protobuf Header message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineHeader}
 */
export const decodeIbcLightclientsSolomachineHeader = (atu8_payload) => decode_protobuf(atu8_payload, [3, 1, 1, 5], [0, 0, decodeGoogleProtobufAny]);
/**
 * Decodes a protobuf Misbehaviour message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineMisbehaviour}
 */
export const decodeIbcLightclientsSolomachineMisbehaviour = (atu8_payload) => decode_protobuf(atu8_payload, [3, 1, 1], [0, decodeIbcLightclientsSolomachineSignatureAndData, decodeIbcLightclientsSolomachineSignatureAndData]);
/**
 * Decodes a protobuf SignatureAndData message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineSignatureAndData}
 */
export const decodeIbcLightclientsSolomachineSignatureAndData = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1, 1, 3]);
/**
 * Decodes a protobuf TimestampedSignatureData message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineTimestampedSignatureData}
 */
export const decodeIbcLightclientsSolomachineTimestampedSignatureData = (atu8_payload) => decode_protobuf(atu8_payload, [1, 3]);
/**
 * Decodes a protobuf SignBytes message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineSignBytes}
 */
export const decodeIbcLightclientsSolomachineSignBytes = (atu8_payload) => decode_protobuf(atu8_payload, [3, 3, 5, 1, 1]);
/**
 * Decodes a protobuf HeaderData message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineHeaderData}
 */
export const decodeIbcLightclientsSolomachineHeaderData = (atu8_payload) => decode_protobuf(atu8_payload, [1, 5], [decodeGoogleProtobufAny]);
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineClientState} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: sequence - latest sequence of the client state
 *   - 1: is_frozen - frozen sequence of the solo machine
 *   - 2: consensus_state -
 */
export const destructIbcLightclientsSolomachineClientState = (g_struct) => [g_struct.sequence, g_struct.is_frozen, g_struct.consensus_state];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_CLIENT_STATE = '/ibc.lightclients.solomachine.v3.ClientState';
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineConsensusState} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: public_key - public key of the solo machine
 *   - 1: diversifier - allows the same public key to be re-used across different solo machine clients (potentially on different chains) without being considered misbehaviour.
 *   - 2: timestamp -
 */
export const destructIbcLightclientsSolomachineConsensusState = (g_struct) => [g_struct.public_key, g_struct.diversifier, g_struct.timestamp];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_CONSENSUS_STATE = '/ibc.lightclients.solomachine.v3.ConsensusState';
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineHeader} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: timestamp -
 *   - 1: signature -
 *   - 2: new_public_key -
 *   - 3: new_diversifier -
 */
export const destructIbcLightclientsSolomachineHeader = (g_struct) => [g_struct.timestamp, safe_base64_to_bytes(g_struct.signature), g_struct.new_public_key, g_struct.new_diversifier];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_HEADER = '/ibc.lightclients.solomachine.v3.Header';
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineMisbehaviour} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: sequence -
 *   - 1: signature_one -
 *   - 2: signature_two -
 */
export const destructIbcLightclientsSolomachineMisbehaviour = (g_struct) => [g_struct.sequence, g_struct.signature_one, g_struct.signature_two];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_MISBEHAVIOUR = '/ibc.lightclients.solomachine.v3.Misbehaviour';
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineSignatureAndData} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: signature -
 *   - 1: path -
 *   - 2: data -
 *   - 3: timestamp -
 */
export const destructIbcLightclientsSolomachineSignatureAndData = (g_struct) => [safe_base64_to_bytes(g_struct.signature), safe_base64_to_bytes(g_struct.path), safe_base64_to_bytes(g_struct.data), g_struct.timestamp];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_SIGNATURE_AND_DATA = '/ibc.lightclients.solomachine.v3.SignatureAndData';
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineTimestampedSignatureData} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: signature_data -
 *   - 1: timestamp -
 */
export const destructIbcLightclientsSolomachineTimestampedSignatureData = (g_struct) => [safe_base64_to_bytes(g_struct.signature_data), g_struct.timestamp];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_TIMESTAMPED_SIGNATURE_DATA = '/ibc.lightclients.solomachine.v3.TimestampedSignatureData';
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineSignBytes} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: sequence - the sequence number
 *   - 1: timestamp - the proof timestamp
 *   - 2: diversifier - the public key diversifier
 *   - 3: path - the standardised path bytes
 *   - 4: data - the marshaled data bytes
 */
export const destructIbcLightclientsSolomachineSignBytes = (g_struct) => [g_struct.sequence, g_struct.timestamp, g_struct.diversifier, safe_base64_to_bytes(g_struct.path), safe_base64_to_bytes(g_struct.data)];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_SIGN_BYTES = '/ibc.lightclients.solomachine.v3.SignBytes';
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineHeaderData} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: new_pub_key - header public key
 *   - 1: new_diversifier - header diversifier
 */
export const destructIbcLightclientsSolomachineHeaderData = (g_struct) => [g_struct.new_pub_key, g_struct.new_diversifier];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_HEADER_DATA = '/ibc.lightclients.solomachine.v3.HeaderData';
//# sourceMappingURL=solomachine.js.map