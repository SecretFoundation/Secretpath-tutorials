import type { WeakUint64Str, CwUint64 } from '@solar-republic/types';
import type { Encoded, Opt, WeakTimestampStr, WeakDurationStr } from '../../../api/types.js';
import type { CosmosBaseDecCoin, DecodedCosmosBaseDecCoin } from '../../cosmos/base/v1beta1/coin.js';
export type EncodedOsmosisConcentratedliquidityIncentiveRecord = Encoded<'/osmosis.concentratedliquidity.v1beta1.IncentiveRecord'>;
export type EncodedOsmosisConcentratedliquidityIncentiveRecordBody = Encoded<'/osmosis.concentratedliquidity.v1beta1.IncentiveRecordBody'>;
/**
 * Encodes a `IncentiveRecord` protobuf message: the high-level struct we use to deal with an independent incentive being distributed on a pool. Note that PoolId, Denom, and MinUptime are included in the key so we avoid storing them in state, hence the distinction between IncentiveRecord and IncentiveRecordBody.
 * @param sg_incentive_id - `incentive_id`: the id uniquely identifying this incentive record.
 * @param sg_pool_id - `pool_id`:
 * @param g_incentive_record_body - `incentive_record_body`: incentive record body holds necessary
 * @param xt_min_uptime - `min_uptime`: the minimum uptime required for liquidity to qualify for this incentive. It should be always be one of the supported uptimes in types.SupportedUptimes
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisConcentratedliquidityIncentiveRecord: (sg_incentive_id?: Opt<WeakUint64Str>, sg_pool_id?: Opt<WeakUint64Str>, atu8_incentive_record_body?: Opt<Encoded<'/osmosis.concentratedliquidity.v1beta1.IncentiveRecordBody'>>, xt_min_uptime?: Opt<number>) => EncodedOsmosisConcentratedliquidityIncentiveRecord;
/**
 * Encodes a `IncentiveRecordBody` protobuf message: represents the body stored in state for each individual record.
 * @param g_remaining_coin - `remaining_coin`: the total amount of incentives to be distributed
 * @param s_emission_rate - `emission_rate`: the incentive emission rate per second
 * @param xt_start_time - `start_time`: the time when the incentive starts distributing
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisConcentratedliquidityIncentiveRecordBody: (atu8_remaining_coin?: Opt<Encoded<'/cosmos.base.v1beta1.DecCoin'>>, s_emission_rate?: Opt<string>, xt_start_time?: Opt<number>) => EncodedOsmosisConcentratedliquidityIncentiveRecordBody;
/**
 * A decoded protobuf IncentiveRecord message
 *
 * Tuple where:
 *   - 0: incentive_id - the id uniquely identifying this incentive record.
 *   - 1: pool_id -
 *   - 3: incentive_record_body - incentive record body holds necessary
 *   - 4: min_uptime - the minimum uptime required for liquidity to qualify for this incentive. It should be always be one of the supported uptimes in types.SupportedUptimes
 */
export type DecodedOsmosisConcentratedliquidityIncentiveRecord = [
    sg_incentive_id?: CwUint64,
    sg_pool_id?: CwUint64,
    w_0?: undefined,
    a_incentive_record_body?: DecodedOsmosisConcentratedliquidityIncentiveRecordBody,
    a_min_uptime?: [
        string,
        number
    ]
];
/**
 * Decodes a protobuf IncentiveRecord message
 * @param atu8_payload - raw bytes to decode
 * @param RESERVED - a second argument is explicitly forbidden. make sure not to pass this function by reference to some callback argument
 * @returns a {@link DecodedOsmosisConcentratedliquidityIncentiveRecord}
 */
export declare const decodeOsmosisConcentratedliquidityIncentiveRecord: (atu8_payload: Uint8Array, RESERVED?: never) => DecodedOsmosisConcentratedliquidityIncentiveRecord;
/**
 * A decoded protobuf IncentiveRecordBody message
 *
 * Tuple where:
 *   - 0: remaining_coin - the total amount of incentives to be distributed
 *   - 1: emission_rate - the incentive emission rate per second
 *   - 2: start_time - the time when the incentive starts distributing
 */
export type DecodedOsmosisConcentratedliquidityIncentiveRecordBody = [
    a_remaining_coin?: DecodedCosmosBaseDecCoin,
    s_emission_rate?: string,
    a_start_time?: [
        string,
        number
    ]
];
/**
 * Decodes a protobuf IncentiveRecordBody message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisConcentratedliquidityIncentiveRecordBody}
 */
export declare const decodeOsmosisConcentratedliquidityIncentiveRecordBody: (atu8_payload: Uint8Array) => DecodedOsmosisConcentratedliquidityIncentiveRecordBody;
/**
 * Destructures the fields of a {@link OsmosisConcentratedliquidityIncentiveRecord} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: incentive_id - the id uniquely identifying this incentive record.
 *   - 1: pool_id -
 *   - 3: incentive_record_body - incentive record body holds necessary
 *   - 4: min_uptime - the minimum uptime required for liquidity to qualify for this incentive. It should be always be one of the supported uptimes in types.SupportedUptimes
 */
export declare const destructOsmosisConcentratedliquidityIncentiveRecord: (g_struct: OsmosisConcentratedliquidityIncentiveRecord) => [incentive_id?: CwUint64, pool_id?: CwUint64, EMPTY?: void, incentive_record_body?: OsmosisConcentratedliquidityIncentiveRecordBody, min_uptime?: number];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_CONCENTRATEDLIQUIDITY_INCENTIVE_RECORD = "/osmosis.concentratedliquidity.v1beta1.IncentiveRecord";
/**
 * JSON serialization of `osmosis.concentratedliquidity.v1beta1.IncentiveRecord` - the high-level struct we use to deal with an independent incentive being distributed on a pool. Note that PoolId, Denom, and MinUptime are included in the key so we avoid storing them in state, hence the distinction between IncentiveRecord and IncentiveRecordBody.
 */
export type OsmosisConcentratedliquidityIncentiveRecord = {
    incentive_id?: CwUint64 | undefined;
    pool_id?: CwUint64 | undefined;
    incentive_record_body?: OsmosisConcentratedliquidityIncentiveRecordBody | undefined;
    min_uptime?: WeakDurationStr | undefined;
};
/**
 * Destructures the fields of a {@link OsmosisConcentratedliquidityIncentiveRecordBody} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: remaining_coin - the total amount of incentives to be distributed
 *   - 1: emission_rate - the incentive emission rate per second
 *   - 2: start_time - the time when the incentive starts distributing
 */
export declare const destructOsmosisConcentratedliquidityIncentiveRecordBody: (g_struct: OsmosisConcentratedliquidityIncentiveRecordBody) => [remaining_coin?: CosmosBaseDecCoin, emission_rate?: string, start_time?: number];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_CONCENTRATEDLIQUIDITY_INCENTIVE_RECORD_BODY = "/osmosis.concentratedliquidity.v1beta1.IncentiveRecordBody";
/**
 * JSON serialization of `osmosis.concentratedliquidity.v1beta1.IncentiveRecordBody` - represents the body stored in state for each individual record.
 */
export type OsmosisConcentratedliquidityIncentiveRecordBody = {
    remaining_coin?: CosmosBaseDecCoin | undefined;
    emission_rate?: string | undefined;
    start_time?: WeakTimestampStr | undefined;
};
