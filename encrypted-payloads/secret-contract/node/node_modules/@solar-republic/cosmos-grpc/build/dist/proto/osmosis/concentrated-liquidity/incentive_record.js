import { __UNDEFINED } from '@blake.regalia/belt';
import { parse_duration, parse_timestamp } from '../../../api/json.js';
import { decode_protobuf, decode_temporal } from '../../../api/protobuf-reader.js';
import { Protobuf, temporal } from '../../../api/protobuf-writer.js';
import { decodeCosmosBaseDecCoin } from '../../cosmos/base/v1beta1/coin.js';
/**
 * Encodes a `IncentiveRecord` protobuf message: the high-level struct we use to deal with an independent incentive being distributed on a pool. Note that PoolId, Denom, and MinUptime are included in the key so we avoid storing them in state, hence the distinction between IncentiveRecord and IncentiveRecordBody.
 * @param sg_incentive_id - `incentive_id`: the id uniquely identifying this incentive record.
 * @param sg_pool_id - `pool_id`:
 * @param g_incentive_record_body - `incentive_record_body`: incentive record body holds necessary
 * @param xt_min_uptime - `min_uptime`: the minimum uptime required for liquidity to qualify for this incentive. It should be always be one of the supported uptimes in types.SupportedUptimes
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeOsmosisConcentratedliquidityIncentiveRecord = (sg_incentive_id, sg_pool_id, atu8_incentive_record_body, xt_min_uptime) => Protobuf() // ...
    .g(sg_incentive_id) // uint64 incentive_id = 1
    .g(sg_pool_id) // uint64 pool_id = 2
    .b(atu8_incentive_record_body, 4) // IncentiveRecordBody incentive_record_body = 4
    .b(temporal(xt_min_uptime), 5) // Duration min_uptime = 5
    .o;
/**
 * Encodes a `IncentiveRecordBody` protobuf message: represents the body stored in state for each individual record.
 * @param g_remaining_coin - `remaining_coin`: the total amount of incentives to be distributed
 * @param s_emission_rate - `emission_rate`: the incentive emission rate per second
 * @param xt_start_time - `start_time`: the time when the incentive starts distributing
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeOsmosisConcentratedliquidityIncentiveRecordBody = (atu8_remaining_coin, s_emission_rate, xt_start_time) => Protobuf() // ...
    .b(atu8_remaining_coin) // DecCoin remaining_coin = 1
    .s(s_emission_rate) // string emission_rate = 2
    .b(temporal(xt_start_time)) // Timestamp start_time = 3
    .o;
/**
 * Decodes a protobuf IncentiveRecord message
 * @param atu8_payload - raw bytes to decode
 * @param RESERVED - a second argument is explicitly forbidden. make sure not to pass this function by reference to some callback argument
 * @returns a {@link DecodedOsmosisConcentratedliquidityIncentiveRecord}
 */
export const decodeOsmosisConcentratedliquidityIncentiveRecord = ((atu8_payload, [sg_incentive_id, sg_pool_id, , a_incentive_record_body, a_min_uptime] = decode_protobuf(atu8_payload, [3, 3, 0, 1, [3, 1]], [0, 0, 0, decodeOsmosisConcentratedliquidityIncentiveRecordBody, decode_temporal])) => [sg_incentive_id, sg_pool_id, __UNDEFINED, a_incentive_record_body, a_min_uptime]);
/**
 * Decodes a protobuf IncentiveRecordBody message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisConcentratedliquidityIncentiveRecordBody}
 */
export const decodeOsmosisConcentratedliquidityIncentiveRecordBody = (atu8_payload) => decode_protobuf(atu8_payload, [1, 5, [3, 1]], [decodeCosmosBaseDecCoin, 0, decode_temporal]);
/**
 * Destructures the fields of a {@link OsmosisConcentratedliquidityIncentiveRecord} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: incentive_id - the id uniquely identifying this incentive record.
 *   - 1: pool_id -
 *   - 3: incentive_record_body - incentive record body holds necessary
 *   - 4: min_uptime - the minimum uptime required for liquidity to qualify for this incentive. It should be always be one of the supported uptimes in types.SupportedUptimes
 */
export const destructOsmosisConcentratedliquidityIncentiveRecord = (g_struct) => [g_struct.incentive_id, g_struct.pool_id, __UNDEFINED, g_struct.incentive_record_body, parse_duration(g_struct.min_uptime)];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_OSMOSIS_CONCENTRATEDLIQUIDITY_INCENTIVE_RECORD = '/osmosis.concentratedliquidity.v1beta1.IncentiveRecord';
/**
 * Destructures the fields of a {@link OsmosisConcentratedliquidityIncentiveRecordBody} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: remaining_coin - the total amount of incentives to be distributed
 *   - 1: emission_rate - the incentive emission rate per second
 *   - 2: start_time - the time when the incentive starts distributing
 */
export const destructOsmosisConcentratedliquidityIncentiveRecordBody = (g_struct) => [g_struct.remaining_coin, g_struct.emission_rate, parse_timestamp(g_struct.start_time)];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_OSMOSIS_CONCENTRATEDLIQUIDITY_INCENTIVE_RECORD_BODY = '/osmosis.concentratedliquidity.v1beta1.IncentiveRecordBody';
//# sourceMappingURL=incentive_record.js.map