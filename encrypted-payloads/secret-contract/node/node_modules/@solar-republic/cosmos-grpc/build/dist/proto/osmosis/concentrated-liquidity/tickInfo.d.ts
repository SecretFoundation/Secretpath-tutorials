import type { Encoded, Opt } from '../../../api/types.js';
import type { CosmosBaseDecCoin, DecodedCosmosBaseDecCoin } from '../../cosmos/base/v1beta1/coin.js';
export type EncodedOsmosisConcentratedliquidityTickInfo = Encoded<'/osmosis.concentratedliquidity.v1beta1.TickInfo'>;
export type EncodedOsmosisConcentratedliquidityUptimeTrackers = Encoded<'/osmosis.concentratedliquidity.v1beta1.UptimeTrackers'>;
export type EncodedOsmosisConcentratedliquidityUptimeTracker = Encoded<'/osmosis.concentratedliquidity.v1beta1.UptimeTracker'>;
/**
 * Encodes a `TickInfo` protobuf message:
 * @param s_liquidity_gross - `liquidity_gross`:
 * @param s_liquidity_net - `liquidity_net`:
 * @param a_spread_reward_growth_opposite_direction_of_last_traversals - `spread_reward_growth_opposite_direction_of_last_traversal`: Total spread rewards accumulated in the opposite direction that the tick was last crossed. i.e. if the current tick is to the right of this tick (meaning its currently a greater price), then this is the total spread rewards accumulated below the tick. If the current tick is to the left of this tick (meaning its currently at a lower price), then this is the total spread rewards accumulated above the tick. Note: the way this value is used depends on the direction of spread rewards we are calculating for. If we are calculating spread rewards below the lower tick and the lower tick is the active tick, then this is the spreadRewardGrowthGlobal - the lower tick's spreadRewardGrowthOppositeDirectionOfLastTraversal. If we are calculating spread rewards above the upper tick and the upper tick is the active tick, then this is just the tick's spreadRewardGrowthOppositeDirectionOfLastTraversal value.
 * @param g_uptime_trackers - `uptime_trackers`: a container encapsulating the uptime trackers. We use a container instead of a "repeated UptimeTracker" directly because we need the ability to serialize and deserialize the container easily for events when crossing a tick.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisConcentratedliquidityTickInfo: (s_liquidity_gross?: Opt<string>, s_liquidity_net?: Opt<string>, a_spread_reward_growth_opposite_direction_of_last_traversals?: Opt<Encoded<'/cosmos.base.v1beta1.DecCoin'>[]>, atu8_uptime_trackers?: Opt<Encoded<'/osmosis.concentratedliquidity.v1beta1.UptimeTrackers'>>) => EncodedOsmosisConcentratedliquidityTickInfo;
/**
 * Encodes a `UptimeTrackers` protobuf message:
 * @param a_lists - `list`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisConcentratedliquidityUptimeTrackers: (a_lists?: Opt<Encoded<'/osmosis.concentratedliquidity.v1beta1.UptimeTracker'>[]>) => EncodedOsmosisConcentratedliquidityUptimeTrackers;
/**
 * Encodes a `UptimeTracker` protobuf message:
 * @param a_uptime_growth_outsides - `uptime_growth_outside`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisConcentratedliquidityUptimeTracker: (a_uptime_growth_outsides?: Opt<Encoded<'/cosmos.base.v1beta1.DecCoin'>[]>) => EncodedOsmosisConcentratedliquidityUptimeTracker;
/**
 * A decoded protobuf TickInfo message
 *
 * Tuple where:
 *   - 0: liquidity_gross -
 *   - 1: liquidity_net -
 *   - 2: spread_reward_growth_opposite_direction_of_last_traversal - Total spread rewards accumulated in the opposite direction that the tick was last crossed. i.e. if the current tick is to the right of this tick (meaning its currently a greater price), then this is the total spread rewards accumulated below the tick. If the current tick is to the left of this tick (meaning its currently at a lower price), then this is the total spread rewards accumulated above the tick. Note: the way this value is used depends on the direction of spread rewards we are calculating for. If we are calculating spread rewards below the lower tick and the lower tick is the active tick, then this is the spreadRewardGrowthGlobal - the lower tick's spreadRewardGrowthOppositeDirectionOfLastTraversal. If we are calculating spread rewards above the upper tick and the upper tick is the active tick, then this is just the tick's spreadRewardGrowthOppositeDirectionOfLastTraversal value.
 *   - 3: uptime_trackers - a container encapsulating the uptime trackers. We use a container instead of a "repeated UptimeTracker" directly because we need the ability to serialize and deserialize the container easily for events when crossing a tick.
 */
export type DecodedOsmosisConcentratedliquidityTickInfo = [
    s_liquidity_gross?: string,
    s_liquidity_net?: string,
    a_spread_reward_growth_opposite_direction_of_last_traversal?: DecodedCosmosBaseDecCoin[],
    a_uptime_trackers?: DecodedOsmosisConcentratedliquidityUptimeTrackers
];
/**
 * Decodes a protobuf TickInfo message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisConcentratedliquidityTickInfo}
 */
export declare const decodeOsmosisConcentratedliquidityTickInfo: (atu8_payload: Uint8Array) => DecodedOsmosisConcentratedliquidityTickInfo;
/**
 * A decoded protobuf UptimeTrackers message
 *
 * Alias for: list -
 */
export type DecodedOsmosisConcentratedliquidityUptimeTrackers = [
    a_list?: DecodedOsmosisConcentratedliquidityUptimeTracker[]
];
/**
 * Decodes a protobuf UptimeTrackers message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisConcentratedliquidityUptimeTrackers}
 */
export declare const decodeOsmosisConcentratedliquidityUptimeTrackers: (atu8_payload: Uint8Array) => DecodedOsmosisConcentratedliquidityUptimeTrackers;
/**
 * A decoded protobuf UptimeTracker message
 *
 * Alias for: uptime_growth_outside -
 */
export type DecodedOsmosisConcentratedliquidityUptimeTracker = [
    a_uptime_growth_outside?: DecodedCosmosBaseDecCoin[]
];
/**
 * Decodes a protobuf UptimeTracker message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisConcentratedliquidityUptimeTracker}
 */
export declare const decodeOsmosisConcentratedliquidityUptimeTracker: (atu8_payload: Uint8Array) => DecodedOsmosisConcentratedliquidityUptimeTracker;
/**
 * Destructures the fields of a {@link OsmosisConcentratedliquidityTickInfo} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: liquidity_gross -
 *   - 1: liquidity_net -
 *   - 2: spread_reward_growth_opposite_direction_of_last_traversal - Total spread rewards accumulated in the opposite direction that the tick was last crossed. i.e. if the current tick is to the right of this tick (meaning its currently a greater price), then this is the total spread rewards accumulated below the tick. If the current tick is to the left of this tick (meaning its currently at a lower price), then this is the total spread rewards accumulated above the tick. Note: the way this value is used depends on the direction of spread rewards we are calculating for. If we are calculating spread rewards below the lower tick and the lower tick is the active tick, then this is the spreadRewardGrowthGlobal - the lower tick's spreadRewardGrowthOppositeDirectionOfLastTraversal. If we are calculating spread rewards above the upper tick and the upper tick is the active tick, then this is just the tick's spreadRewardGrowthOppositeDirectionOfLastTraversal value.
 *   - 3: uptime_trackers - a container encapsulating the uptime trackers. We use a container instead of a "repeated UptimeTracker" directly because we need the ability to serialize and deserialize the container easily for events when crossing a tick.
 */
export declare const destructOsmosisConcentratedliquidityTickInfo: (g_struct: OsmosisConcentratedliquidityTickInfo) => [liquidity_gross?: string, liquidity_net?: string, spread_reward_growth_opposite_direction_of_last_traversal?: CosmosBaseDecCoin[], uptime_trackers?: OsmosisConcentratedliquidityUptimeTrackers];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_CONCENTRATEDLIQUIDITY_TICK_INFO = "/osmosis.concentratedliquidity.v1beta1.TickInfo";
/**
 * JSON serialization of `osmosis.concentratedliquidity.v1beta1.TickInfo` -
 */
export type OsmosisConcentratedliquidityTickInfo = {
    liquidity_gross?: string | undefined;
    liquidity_net?: string | undefined;
    spread_reward_growth_opposite_direction_of_last_traversal?: CosmosBaseDecCoin[] | undefined;
    uptime_trackers?: OsmosisConcentratedliquidityUptimeTrackers | undefined;
};
/**
 * Destructures the fields of a {@link OsmosisConcentratedliquidityUptimeTrackers} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: list -
 */
export declare const destructOsmosisConcentratedliquidityUptimeTrackers: (g_struct: OsmosisConcentratedliquidityUptimeTrackers) => [list?: OsmosisConcentratedliquidityUptimeTracker[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_CONCENTRATEDLIQUIDITY_UPTIME_TRACKERS = "/osmosis.concentratedliquidity.v1beta1.UptimeTrackers";
/**
 * JSON serialization of `osmosis.concentratedliquidity.v1beta1.UptimeTrackers` -
 */
export type OsmosisConcentratedliquidityUptimeTrackers = {
    list?: OsmosisConcentratedliquidityUptimeTracker[] | undefined;
};
/**
 * Destructures the fields of a {@link OsmosisConcentratedliquidityUptimeTracker} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: uptime_growth_outside -
 */
export declare const destructOsmosisConcentratedliquidityUptimeTracker: (g_struct: OsmosisConcentratedliquidityUptimeTracker) => [uptime_growth_outside?: CosmosBaseDecCoin[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_CONCENTRATEDLIQUIDITY_UPTIME_TRACKER = "/osmosis.concentratedliquidity.v1beta1.UptimeTracker";
/**
 * JSON serialization of `osmosis.concentratedliquidity.v1beta1.UptimeTracker` -
 */
export type OsmosisConcentratedliquidityUptimeTracker = {
    uptime_growth_outside?: CosmosBaseDecCoin[] | undefined;
};
