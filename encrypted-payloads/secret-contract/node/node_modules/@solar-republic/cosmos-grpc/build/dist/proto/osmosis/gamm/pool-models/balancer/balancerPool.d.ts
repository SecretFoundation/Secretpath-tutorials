import type { WeakUint64Str, WeakAccountAddr, SlimCoin, CwUint64, CwAccountAddr } from '@solar-republic/types';
import type { Encoded, Opt, WeakTimestampStr, WeakDurationStr } from '../../../../../api/types.js';
import type { CosmosBaseCoin } from '../../../../cosmos/base/v1beta1/coin.js';
export type AnyOsmosisGammPool = Encoded<'PoolI'>;
export type EncodedOsmosisGammSmoothWeightChangeParams = Encoded<'/osmosis.gamm.v1beta1.SmoothWeightChangeParams'>;
export type EncodedOsmosisGammPoolParams = Encoded<'/osmosis.gamm.v1beta1.PoolParams'>;
export type EncodedOsmosisGammPoolAsset = Encoded<'/osmosis.gamm.v1beta1.PoolAsset'>;
export type EncodedOsmosisGammPool = Encoded<'/osmosis.gamm.v1beta1.Pool' | 'PoolI'>;
/**
 * Encodes a `Pool` protobuf message wrapped in the `Any` container:
 * @param sa_address - `address`:
 * @param sg_id - `id`:
 * @param g_pool_params - `pool_params`:
 * @param s_future_pool_governor - `future_pool_governor`: This string specifies who will govern the pool in the future. Valid forms of this are: {token name},{duration} {duration} where {token name} if specified is the token which determines the governor, and if not specified is the LP token for this pool.duration is a time specified as 0w,1w,2w, etc. which specifies how long the token would need to be locked up to count in governance. 0w means no lockup. TODO: Further improve these docs
 * @param a_total_shares - `total_shares`: sum of all LP tokens sent out
 * @param a_pool_assets - `pool_assets`: These are assumed to be sorted by denomiation. They contain the pool asset and the information about the weight
 * @param s_total_weight - `total_weight`: sum of all non-normalized pool weights
 * @returns a strongly subtyped Uint8Array representing an `Any` protobuf message
 */
export declare const anyPool: (sa_address?: Opt<WeakAccountAddr>, sg_id?: Opt<WeakUint64Str>, atu8_pool_params?: Opt<Encoded<'/osmosis.gamm.v1beta1.PoolParams'>>, s_future_pool_governor?: Opt<string>, a_total_shares?: Opt<SlimCoin>, a_pool_assets?: Opt<Encoded<'/osmosis.gamm.v1beta1.PoolAsset'>[]>, s_total_weight?: Opt<string>) => AnyOsmosisGammPool;
/**
 * Encodes a `SmoothWeightChangeParams` protobuf message: Parameters for changing the weights in a balancer pool smoothly from a start weight and end weight over a period of time. Currently, the only smooth change supported is linear changing between the two weights, but more types may be added in the future. When these parameters are set, the weight w(t) for pool time `t` is the following: t <= start_time: w(t) = initial_pool_weights start_time < t <= start_time + duration: w(t) = initial_pool_weights + (t - start_time) * (target_pool_weights - initial_pool_weights) / (duration) t > start_time + duration: w(t) = target_pool_weights
 * @param xt_start_time - `start_time`: The start time for beginning the weight change. If a parameter change / pool instantiation leaves this blank, it should be generated by the state_machine as the current time.
 * @param xt_duration - `duration`: Duration for the weights to change over
 * @param a_initial_pool_weights - `initial_pool_weights`: The initial pool weights. These are copied from the pool's settings at the time of weight change instantiation. The amount PoolAsset.token.amount field is ignored if present, future type refactorings should just have a type with the denom & weight here.
 * @param a_target_pool_weights - `target_pool_weights`: The target pool weights. The pool weights will change linearly with respect to time between start_time, and start_time + duration. The amount PoolAsset.token.amount field is ignored if present, future type refactorings should just have a type with the denom & weight here.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisGammSmoothWeightChangeParams: (xt_start_time?: Opt<number>, xt_duration?: Opt<number>, a_initial_pool_weights?: Opt<Encoded<'/osmosis.gamm.v1beta1.PoolAsset'>[]>, a_target_pool_weights?: Opt<Encoded<'/osmosis.gamm.v1beta1.PoolAsset'>[]>) => EncodedOsmosisGammSmoothWeightChangeParams;
/**
 * Encodes a `PoolParams` protobuf message: defined the parameters that will be managed by the pool governance in the future. This params are not managed by the chain governance. Instead they will be managed by the token holders of the pool. The pool's token holders are specified in future_pool_governor.
 * @param s_swap_fee - `swap_fee`:
 * @param s_exit_fee - `exit_fee`: N.B.: exit fee is disabled during pool creation in x/poolmanager. While old pools can maintain a non-zero fee. No new pool can be created with non-zero fee anymore
 * @param g_smooth_weight_change_params - `smooth_weight_change_params`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisGammPoolParams: (s_swap_fee?: Opt<string>, s_exit_fee?: Opt<string>, atu8_smooth_weight_change_params?: Opt<Encoded<'/osmosis.gamm.v1beta1.SmoothWeightChangeParams'>>) => EncodedOsmosisGammPoolParams;
/**
 * Encodes a `PoolAsset` protobuf message: Pool asset is an internal struct that combines the amount of the token in the pool, and its balancer weight. This is an awkward packaging of data, and should be revisited in a future state migration.
 * @param a_token - `token`: Coins we are talking about, the denomination must be unique amongst all PoolAssets for this pool.
 * @param s_weight - `weight`: Weight that is not normalized. This weight must be less than 2^50
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisGammPoolAsset: (a_token?: Opt<SlimCoin>, s_weight?: Opt<string>) => EncodedOsmosisGammPoolAsset;
/**
 * Encodes a `Pool` protobuf message:
 * @param sa_address - `address`:
 * @param sg_id - `id`:
 * @param g_pool_params - `pool_params`:
 * @param s_future_pool_governor - `future_pool_governor`: This string specifies who will govern the pool in the future. Valid forms of this are: {token name},{duration} {duration} where {token name} if specified is the token which determines the governor, and if not specified is the LP token for this pool.duration is a time specified as 0w,1w,2w, etc. which specifies how long the token would need to be locked up to count in governance. 0w means no lockup. TODO: Further improve these docs
 * @param a_total_shares - `total_shares`: sum of all LP tokens sent out
 * @param a_pool_assets - `pool_assets`: These are assumed to be sorted by denomiation. They contain the pool asset and the information about the weight
 * @param s_total_weight - `total_weight`: sum of all non-normalized pool weights
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisGammPool: (sa_address?: Opt<WeakAccountAddr>, sg_id?: Opt<WeakUint64Str>, atu8_pool_params?: Opt<Encoded<'/osmosis.gamm.v1beta1.PoolParams'>>, s_future_pool_governor?: Opt<string>, a_total_shares?: Opt<SlimCoin>, a_pool_assets?: Opt<Encoded<'/osmosis.gamm.v1beta1.PoolAsset'>[]>, s_total_weight?: Opt<string>) => EncodedOsmosisGammPool;
/**
 * A decoded protobuf SmoothWeightChangeParams message
 *
 * Tuple where:
 *   - 0: start_time - The start time for beginning the weight change. If a parameter change / pool instantiation leaves this blank, it should be generated by the state_machine as the current time.
 *   - 1: duration - Duration for the weights to change over
 *   - 2: initial_pool_weights - The initial pool weights. These are copied from the pool's settings at the time of weight change instantiation. The amount PoolAsset.token.amount field is ignored if present, future type refactorings should just have a type with the denom & weight here.
 *   - 3: target_pool_weights - The target pool weights. The pool weights will change linearly with respect to time between start_time, and start_time + duration. The amount PoolAsset.token.amount field is ignored if present, future type refactorings should just have a type with the denom & weight here.
 */
export type DecodedOsmosisGammSmoothWeightChangeParams = [
    a_start_time?: [
        string,
        number
    ],
    a_duration?: [
        string,
        number
    ],
    a_initial_pool_weights?: DecodedOsmosisGammPoolAsset[],
    a_target_pool_weights?: DecodedOsmosisGammPoolAsset[]
];
/**
 * Decodes a protobuf SmoothWeightChangeParams message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisGammSmoothWeightChangeParams}
 */
export declare const decodeOsmosisGammSmoothWeightChangeParams: (atu8_payload: Uint8Array) => DecodedOsmosisGammSmoothWeightChangeParams;
/**
 * A decoded protobuf PoolParams message
 *
 * Tuple where:
 *   - 0: swap_fee -
 *   - 1: exit_fee - N.B.: exit fee is disabled during pool creation in x/poolmanager. While old pools can maintain a non-zero fee. No new pool can be created with non-zero fee anymore
 *   - 2: smooth_weight_change_params -
 */
export type DecodedOsmosisGammPoolParams = [
    s_swap_fee?: string,
    s_exit_fee?: string,
    a_smooth_weight_change_params?: DecodedOsmosisGammSmoothWeightChangeParams
];
/**
 * Decodes a protobuf PoolParams message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisGammPoolParams}
 */
export declare const decodeOsmosisGammPoolParams: (atu8_payload: Uint8Array) => DecodedOsmosisGammPoolParams;
/**
 * A decoded protobuf PoolAsset message
 *
 * Tuple where:
 *   - 0: token - Coins we are talking about, the denomination must be unique amongst all PoolAssets for this pool.
 *   - 1: weight - Weight that is not normalized. This weight must be less than 2^50
 */
export type DecodedOsmosisGammPoolAsset = [
    a_token?: [
        string,
        string
    ],
    s_weight?: string
];
/**
 * Decodes a protobuf PoolAsset message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisGammPoolAsset}
 */
export declare const decodeOsmosisGammPoolAsset: (atu8_payload: Uint8Array) => DecodedOsmosisGammPoolAsset;
/**
 * A decoded protobuf Pool message
 *
 * Tuple where:
 *   - 0: address -
 *   - 1: id -
 *   - 2: pool_params -
 *   - 3: future_pool_governor - This string specifies who will govern the pool in the future. Valid forms of this are: {token name},{duration} {duration} where {token name} if specified is the token which determines the governor, and if not specified is the LP token for this pool.duration is a time specified as 0w,1w,2w, etc. which specifies how long the token would need to be locked up to count in governance. 0w means no lockup. TODO: Further improve these docs
 *   - 4: total_shares - sum of all LP tokens sent out
 *   - 5: pool_assets - These are assumed to be sorted by denomiation. They contain the pool asset and the information about the weight
 *   - 6: total_weight - sum of all non-normalized pool weights
 */
export type DecodedOsmosisGammPool = [
    sa_address?: CwAccountAddr,
    sg_id?: CwUint64,
    a_pool_params?: DecodedOsmosisGammPoolParams,
    s_future_pool_governor?: string,
    a_total_shares?: [
        string,
        string
    ],
    a_pool_assets?: DecodedOsmosisGammPoolAsset[],
    s_total_weight?: string
];
/**
 * Decodes a protobuf Pool message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisGammPool}
 */
export declare const decodeOsmosisGammPool: (atu8_payload: Uint8Array) => DecodedOsmosisGammPool;
/**
 * Destructures the fields of a {@link OsmosisGammPoolParams} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: swap_fee -
 *   - 1: exit_fee - N.B.: exit fee is disabled during pool creation in x/poolmanager. While old pools can maintain a non-zero fee. No new pool can be created with non-zero fee anymore
 *   - 2: smooth_weight_change_params -
 */
export declare const destructOsmosisGammPoolParams: (g_struct: OsmosisGammPoolParams) => [swap_fee?: string, exit_fee?: string, smooth_weight_change_params?: OsmosisGammSmoothWeightChangeParams];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_GAMM_POOL_PARAMS = "/osmosis.gamm.v1beta1.PoolParams";
/**
 * JSON serialization of `osmosis.gamm.v1beta1.PoolParams` - defined the parameters that will be managed by the pool governance in the future. This params are not managed by the chain governance. Instead they will be managed by the token holders of the pool. The pool's token holders are specified in future_pool_governor.
 */
export type OsmosisGammPoolParams = {
    swap_fee?: string | undefined;
    exit_fee?: string | undefined;
    smooth_weight_change_params?: OsmosisGammSmoothWeightChangeParams | undefined;
};
/**
 * Destructures the fields of a {@link OsmosisGammSmoothWeightChangeParams} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: start_time - The start time for beginning the weight change. If a parameter change / pool instantiation leaves this blank, it should be generated by the state_machine as the current time.
 *   - 1: duration - Duration for the weights to change over
 *   - 2: initial_pool_weights - The initial pool weights. These are copied from the pool's settings at the time of weight change instantiation. The amount PoolAsset.token.amount field is ignored if present, future type refactorings should just have a type with the denom & weight here.
 *   - 3: target_pool_weights - The target pool weights. The pool weights will change linearly with respect to time between start_time, and start_time + duration. The amount PoolAsset.token.amount field is ignored if present, future type refactorings should just have a type with the denom & weight here.
 */
export declare const destructOsmosisGammSmoothWeightChangeParams: (g_struct: OsmosisGammSmoothWeightChangeParams) => [start_time?: number, duration?: number, initial_pool_weights?: OsmosisGammPoolAsset[], target_pool_weights?: OsmosisGammPoolAsset[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_GAMM_SMOOTH_WEIGHT_CHANGE_PARAMS = "/osmosis.gamm.v1beta1.SmoothWeightChangeParams";
/**
 * JSON serialization of `osmosis.gamm.v1beta1.SmoothWeightChangeParams` - Parameters for changing the weights in a balancer pool smoothly from a start weight and end weight over a period of time. Currently, the only smooth change supported is linear changing between the two weights, but more types may be added in the future. When these parameters are set, the weight w(t) for pool time `t` is the following: t <= start_time: w(t) = initial_pool_weights start_time < t <= start_time + duration: w(t) = initial_pool_weights + (t - start_time) * (target_pool_weights - initial_pool_weights) / (duration) t > start_time + duration: w(t) = target_pool_weights
 */
export type OsmosisGammSmoothWeightChangeParams = {
    start_time?: WeakTimestampStr | undefined;
    duration?: WeakDurationStr | undefined;
    initial_pool_weights?: OsmosisGammPoolAsset[] | undefined;
    target_pool_weights?: OsmosisGammPoolAsset[] | undefined;
};
/**
 * Destructures the fields of a {@link OsmosisGammPoolAsset} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: token - Coins we are talking about, the denomination must be unique amongst all PoolAssets for this pool.
 *   - 1: weight - Weight that is not normalized. This weight must be less than 2^50
 */
export declare const destructOsmosisGammPoolAsset: (g_struct: OsmosisGammPoolAsset) => [token?: CosmosBaseCoin, weight?: string];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_GAMM_POOL_ASSET = "/osmosis.gamm.v1beta1.PoolAsset";
/**
 * JSON serialization of `osmosis.gamm.v1beta1.PoolAsset` - Pool asset is an internal struct that combines the amount of the token in the pool, and its balancer weight. This is an awkward packaging of data, and should be revisited in a future state migration.
 */
export type OsmosisGammPoolAsset = {
    token?: CosmosBaseCoin | undefined;
    weight?: string | undefined;
};
/**
 * Destructures the fields of a {@link OsmosisGammPool} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: address -
 *   - 1: id -
 *   - 2: pool_params -
 *   - 3: future_pool_governor - This string specifies who will govern the pool in the future. Valid forms of this are: {token name},{duration} {duration} where {token name} if specified is the token which determines the governor, and if not specified is the LP token for this pool.duration is a time specified as 0w,1w,2w, etc. which specifies how long the token would need to be locked up to count in governance. 0w means no lockup. TODO: Further improve these docs
 *   - 4: total_shares - sum of all LP tokens sent out
 *   - 5: pool_assets - These are assumed to be sorted by denomiation. They contain the pool asset and the information about the weight
 *   - 6: total_weight - sum of all non-normalized pool weights
 */
export declare const destructOsmosisGammPool: (g_struct: OsmosisGammPool) => [address?: CwAccountAddr, id?: CwUint64, pool_params?: OsmosisGammPoolParams, future_pool_governor?: string, total_shares?: CosmosBaseCoin, pool_assets?: OsmosisGammPoolAsset[], total_weight?: string];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_GAMM_POOL = "/osmosis.gamm.v1beta1.Pool";
/**
 * JSON serialization of `osmosis.gamm.v1beta1.Pool` -
 */
export type OsmosisGammPool = {
    address?: CwAccountAddr | undefined;
    id?: CwUint64 | undefined;
    pool_params?: OsmosisGammPoolParams | undefined;
    future_pool_governor?: string | undefined;
    total_shares?: CosmosBaseCoin | undefined;
    pool_assets?: OsmosisGammPoolAsset[] | undefined;
    total_weight?: string | undefined;
};
