import type { WeakUint64Str, SlimCoin, CwUint64 } from '@solar-republic/types';
import type { Encoded, Opt, WeakTimestampStr, WeakDurationStr } from '../../../api/types.js';
import type { CosmosBaseCoin } from '../../cosmos/base/v1beta1/coin.js';
import type { OsmosisLockupQueryCondition, DecodedOsmosisLockupQueryCondition } from '../lockup/lock.js';
export type EncodedOsmosisIncentivesGauge = Encoded<'/osmosis.incentives.Gauge'>;
export type EncodedOsmosisIncentivesLockableDurationsInfo = Encoded<'/osmosis.incentives.LockableDurationsInfo'>;
/**
 * Encodes a `Gauge` protobuf message: an object that stores and distributes yields to recipients who satisfy certain conditions. Currently gauges support conditions around the duration for which a given denom is locked.
 * @param sg_id - `id`: the unique ID of a Gauge
 * @param b_is_perpetual - `is_perpetual`: a flag to show if it's a perpetual or non-perpetual gauge Non-perpetual gauges distribute their tokens equally per epoch while the gauge is in the active period. Perpetual gauges distribute all their tokens at a single time and only distribute their tokens again once the gauge is refilled, Intended for use with incentives that get refilled daily.
 * @param g_distribute_to - `distribute_to`: where the gauge rewards are distributed to. This is queried via lock duration or by timestamp
 * @param a_coins - `coins`: the total amount of coins that have been in the gauge Can distribute multiple coin denoms
 * @param xt_start_time - `start_time`: the distribution start time
 * @param sg_num_epochs_paid_over - `num_epochs_paid_over`: the number of total epochs distribution will be completed over
 * @param sg_filled_epochs - `filled_epochs`: the number of epochs distribution has been completed on already
 * @param a_distributed_coins - `distributed_coins`: coins that have been distributed already
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisIncentivesGauge: (sg_id?: Opt<WeakUint64Str>, b_is_perpetual?: Opt<boolean | 0 | 1>, atu8_distribute_to?: Opt<Encoded<'/osmosis.lockup.QueryCondition'>>, a_coins?: Opt<SlimCoin[]>, xt_start_time?: Opt<number>, sg_num_epochs_paid_over?: Opt<WeakUint64Str>, sg_filled_epochs?: Opt<WeakUint64Str>, a_distributed_coins?: Opt<SlimCoin[]>) => EncodedOsmosisIncentivesGauge;
/**
 * Encodes a `LockableDurationsInfo` protobuf message:
 * @param a_lockable_durations - `lockable_durations`: List of incentivised durations that gauges will pay out to
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisIncentivesLockableDurationsInfo: (a_lockable_durations?: Opt<number[]>) => EncodedOsmosisIncentivesLockableDurationsInfo;
/**
 * A decoded protobuf Gauge message
 *
 * Tuple where:
 *   - 0: id - the unique ID of a Gauge
 *   - 1: is_perpetual - a flag to show if it's a perpetual or non-perpetual gauge Non-perpetual gauges distribute their tokens equally per epoch while the gauge is in the active period. Perpetual gauges distribute all their tokens at a single time and only distribute their tokens again once the gauge is refilled, Intended for use with incentives that get refilled daily.
 *   - 2: distribute_to - where the gauge rewards are distributed to. This is queried via lock duration or by timestamp
 *   - 3: coins - the total amount of coins that have been in the gauge Can distribute multiple coin denoms
 *   - 4: start_time - the distribution start time
 *   - 5: num_epochs_paid_over - the number of total epochs distribution will be completed over
 *   - 6: filled_epochs - the number of epochs distribution has been completed on already
 *   - 7: distributed_coins - coins that have been distributed already
 */
export type DecodedOsmosisIncentivesGauge = [
    sg_id?: CwUint64,
    b_is_perpetual?: 0 | 1,
    a_distribute_to?: DecodedOsmosisLockupQueryCondition,
    a_coins?: [
        string,
        string
    ][],
    a_start_time?: [
        string,
        number
    ],
    sg_num_epochs_paid_over?: CwUint64,
    sg_filled_epochs?: CwUint64,
    a_distributed_coins?: [
        string,
        string
    ][]
];
/**
 * Decodes a protobuf Gauge message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisIncentivesGauge}
 */
export declare const decodeOsmosisIncentivesGauge: (atu8_payload: Uint8Array) => DecodedOsmosisIncentivesGauge;
/**
 * A decoded protobuf LockableDurationsInfo message
 *
 * Alias for: lockable_durations - List of incentivised durations that gauges will pay out to
 */
export type DecodedOsmosisIncentivesLockableDurationsInfo = [
    a_lockable_durations?: [
        string,
        number
    ][]
];
/**
 * Decodes a protobuf LockableDurationsInfo message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisIncentivesLockableDurationsInfo}
 */
export declare const decodeOsmosisIncentivesLockableDurationsInfo: (atu8_payload: Uint8Array) => DecodedOsmosisIncentivesLockableDurationsInfo;
/**
 * Destructures the fields of a {@link OsmosisIncentivesGauge} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: id - the unique ID of a Gauge
 *   - 1: is_perpetual - a flag to show if it's a perpetual or non-perpetual gauge Non-perpetual gauges distribute their tokens equally per epoch while the gauge is in the active period. Perpetual gauges distribute all their tokens at a single time and only distribute their tokens again once the gauge is refilled, Intended for use with incentives that get refilled daily.
 *   - 2: distribute_to - where the gauge rewards are distributed to. This is queried via lock duration or by timestamp
 *   - 3: coins - the total amount of coins that have been in the gauge Can distribute multiple coin denoms
 *   - 4: start_time - the distribution start time
 *   - 5: num_epochs_paid_over - the number of total epochs distribution will be completed over
 *   - 6: filled_epochs - the number of epochs distribution has been completed on already
 *   - 7: distributed_coins - coins that have been distributed already
 */
export declare const destructOsmosisIncentivesGauge: (g_struct: OsmosisIncentivesGauge) => [id?: CwUint64, is_perpetual?: boolean, distribute_to?: OsmosisLockupQueryCondition, coins?: CosmosBaseCoin[], start_time?: number, num_epochs_paid_over?: CwUint64, filled_epochs?: CwUint64, distributed_coins?: CosmosBaseCoin[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_INCENTIVES_GAUGE = "/osmosis.incentives.Gauge";
/**
 * JSON serialization of `osmosis.incentives.Gauge` - an object that stores and distributes yields to recipients who satisfy certain conditions. Currently gauges support conditions around the duration for which a given denom is locked.
 */
export type OsmosisIncentivesGauge = {
    id?: CwUint64 | undefined;
    is_perpetual?: boolean | undefined;
    distribute_to?: OsmosisLockupQueryCondition | undefined;
    coins?: CosmosBaseCoin[] | undefined;
    start_time?: WeakTimestampStr | undefined;
    num_epochs_paid_over?: CwUint64 | undefined;
    filled_epochs?: CwUint64 | undefined;
    distributed_coins?: CosmosBaseCoin[] | undefined;
};
/**
 * Destructures the fields of a {@link OsmosisIncentivesLockableDurationsInfo} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: lockable_durations - List of incentivised durations that gauges will pay out to
 */
export declare const destructOsmosisIncentivesLockableDurationsInfo: (g_struct: OsmosisIncentivesLockableDurationsInfo) => [lockable_durations?: number[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_INCENTIVES_LOCKABLE_DURATIONS_INFO = "/osmosis.incentives.LockableDurationsInfo";
/**
 * JSON serialization of `osmosis.incentives.LockableDurationsInfo` -
 */
export type OsmosisIncentivesLockableDurationsInfo = {
    lockable_durations?: WeakDurationStr[] | undefined;
};
