import { parse_timestamp } from '../../../../api/json.js';
import { decode_protobuf, decode_temporal } from '../../../../api/protobuf-reader.js';
import { Protobuf, temporal } from '../../../../api/protobuf-writer.js';
/**
 * Encodes a `TwapRecord` protobuf message: A TWAP record should be indexed in state by pool_id, (asset pair), timestamp The asset pair assets should be lexicographically sorted. Technically (pool_id, asset_0_denom, asset_1_denom, height) do not need to appear in the struct however we view this as the wrong performance tradeoff given SDK today. Would rather we optimize for readability and correctness, than an optimal state storage format. The system bottleneck is elsewhere for now.
 * @param sg_pool_id - `pool_id`:
 * @param s_asset0_denom - `asset0_denom`: Lexicographically smaller denom of the pair
 * @param s_asset1_denom - `asset1_denom`: Lexicographically larger denom of the pair
 * @param sg_height - `height`: this record corresponds to, for debugging purposes
 * @param xt_time - `time`: This field should only exist until we have a global registry in the state machine, mapping prior block heights within {TIME RANGE} to times.
 * @param s_p0_last_spot_price - `p0_last_spot_price`: We store the last spot prices in the struct, so that we can interpolate accumulator values for times between when accumulator records are stored.
 * @param s_p1_last_spot_price - `p1_last_spot_price`:
 * @param s_p0_arithmetic_twap_accumulator - `p0_arithmetic_twap_accumulator`:
 * @param s_p1_arithmetic_twap_accumulator - `p1_arithmetic_twap_accumulator`:
 * @param s_geometric_twap_accumulator - `geometric_twap_accumulator`:
 * @param xt_last_error_time - `last_error_time`: This field contains the time in which the last spot price error occured. It is used to alert the caller if they are getting a potentially erroneous TWAP, due to an unforeseen underlying error.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeOsmosisTwapTwapRecord = (sg_pool_id, s_asset0_denom, s_asset1_denom, sg_height, xt_time, s_p0_last_spot_price, s_p1_last_spot_price, s_p0_arithmetic_twap_accumulator, s_p1_arithmetic_twap_accumulator, s_geometric_twap_accumulator, xt_last_error_time) => Protobuf() // ...
    .g(sg_pool_id) // uint64 pool_id = 1
    .s(s_asset0_denom) // string asset0_denom = 2
    .s(s_asset1_denom) // string asset1_denom = 3
    .g(sg_height) // int32 height = 4
    .b(temporal(xt_time)) // Timestamp time = 5
    .s(s_p0_last_spot_price) // string p0_last_spot_price = 6
    .s(s_p1_last_spot_price) // string p1_last_spot_price = 7
    .s(s_p0_arithmetic_twap_accumulator) // string p0_arithmetic_twap_accumulator = 8
    .s(s_p1_arithmetic_twap_accumulator) // string p1_arithmetic_twap_accumulator = 9
    .s(s_geometric_twap_accumulator) // string geometric_twap_accumulator = 10
    .b(temporal(xt_last_error_time)) // Timestamp last_error_time = 11
    .o;
/**
 * Decodes a protobuf TwapRecord message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisTwapTwapRecord}
 */
export const decodeOsmosisTwapTwapRecord = (atu8_payload) => decode_protobuf(atu8_payload, [3, 5, 5, 3, [3, 1], 5, 5, 5, 5, 5, [3, 1]], [0, 0, 0, 0, decode_temporal, 0, 0, 0, 0, 0, decode_temporal]);
/**
 * Destructures the fields of a {@link OsmosisTwapTwapRecord} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: pool_id -
 *   - 1: asset0_denom - Lexicographically smaller denom of the pair
 *   - 2: asset1_denom - Lexicographically larger denom of the pair
 *   - 3: height - this record corresponds to, for debugging purposes
 *   - 4: time - This field should only exist until we have a global registry in the state machine, mapping prior block heights within {TIME RANGE} to times.
 *   - 5: p0_last_spot_price - We store the last spot prices in the struct, so that we can interpolate accumulator values for times between when accumulator records are stored.
 *   - 6: p1_last_spot_price -
 *   - 7: p0_arithmetic_twap_accumulator -
 *   - 8: p1_arithmetic_twap_accumulator -
 *   - 9: geometric_twap_accumulator -
 *   - 10: last_error_time - This field contains the time in which the last spot price error occured. It is used to alert the caller if they are getting a potentially erroneous TWAP, due to an unforeseen underlying error.
 */
export const destructOsmosisTwapTwapRecord = (g_struct) => [g_struct.pool_id, g_struct.asset0_denom, g_struct.asset1_denom, g_struct.height, parse_timestamp(g_struct.time), g_struct.p0_last_spot_price, g_struct.p1_last_spot_price, g_struct.p0_arithmetic_twap_accumulator, g_struct.p1_arithmetic_twap_accumulator, g_struct.geometric_twap_accumulator, parse_timestamp(g_struct.last_error_time)];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_OSMOSIS_TWAP_TWAP_RECORD = '/osmosis.twap.v1beta1.TwapRecord';
//# sourceMappingURL=twap_record.js.map