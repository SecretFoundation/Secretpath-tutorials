/**
 * Callback that returns or resolves to a private key as an Uint8Array.
 */
export type KeyProducer<dc_type extends ArrayBufferView = Uint8Array> = () => dc_type | Promise<dc_type>;
/**
 * Maintains a private key that needs to exist in process memory when used, but can otherwise benefit from
 * cryptographic subsystem security at rest. This is necessary for elliptic curves that are not supported
 * by the Web Crypto API such as secp256k1 .
 */
export declare class RuntimeKey {
    /**
     * Create a new private key object. This function will also wipe the contents of the original private key from memory.
     * @param atu8_sk - the private key (will get zeroed out immediately after calling)
     */
    static create(fk_sk: KeyProducer, ni_bits?: number): Promise<RuntimeKey>;
    /**
     * Create a new private key object. This function will also wipe the contents of the original private key from memory.
     * @param atu8_sk - the private key (will get zeroed out immediately after calling)
     */
    static createRaw(atu8_sk: Uint8Array, ni_bits?: number): Promise<RuntimeKey>;
    /**
     * Construct privately since initialization is asynchronous.
     */
    private constructor();
    /**
     * Recreate the private key, only allowing it to exist in stack memory within a single event loop tick.
     */
    access<w_return = unknown>(fk_use: (atu8_sk: Uint8Array) => w_return): Promise<Awaited<w_return>>;
    /**
     * Destroy the instance and any of its materials
     */
    destroy(): void;
    /**
     * Clones the instance and it's backing buffer
     */
    clone(): Promise<RuntimeKey>;
}
