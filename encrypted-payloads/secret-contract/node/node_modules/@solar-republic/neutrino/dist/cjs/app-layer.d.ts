import type { CreateQueryArgsAndAuthParams } from './inferencing.js';
import type { SecretContract } from './secret-contract.js';
import type { AuthSecret, LcdRpcStruct, TxResultWrapper, WeakSecretAccAddr } from './types.js';
import type { Wallet } from './wallet.js';
import type { JsonObject, Nilable, Promisable, NaiveJsonString } from '@blake.regalia/belt';
import type { ContractInterface } from '@solar-republic/contractor';
import type { TendermintAbciTxResult } from '@solar-republic/cosmos-grpc/tendermint/abci/types';
import type { SecretQueryPermit, SlimCoin, WeakAccountAddr, TrustedContextUrl, WeakUint128Str } from '@solar-republic/types';
export type RetryParams = [
    xt_wait: number
];
export declare const retry: <w_out>(f_broadcast: (c_attempts: number) => Promise<w_out>, f_handle: (z_error: unknown, c_attempts: number) => Promisable<RetryParams | Nilable<void>>, c_attempts?: number) => Promise<w_out>;
/**
 * Opens a new Tendermint JSONRPC WebSocket and immediately subscribes using the given query.
 * Users should close the WebSocket when no longer needed
 * @param p_rpc - RPC endpoint as an HTTPS base URL without trailing slash, e.g., "https://rpc.provider.net"
 * @param sx_query - the Tendermint query to filter events by, e.g., "tm.event='Tx'"
 * @param fk_message - callback for each message
 * @returns - the WebSocket instance
 */
export declare const subscribe_tendermint_events: (p_rpc: TrustedContextUrl, sx_query: string, fk_message: (d_event: MessageEvent<NaiveJsonString>) => any) => Promise<WebSocket>;
/**
 * Broadcast a transaction to the network for its result
 * @param gc_node
 * @param atu8_raw
 * @param si_txn
 * @returns tuple of `[number, string, TxResponse?]`
 *  - [0]: `xc_code: number` - error code from chain, or non-OK HTTP status code from the LCD server.
 * 		A value of `0` indicates success. A value of `-1` indicates a JSON parsing error.
 *  - [1]: `sx_res: string` - raw response text from the initial broadcast request (result of CheckTx)
 *  - [2]: `tx_res?: `{@link TxResponse} - on success, the parsed transaction response JSON object
 */
export declare const broadcast_result: (gc_node: LcdRpcStruct, atu8_raw: Uint8Array, si_txn: string) => Promise<[
    xc_code: number,
    sx_res: string,
    g_tx_res?: Nilable<TxResultWrapper['TxResult']>
]>;
/**
 * Query a Secret Contract method
 * @param k_contract
 * @param h_query
 * @returns tuple of `[number, string, JsonObject?]` where:
 *  - [0]: `xc_code: number` - error code from chain, or non-OK HTTP status code from the LCD server.
 * 		A value of `0` indicates success.
 *  - [1]: `s_error: string` - error message from chain or HTTP response body
 *  - [3]: `h_answer?: JsonObject` - contract response as JSON object on success
 */
export declare const query_secret_contract: <g_interface extends {
    config: {
        all_executions?: import("@solar-republic/contractor").MethodDescriptor;
        default_execution_answer?: JsonObject<never>;
        all_queries?: import("@solar-republic/contractor").MethodDescriptor;
        snip52_channels?: import("@solar-republic/contractor").Snip52ChannelDict;
    };
    executions: JsonObject<never>;
    queries: JsonObject<never>;
}, h_variants extends ContractInterface.MsgAndAnswer<g_interface, "queries", keyof g_interface["queries"]>, g_variant extends h_variants[keyof h_variants]>(k_contract: SecretContract<g_interface>, h_query: g_variant["msg"]) => Promise<[xc_code: number, s_error: string, h_answer?: g_variant["answer"]]>;
/**
 * Format a query message given its method id and args object, and optionally an auth secret.
 *
 * If an auth secret is given, the resulting query object will use the typical shape for that method.
 *
 * Depending on auth secret's type (see {@link AuthSecret}):
 *  - _falsy_: no auth -- `{[method]: args}`
 *  - `string`: Viewing Key -- `{[method]:args, key:z_auth}`
 *  - `[string, string?]`: ViewerInfo -- `{[method]:{...args, viewer:{viewing_key:z_auth[0], address?:z_auth[1]}}}`
 *  - `object`: QueryPermit -- `{with_permit:{query:{[method]:args}, permit:z_auth}}`
 *
 * @param si_method
 * @param h_query
 * @param z_auth
 * @returns
 */
export declare const format_secret_query: (si_method: string, h_query: object, z_auth?: Nilable<AuthSecret>) => JsonObject;
export interface QueryContractInfer {
    <g_interface extends ContractInterface, h_variants extends ContractInterface.MsgAndAnswer<g_interface, 'queries'>, si_method extends Extract<keyof h_variants, string>, g_variant extends h_variants[si_method]>(k_contract: SecretContract<g_interface>, si_method: si_method, ...[h_args, z_auth]: CreateQueryArgsAndAuthParams<h_variants, si_method, ContractInterface extends g_interface ? 1 : 0>): Promise<[
        w_result: g_variant['response'] | undefined,
        xc_code_x: number,
        s_error: string,
        h_answer?: g_variant['answer']
    ]>;
}
/**
 * Query a Secret Contract method and automatically apply an auth secret if one is provided.
 * Additionally, unwrap the success response if one was returned.
 * @param k_contract - the contract
 * @param si_method - which query method to invoke
 * @param h_args - the args value to pass in with the given query
 * @param z_auth - optional {@link AuthSecret} to perform an authenticated query
 * @returns tuple of `[JsonObject?, number, string, JsonObject?]` where:
 *  - [0]: `w_result?: JsonObject` - unwrapped contract result on success
 *  - [1]: `xc_code: number` - error code from chain, or non-OK HTTP status code from the LCD server.
 * 		A value of `0` indicates success.
 *  - [2]: `s_error: string` - error message from chain or HTTP response body
 *  - [3]: `h_answer?: JsonObject` - contract response as JSON object on success
 */
export declare const query_secret_contract_infer: QueryContractInfer;
/**
 * Execute a Secret Contract method using BROADCAST_MODE_SYNC and wait for confirmation via JSONRPC.
 * More reliable than `exec_contract_unreliable` which may appear to fail if the chain's block time exceeds node's broadcast timeout.
 * @param k_contract - a {@link SecretContract} instance
 * @param k_wallet - the {@link Wallet} of the sender
 * @param h_exec - the execution message as a plain object (to be JSON-encoded)
 * @param a_fees - an Array of {@link SlimCoin} describing the amounts and denoms of fees
 * @param sg_limit - the u128 gas limit to set for the transaction
 * @param sa_granter - optional granter address to use to pay for gas fee
 * @param a_funds - optional Array of {@link SlimCoin} of funds to send into the contract with the tx
 * @param s_memo - optional memo field
 * @returns tuple of `[number, string, TxResponse?]`
 *  - [0]: `xc_code: number` - error code from chain, or non-OK HTTP status code from the LCD server.
 * 		A value of `0` indicates success.
 *  - [1]: `s_res: string` - message text. on success, will be the contract's response as a JSON string.
 * 		on error, will be either the error string from HTTP response text, chain error message,
 * 		or contract error as a JSON string.
 *  - [2]: `g_tx_res?: `{@link TxResponse} - on success, the parsed transaction response JSON object
 *  - [3]: `si_txn?: string` - the transaction hash if a broadcast attempt was made
 *
 * @throws a {@link BroadcastResultErr}
 */
export declare const exec_secret_contract: <g_interface extends {
    config: {
        all_executions?: import("@solar-republic/contractor").MethodDescriptor;
        default_execution_answer?: JsonObject<never>;
        all_queries?: import("@solar-republic/contractor").MethodDescriptor;
        snip52_channels?: import("@solar-republic/contractor").Snip52ChannelDict;
    };
    executions: JsonObject<never>;
    queries: JsonObject<never>;
}, h_group extends ContractInterface.MsgAndAnswer<g_interface, "executions", keyof g_interface["executions"]>, as_methods extends Extract<keyof h_group, string>>(k_contract: SecretContract<g_interface>, k_wallet: Wallet<'secret'>, h_exec: {
    config: {
        all_executions?: import("@solar-republic/contractor").MethodDescriptor;
        default_execution_answer?: JsonObject<never>;
        all_queries?: import("@solar-republic/contractor").MethodDescriptor;
        snip52_channels?: import("@solar-republic/contractor").Snip52ChannelDict;
    };
    executions: JsonObject<never>;
    queries: JsonObject<never>;
} extends g_interface ? JsonObject<never> : { [si_method in as_methods]: h_group[si_method]["msg"]; }, a_fees: [SlimCoin, ...SlimCoin[]], sg_limit: WeakUint128Str, sa_granter?: WeakSecretAccAddr | '', a_funds?: SlimCoin[], s_memo?: string) => Promise<[xc_code: number, s_res: string, g_tx_res?: TendermintAbciTxResult | undefined, si_txn?: string]>;
/**
 * Sign a query permit and return the encoded object ready for use in a query
 * @param k_wallet
 * @param si_permit
 * @param a_tokens
 * @param a_permissions
 * @returns
 */
export declare const sign_secret_query_permit: (k_wallet: Wallet, si_permit: string, a_tokens: WeakAccountAddr<'secret'>[], a_permissions: string[]) => Promise<SecretQueryPermit>;
