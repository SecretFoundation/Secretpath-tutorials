import type { A, U } from 'ts-toolbelt';
import { type Dict } from '@blake.regalia/belt';
type AllPrefixes<si_key extends string> = si_key extends `${infer s_0}${infer s_rest}` ? s_0 | `${s_0}${AllPrefixes<s_rest>}` : never;
type AllSuffixes<si_key extends string> = si_key extends `${infer s_0}${infer s_slice0}` ? s_slice0 extends `${infer s_1}${infer s_slice1}${infer s_tail}` ? s_slice0 | AllSuffixes<s_slice0> : s_slice0 extends `${infer s_1}${infer s_slice1}` ? s_slice0 : '' : undefined;
type Mutations<si_key extends string> = si_key | `_${Exclude<AllPrefixes<si_key>, si_key>}` | `$${AllSuffixes<si_key>}`;
type Tpa<h_target extends Record<string, any>, as_keys extends Extract<keyof h_target, string> = Extract<keyof h_target, string>> = U.Merge<{
    [si_key in as_keys]: Record<Mutations<si_key>, h_target[si_key]>;
}[as_keys]>;
export declare const tpas: (h_target: Dict<any>, si_term: string) => any;
export declare const tpae: (h_target: Dict<any>, si_term: string) => any;
export declare const tpaw: (h_target: Dict<any>, si_term: string, xc_side?: 0 | 1) => any;
export declare const tpar: (h_target: Dict<any>, r_match: RegExp) => any;
export declare const tpa: <h_subject extends Record<string, any>>(h_subject: h_subject) => import("ts-toolbelt/out/Any/Compute").ComputeRaw<U.IntersectOf<import("ts-toolbelt/out/Any/Compute").ComputeRaw<{ [si_key in Extract<keyof h_subject, string>]: Record<Mutations<si_key>, h_subject[si_key]>; }[Extract<keyof h_subject, string>] extends infer T_1 ? T_1 extends { [si_key in Extract<keyof h_subject, string>]: Record<Mutations<si_key>, h_subject[si_key]>; }[Extract<keyof h_subject, string>] ? T_1 extends unknown ? T_1 & ({ [P in Exclude<A.Keys<{ [si_key in Extract<keyof h_subject, string>]: Record<Mutations<si_key>, h_subject[si_key]>; }[Extract<keyof h_subject, string>]>, keyof T_1>]: never; } extends infer T_2 ? { [K_1 in keyof T_2]?: { [P in Exclude<A.Keys<{ [si_key in Extract<keyof h_subject, string>]: Record<Mutations<si_key>, h_subject[si_key]>; }[Extract<keyof h_subject, string>]>, keyof T_1>]: never; }[K_1]; } : never) : never : never : never> extends infer T extends object ? { [K in keyof T]: K extends keyof import("ts-toolbelt/out/Any/Compute").ComputeRaw<{ [si_key in Extract<keyof h_subject, string>]: Record<Mutations<si_key>, h_subject[si_key]>; }[Extract<keyof h_subject, string>] extends infer T_1 ? T_1 extends { [si_key in Extract<keyof h_subject, string>]: Record<Mutations<si_key>, h_subject[si_key]>; }[Extract<keyof h_subject, string>] ? T_1 extends unknown ? T_1 & ({ [P in Exclude<A.Keys<{ [si_key in Extract<keyof h_subject, string>]: Record<Mutations<si_key>, h_subject[si_key]>; }[Extract<keyof h_subject, string>]>, keyof T_1>]: never; } extends infer T_2 ? { [K_1 in keyof T_2]?: { [P in Exclude<A.Keys<{ [si_key in Extract<keyof h_subject, string>]: Record<Mutations<si_key>, h_subject[si_key]>; }[Extract<keyof h_subject, string>]>, keyof T_1>]: never; }[K_1]; } : never) : never : never : never> ? (import("ts-toolbelt/out/Any/Compute").ComputeRaw<{ [si_key in Extract<keyof h_subject, string>]: Record<Mutations<si_key>, h_subject[si_key]>; }[Extract<keyof h_subject, string>] extends infer T_1 ? T_1 extends { [si_key in Extract<keyof h_subject, string>]: Record<Mutations<si_key>, h_subject[si_key]>; }[Extract<keyof h_subject, string>] ? T_1 extends unknown ? T_1 & ({ [P in Exclude<A.Keys<{ [si_key in Extract<keyof h_subject, string>]: Record<Mutations<si_key>, h_subject[si_key]>; }[Extract<keyof h_subject, string>]>, keyof T_1>]: never; } extends infer T_2 ? { [K_1 in keyof T_2]?: { [P in Exclude<A.Keys<{ [si_key in Extract<keyof h_subject, string>]: Record<Mutations<si_key>, h_subject[si_key]>; }[Extract<keyof h_subject, string>]>, keyof T_1>]: never; }[K_1]; } : never) : never : never : never> extends infer T_3 extends object ? { [K_2 in keyof T_3]-?: A.At<import("ts-toolbelt/out/Any/Compute").ComputeRaw<{ [si_key in Extract<keyof h_subject, string>]: Record<Mutations<si_key>, h_subject[si_key]>; }[Extract<keyof h_subject, string>] extends infer T_1 ? T_1 extends { [si_key in Extract<keyof h_subject, string>]: Record<Mutations<si_key>, h_subject[si_key]>; }[Extract<keyof h_subject, string>] ? T_1 extends unknown ? T_1 & ({ [P in Exclude<A.Keys<{ [si_key in Extract<keyof h_subject, string>]: Record<Mutations<si_key>, h_subject[si_key]>; }[Extract<keyof h_subject, string>]>, keyof T_1>]: never; } extends infer T_2 ? { [K_1 in keyof T_2]?: { [P in Exclude<A.Keys<{ [si_key in Extract<keyof h_subject, string>]: Record<Mutations<si_key>, h_subject[si_key]>; }[Extract<keyof h_subject, string>]>, keyof T_1>]: never; }[K_1]; } : never) : never : never : never>, K_2>; } : never)[K] : import("ts-toolbelt/out/Any/Compute").ComputeRaw<{ [si_key in Extract<keyof h_subject, string>]: Record<Mutations<si_key>, h_subject[si_key]>; }[Extract<keyof h_subject, string>] extends infer T_1 ? T_1 extends { [si_key in Extract<keyof h_subject, string>]: Record<Mutations<si_key>, h_subject[si_key]>; }[Extract<keyof h_subject, string>] ? T_1 extends unknown ? T_1 & ({ [P in Exclude<A.Keys<{ [si_key in Extract<keyof h_subject, string>]: Record<Mutations<si_key>, h_subject[si_key]>; }[Extract<keyof h_subject, string>]>, keyof T_1>]: never; } extends infer T_2 ? { [K_1 in keyof T_2]?: { [P in Exclude<A.Keys<{ [si_key in Extract<keyof h_subject, string>]: Record<Mutations<si_key>, h_subject[si_key]>; }[Extract<keyof h_subject, string>]>, keyof T_1>]: never; }[K_1]; } : never) : never : never : never>[K]; } : never>>;
export {};
