/// <reference types="web" />
/// <reference types="node" />
import type { Promisable } from '@blake.regalia/belt';
/**
 * Wrapper instance providing operations backed by libsecp256k1 WASM module
 */
export interface Secp256k1 {
    /**
     * Generates a new private key using crypto secure random bytes and without modulo bias
     * @returns a new private key (32 bytes)
     */
    gen_sk(): Uint8Array;
    /**
     * Asserts that the given private key is valid, throws otherwise
     * @param atu8_sk - the private key (32 bytes)
     * @returns the same `Uint8Array`
     */
    valid_sk(atu8_sk: Uint8Array): Uint8Array;
    /**
     * Computes the public key for a given private key
     * @param atu8_sk - the private key (32 bytes)
     * @param b_uncompressed - optional flag to return the uncompressed (65 byte) public key
     * @returns the public key (compressed to 33 bytes by default, or 65 if uncompressed)
     */
    sk_to_pk(atu8_sk: Uint8Array, b_uncompressed?: boolean): Uint8Array;
    /**
     * Signs the given message hash using the given private key.
     * @param atu8_sk - the private key
     * @param atu8_hash - the message hash (32 bytes)
     * @param atu8_entropy - optional entropy to use
     * @returns compact signature (64 bytes) as concatenation of `r || s`
     */
    sign(atu8_sk: Uint8Array, atu8_hash: Uint8Array, atu8_ent?: Uint8Array): Uint8Array;
    /**
     * Verifies the signature is valid for the given message hash and public key
     * @param atu8_signature - compact signature in `r || s` form (64 bytes)
     * @param atu8_msg - the message hash (32 bytes)
     * @param atu8_pk - the public key
     */
    verify(atu8_signature: Uint8Array, atu8_hash: Uint8Array, atu8_pk: Uint8Array): boolean;
    /**
     * ECDH key exchange. Computes a shared secret given a private key some public key
     * @param atu8_sk - the private key (32 bytes)
     * @param atu8_pk - the public key (33 or 65 bytes)
     * @returns the shared secret (32 bytes)
     */
    ecdh(atu8_sk: Uint8Array, atu8_pk: Uint8Array): Uint8Array;
}
/**
 * Creates a new instance of the secp256k1 WASM and returns its ES wrapper
 * @param z_src - a Response containing the WASM binary, a Promise that resolves to one,
 * 	or the raw bytes to the WASM binary as a {@link BufferSource}
 * @returns the wrapper API
 */
export declare const WasmSecp256k1: (z_src: Promisable<Response> | BufferSource) => Promise<Secp256k1>;
