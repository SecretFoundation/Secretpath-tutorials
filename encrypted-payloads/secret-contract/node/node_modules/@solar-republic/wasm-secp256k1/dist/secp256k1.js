const emsimp = (f_map_imports, s_tag) => {
    s_tag += ': ';
    let AB_HEAP;
    let ATU8_HEAP;
    let ATU32_HEAP;
    // eslint-disable-next-line no-console
    const console_out = (s_channel, s_out) => console[s_channel](s_tag + s_out.replace(/\0/g, '\n'));
    let s_error = '';
    const h_fds = {
        // stdout
        1(s_out) {
            console_out('debug', s_out);
        },
        // stderr
        2(s_out) {
            console_out('error', s_error = s_out);
        },
    };
    const g_imports = f_map_imports({
        abort() {
            throw Error(s_tag + (s_error || 'An unknown error occurred'));
        },
        memcpy: (ip_dst, ip_src, nb_size) => ATU8_HEAP.copyWithin(ip_dst, ip_src, ip_src + nb_size),
        resize(nb_size) {
            throw Error(s_tag + 'Out of memory');
        },
        write(i_fd, ip_iov, nl_iovs, ip_written) {
            // output string
            let s_out = '';
            // track number of bytes read from buffers
            let cb_read = 0;
            // each pending iov
            for (let i_iov = 0; i_iov < nl_iovs; i_iov++) {
                // start of buffer in memory
                const ip_start = ATU32_HEAP[ip_iov >> 2];
                // size of buffer
                const nb_len = ATU32_HEAP[ip_iov + 4 >> 2];
                // next iov
                ip_iov += 8;
                // extract text from buffer
                s_out += new TextDecoder().decode(ATU8_HEAP.subarray(ip_start, ip_start + nb_len));
                // update number of bytes read
                cb_read += nb_len;
            }
            // route to fd
            if (h_fds[i_fd]) {
                h_fds[i_fd](s_out);
            }
            // no fd found
            else {
                throw new Error(`libsecp256k1 tried writing to non-open file descriptor: ${i_fd}\n${s_out}`);
            }
            // write bytes read
            ATU32_HEAP[ip_written >> 2] = cb_read;
            // no error
            return 0;
        },
    });
    return [g_imports, (d_memory) => [
            AB_HEAP = d_memory.buffer,
            ATU8_HEAP = new Uint8Array(AB_HEAP),
            ATU32_HEAP = new Uint32Array(AB_HEAP),
        ]];
};

/*
* ================================
*     GENERATED FILE WARNING
* Do not edit this file manually.
* ================================
*/
const map_wasm_imports = (g_imports) => ({
    a: {
        a: g_imports.abort,
        f: g_imports.memcpy,
        d: g_imports.resize,
        e: () => 52, // _fd_close,
        c: () => 70, // _fd_seek,
        b: g_imports.write,
    },
});
const map_wasm_exports = (g_exports) => ({
    malloc: g_exports['i'],
    free: g_exports['j'],
    context_create: g_exports['l'],
    ec_pubkey_parse: g_exports['m'],
    ec_pubkey_serialize: g_exports['n'],
    ecdsa_signature_parse_compact: g_exports['o'],
    ecdsa_signature_serialize_compact: g_exports['p'],
    ecdsa_verify: g_exports['q'],
    ecdsa_sign: g_exports['r'],
    ec_seckey_verify: g_exports['s'],
    ec_pubkey_create: g_exports['t'],
    context_randomize: g_exports['u'],
    ecdh: g_exports['v'],
    sbrk: g_exports['sbrk'],
    memory: g_exports['g'],
    init: () => g_exports['h'](),
});

const S_TAG_ECDH = 'ECDH: ';
const S_TAG_ECDSA_VERIFY = 'ECDSA verify: ';
const S_REASON_INVALID_SK = 'Invalid private key';
const S_REASON_INVALID_PK = 'Invalid public key';
const bytes = (nb_len) => new Uint8Array(nb_len);
const random_32 = () => crypto.getRandomValues(bytes(32));
/**
 * Creates a new instance of the secp256k1 WASM and returns its ES wrapper
 * @param z_src - a Response containing the WASM binary, a Promise that resolves to one,
 * 	or the raw bytes to the WASM binary as a {@link BufferSource}
 * @returns the wrapper API
 */
const WasmSecp256k1 = async (z_src) => {
    // prepare the runtime
    const [g_imports, f_bind_heap] = emsimp(map_wasm_imports, 'wasm-secp256k1');
    // prep the wasm module
    let d_wasm;
    // instantiate wasm binary by streaming the response bytes
    if (z_src instanceof Response || z_src instanceof Promise) {
        d_wasm = await WebAssembly.instantiateStreaming(z_src, g_imports);
    }
    // instantiate using raw bianry
    else {
        d_wasm = await WebAssembly.instantiate(z_src, g_imports);
    }
    // create the libsecp256k1 exports struct
    const g_wasm = map_wasm_exports(d_wasm.instance.exports);
    // bind the heap and ref its view(s)
    const [, ATU8_HEAP, ATU32_HEAP] = f_bind_heap(g_wasm.memory);
    // call into the wasm module's init method
    g_wasm.init();
    // ref malloc function
    const malloc = g_wasm.malloc;
    const ip_sk = malloc(32 /* ByteLens.PRIVATE_KEY */);
    const ip_ent = malloc(32 /* ByteLens.NONCE_ENTROPY */);
    const ip_seed = malloc(32 /* ByteLens.RANDOM_SEED */);
    const ip_sk_shared = malloc(32 /* ByteLens.ECDH_SHARED_SK */);
    const ip_msg_hash = malloc(32 /* ByteLens.MSG_HASH */);
    // scratch spaces
    const ip_sig_scratch = malloc(64 /* ByteLens.ECDSA_SIG_COMPACT */);
    const ip_pk_scratch = malloc(65 /* ByteLens.PUBLIC_KEY_MAX */);
    // library handle: secp256k1_pubkey
    const ip_pk_lib = malloc(64 /* ByteLens.PUBLIC_KEY_LIB */);
    // library handle: secp256k1_ecdsa_signature
    const ip_sig_lib = malloc(64 /* ByteLens.ECDSA_SIG_LIB */);
    // create a reusable context
    const ip_ctx = g_wasm.context_create(513 /* Flags.CONTEXT_SIGN */ | 257 /* Flags.CONTEXT_VERIFY */);
    // length specifier
    const ip_len = g_wasm.malloc(4);
    const ip32_len = ip_len >> 2;
    /**
     * Pads the given input data before copying it into the heap at the given location; throws if input
     * data exceeds expected size
     * @param atu8_data - the data to put into program memory
     * @param ib_write - the starting byte position to write into
     * @param nb_size - the size of the region
     */
    const put_bytes = (atu8_data, ip_write, nb_size) => {
        const atu8_buffer = bytes(nb_size);
        atu8_buffer.set(atu8_data);
        ATU8_HEAP.set(atu8_buffer, ip_write);
    };
    /**
     * Randomizes the context for better protection against CPU side-channel attacks
     */
    const randomize_context = () => {
        // put random seed bytes into place
        put_bytes(random_32(), ip_seed, 32 /* ByteLens.RANDOM_SEED */);
        // randomize context
        if (1 /* BinaryResult.SUCCESS */ !== g_wasm.context_randomize(ip_ctx, ip_seed)) {
            throw Error('Failed to randomize context');
        }
    };
    /**
     * Parses the input public key in preparation for use by some method
     * @param atu8_sk - the private key
     * @returns `true` on success, `false` otherwise
     */
    const parse_pubkey = (atu8_pk) => {
        // copy input bytes into place
        put_bytes(atu8_pk, ip_pk_scratch, 65 /* ByteLens.PUBLIC_KEY_MAX */);
        // parse public key
        return 1 /* BinaryResult.SUCCESS */ === g_wasm.ec_pubkey_parse(ip_ctx, ip_pk_lib, ip_pk_scratch, atu8_pk.length);
    };
    /**
     * Puts the given private key into program memory, runs the given callback, then zeroes out the key
     * @param atu8_sk - the private key
     * @param f_use - callback to use the key
     * @returns whatever the callback returns
     */
    const with_sk = (atu8_sk, f_use) => {
        // prep callback return
        let w_return;
        // in case of any exception..
        try {
            // copy input bytes into place
            put_bytes(atu8_sk, ip_sk, 32 /* ByteLens.PRIVATE_KEY */);
            // use private key
            w_return = f_use();
        }
        finally {
            // zero-out private key
            ATU8_HEAP.fill(0, ip_sk, ip_sk + 32 /* ByteLens.PRIVATE_KEY */);
        }
        // forward result
        return w_return;
    };
    /**
     * Serializes the public key
     * @param b_uncompressed - whether or not the result should be in compressed form (33 bytes) or not (65 bytes)
     * @returns the public key as a buffer
     */
    const get_pk = (b_uncompressed = false) => {
        // output length of public key
        const nb_pk = b_uncompressed ? 65 /* ByteLens.PUBLIC_KEY_UNCOMPRESSED */ : 33 /* ByteLens.PUBLIC_KEY_COMPRESSED */;
        // // set target output length in little endian for WASM runtime
        // DV_HEAP.setUint32(ip_len, nb_pk, true);
        // set target output length (the Web has basically become LE-only)
        ATU32_HEAP[ip32_len] = nb_pk;
        // prep compression flag
        const xm_compression = b_uncompressed ? 2 /* Flags.COMPRESSION_UNCOMPRESSED */ : 258 /* Flags.COMPRESSION_COMPRESSED */;
        // serialize public key
        g_wasm.ec_pubkey_serialize(ip_ctx, ip_pk_scratch, ip_len, ip_pk_lib, xm_compression);
        // extract result
        return ATU8_HEAP.slice(ip_pk_scratch, ip_pk_scratch + nb_pk);
    };
    /**
     * Asserts the private key is valid
     * @param atu8_sk - the private key (32 bytes)
     * @returns the valid private key, or throws if the caller somehow discovered an invalid sk
     */
    const valid_sk = (atu8_sk) => {
        // while using the private key, assert the length is valid and the point falls within curve order
        if (with_sk(atu8_sk, () => 32 /* ByteLens.PRIVATE_KEY */ !== atu8_sk.length || 1 /* BinaryResult.SUCCESS */ !== g_wasm.ec_seckey_verify(ip_ctx, ip_sk))) {
            throw Error(S_REASON_INVALID_SK);
        }
        // return the valid sk
        return atu8_sk;
    };
    return {
        gen_sk: () => valid_sk(crypto.getRandomValues(bytes(32 /* ByteLens.PRIVATE_KEY */))),
        valid_sk,
        sk_to_pk(atu8_sk, b_uncompressed = false) {
            // randomize context
            randomize_context();
            // while using the private key, compute its corresponding public key; from the docs:
            if (1 /* BinaryResult.SUCCESS */ !== with_sk(atu8_sk, () => g_wasm.ec_pubkey_create(ip_ctx, ip_pk_lib, ip_sk))) {
                throw Error('sk_to_pk: ' + S_REASON_INVALID_SK);
            }
            // serialize the public key
            return get_pk(b_uncompressed);
        },
        sign(atu8_sk, atu8_hash, atu8_ent = random_32()) {
            // randomize context
            randomize_context();
            // copy message hash bytes into place
            put_bytes(atu8_hash, ip_msg_hash, 32 /* ByteLens.MSG_HASH */);
            // copy entropy bytes into place
            put_bytes(atu8_ent, ip_ent, 32 /* ByteLens.NONCE_ENTROPY */);
            // while using the private key, sign the given message hash
            if (1 /* BinaryResult.SUCCESS */ !== with_sk(atu8_sk, () => g_wasm.ecdsa_sign(ip_ctx, ip_sig_lib, ip_msg_hash, ip_sk, 0, ip_ent))) {
                throw Error('ECDSA sign: ' + S_REASON_INVALID_SK);
            }
            // serialize the signature in compact form as `r || s` (64 bytes)
            g_wasm.ecdsa_signature_serialize_compact(ip_ctx, ip_sig_scratch, ip_sig_lib);
            // return serialized signature
            return ATU8_HEAP.slice(ip_sig_scratch, ip_sig_scratch + 64 /* ByteLens.ECDSA_SIG_COMPACT */);
        },
        verify(atu8_signature, atu8_hash, atu8_pk) {
            // copy signature bytes into place
            put_bytes(atu8_signature, ip_sig_scratch, 64 /* ByteLens.ECDSA_SIG_COMPACT */);
            // copy message hash bytes into place
            put_bytes(atu8_hash, ip_msg_hash, 32 /* ByteLens.MSG_HASH */);
            // parse the public key
            if (!parse_pubkey(atu8_pk)) {
                throw Error(S_TAG_ECDSA_VERIFY + S_REASON_INVALID_PK);
            }
            // parse the signature
            if (1 /* BinaryResult.SUCCESS */ !== g_wasm.ecdsa_signature_parse_compact(ip_ctx, ip_sig_lib, ip_sig_scratch)) {
                throw Error(S_TAG_ECDSA_VERIFY + 'Unparseable signature');
            }
            // verify the signature
            return 1 /* BinaryResult.SUCCESS */ === g_wasm.ecdsa_verify(ip_ctx, ip_sig_lib, ip_msg_hash, ip_pk_lib);
        },
        ecdh(atu8_sk, atu8_pk) {
            // parse public key
            if (!parse_pubkey(atu8_pk))
                throw Error(S_TAG_ECDH + S_REASON_INVALID_PK);
            // start using private key
            return with_sk(atu8_sk, () => {
                // perform ecdh computation
                if (1 /* BinaryResult.SUCCESS */ !== g_wasm.ecdh(ip_ctx, ip_sk_shared, ip_pk_lib, ip_sk)) {
                    throw Error(S_TAG_ECDH + S_REASON_INVALID_SK);
                }
                // return copy of result bytes
                return ATU8_HEAP.slice(ip_sk_shared, ip_sk_shared + 32 /* ByteLens.ECDH_SHARED_SK */);
            });
        },
    };
};

export { WasmSecp256k1 as W };
