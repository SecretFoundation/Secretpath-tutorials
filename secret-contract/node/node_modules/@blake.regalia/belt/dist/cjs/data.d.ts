import type { NaiveBase58, NaiveBase64, NaiveBase93, NaiveHexLower } from './strings';
import type { JsonValue } from './types';
export declare const uuid_v4: () => string;
type Uint8ArrayConstructorParams = [] | [length: number] | [array: ArrayLike<number> | ArrayBufferLike] | [buffer: ArrayBufferLike, byteOffset?: number, length?: number];
/**
 * Helps reduce codesize
 * @param a_args
 * @returns
 */
export declare const bytes: (...a_args: Uint8ArrayConstructorParams) => Uint8Array;
/**
 * Helps reduce codesize
 * @param a_args
 * @returns
 */
export declare const dataview: (buffer: ArrayBufferLike, byteOffset?: number | undefined, byteLength?: number | undefined) => DataView;
/**
 * Performs SHA-256 hash on the given data.
 * @param atu8_data data to hash
 * @returns the hash digest
 */
export declare const sha256: (atu8_data: Uint8Array) => Promise<Uint8Array>;
/**
 * Performs SHA-256(SHA-256(data))
 * @param atu8_data data to hash
 * @returns the hash digest
 */
export declare const sha256d: (atu8_data: Uint8Array) => Promise<Uint8Array>;
/**
 * Performs SHA-384 hash on the given data.
 * @param atu8_data data to hash
 * @returns the hash digest
 */
export declare const sha384: (atu8_data: Uint8Array) => Promise<Uint8Array>;
/**
 * Performs SHA-512 hash on the given data.
 * @param atu8_data data to hash
 * @returns the hash digest
 */
export declare const sha512: (atu8_data: Uint8Array) => Promise<Uint8Array>;
/**
 * Performs HMAC signing of the given message, **not the digest**.
 * @param atu8_sk private key
 * @param atu8_message message to sign, **not the digest**.
 * @returns HMAC signature
 */
export declare const hmac: (atu8_sk: Uint8Array, atu8_message: Uint8Array, si_algo?: 'SHA-256' | 'SHA-512') => Promise<Uint8Array>;
/**
 * Wipe the contents of a buffer so that sensitive data does not outlive garbage collection.
 */
export declare const zero_out: (atu8_data: number[] | Uint8Array | Uint16Array) => void;
export declare const encode_length_prefix_u16: (atu8_data: Uint8Array) => Uint8Array;
export declare const decode_length_prefix_u16: (atu8_encoded: Uint8Array) => [Uint8Array, Uint8Array];
/**
 * UTF-8 encodes the given text to an Uint8Array.
 * @param s_text text to encode
 * @returns UTF-8 encoded Uint8Array
 */
export declare const text_to_bytes: (s_text: string) => Uint8Array;
/**
 * UTF-8 decodes the given Uint8Array to text.
 * @param atu8_text UTF-8 encoded data to decode
 * @returns text
 */
export declare const bytes_to_text: (atu8_text: Uint8Array) => string;
/**
 * Converts the given base64-encoded string to a buffer, then UTF-8 decodes it.
 * @param sx_buffer input base64-encoded string
 * @returns text
 */
export declare const base64_to_text: (sx_buffer: string) => string;
/**
 * UTF-8 encodes the given text, then converts it to a base64-encoded string.
 * @param s_text text to encode
 * @returns output base64-encoded string
 */
export declare const text_to_base64: (s_text: string) => NaiveBase64;
/**
 * Attempts to JSON stringify the given primitive/object and subsequently UTF-8 encode it.
 * @param w_json JSON-compatible value to encode
 * @returns UTF-8 encoded Uint8Array
 */
export declare const json_to_bytes: (w_json: JsonValue) => Uint8Array;
/**
 * UTF-8 decodes the given Uint8Array and subsequently attempts to JSON parse it.
 * @param atu8_json UTF-8 encoded JSON string data
 * @returns parsed JSON value
 */
export declare const bytes_to_json: (atu8_json: Uint8Array) => JsonValue;
/**
 * Encodes the given 32-bit integer in big-endian format to a new buffer.
 * @param xg_uint
 * @returns
 */
export declare const uint32_to_bytes_be: (xg_uint: number | bigint) => Uint8Array;
/**
 * Decodes a 32-bit integer in big-endian format from a buffer (optionally at the given position).
 * @param n_uint
 * @returns
 */
export declare const bytes_to_uint32_be: (atu8_buffer: Uint8Array, ib_offset?: number) => number;
/**
 * Encodes the given bigint in big-endian format to a new 32-byte buffer, or whatever size is given.
 * @param xg_value - the value to encode
 * @param nb_size - size of the buffer to create
 * @returns the encoded buffer
 */
export declare const bigint_to_bytes_be: (xg_value: bigint, nb_size?: number) => Uint8Array;
/**
 * Decodes a bigint in big-endian format from a buffer
 * @param atu8_bytes
 * @returns
 */
export declare const bytes_to_bigint_be: (atu8_bytes: Uint8Array) => bigint;
/**
 * Converts a JSON object into its canonical form.
 * @param w_json JSON-compatible value to canonicalize
 * @returns canonicalized JSON value
 */
export declare const canonicalize_json: <w_json extends JsonValue>(w_json: w_json) => w_json;
/**
 * Attempts to parse the given JSON string, returning `undefined` on parse error instead of throwing
 * @param sx_json
 * @returns
 */
export declare const safe_json: <w_out extends JsonValue<void | undefined> = JsonValue>(sx_json: string) => w_out | undefined;
/**
 * Concatenate a sequence of Uint8Arrays.
 * @param a_buffers the data to concatenate in order
 * @returns the concatenated output Uint8Array
 */
export declare const concat: (a_buffers: Uint8Array[]) => Uint8Array;
/**
 * Concatenate two Uint8Arrays together.
 * @param atu8_buffer_a left side
 * @param atu8_buffer_b right side
 * @returns the concatenated output Uint8Array
 */
export declare const concat2: (atu8_a: Uint8Array, atu8_b: Uint8Array) => Uint8Array;
/**
 * Converts the given buffer to a hex string format in lowercase.
 * @param atu8_buffer input buffer
 * @returns output hex string
 */
export declare const bytes_to_hex: (atu8_buffer: Uint8Array) => NaiveHexLower;
/**
 * Converts the given hex string into a buffer.
 * @param sx_hex input hex string
 * @returns output buffer
 */
export declare const hex_to_bytes: (sx_hex: string) => Uint8Array;
/**
 * Converts the given buffer to a base64-encoded string using minimal code but at the expense of performance.
 * @param atu8_buffer input buffer
 * @returns output base64-encoded string
 */
export declare const bytes_to_base64_slim: (atu8_buffer: Uint8Array) => NaiveBase64;
/**
 * Converts the given base64-encoded string to a buffer using minimal code but at the expense of performance.
 * @param sx_buffer input base64-encoded string
 * @returns output buffer
 */
export declare const base64_to_bytes_slim: (sx_buffer: string) => Uint8Array;
/**
 * Converts the given buffer to a base64-encoded string.
 * @param atu8_buffer input buffer
 * @returns output base64-encoded string
 */
export declare const bytes_to_base64: (atu8_buffer: Uint8Array) => NaiveBase64;
/**
 * Converts the given base64-encoded string to a buffer.
 * @param sb64_data input base64-encoded string
 * @returns output buffer
 */
export declare const base64_to_bytes: (sb64_data: string) => Uint8Array;
/**
 * Converts the given UTF-8 friendly compact string to a buffer.
 * @param sx_buffer input string
 * @returns output buffer
 */
export declare const string8_to_bytes: (sx_buffer: string) => Uint8Array;
/**
 * Converts the given buffer to a base93-encoded string.
 * @param atu8_buffer input buffer
 * @returns output base93-encoded string
 */
export declare const bytes_to_base93: (atu8_buffer: Uint8Array) => NaiveBase93;
/**
 * Converts the given base93-encoded string to a buffer.
 * @param sb93_data input base93-encoded string
 * @returns output buffer
 */
export declare const base93_to_bytes: (sb93_data: string) => Uint8Array;
export declare const bytes_to_base58: (atu8_buffer: Uint8Array) => NaiveBase58;
export declare const base58_to_bytes: (sb58_buffer: string) => Uint8Array;
export {};
