import type { Dict, JsonObject } from './types';
/**
 * Utility nil buffer constant
 */
export declare const ATU8_NIL: Uint8Array;
/**
 * The frequently-used "no-operation" function
 */
export declare const F_NOOP: () => void;
/**
 * The seldomnly-used "identity" function
 */
export declare const F_IDENTITY: (w: any) => any;
/**
 * Creates a proper-case string
 */
export declare const proper: (s_input: string) => string;
/**
 * Simple test for whether a deserialized JSON value is a plain object (dict) or not
 */
export declare const is_dict: (z: unknown) => z is JsonObject<never>;
/**
 * More advanced test for whether an ES object is a plain object (dict) or not
 */
export declare const is_dict_es: (z: unknown) => z is JsonObject<never>;
/**
 * Fold array into an object
 */
export declare const fold: <w_out, w_value>(a_in: w_value[], f_fold: (z_value: w_value, i_each: number) => Dict<w_out>) => Dict<w_out>;
/**
 * Creates a new array by inserting an item in between every existing item
 */
export declare const interjoin: <w_item extends unknown, w_insert extends unknown>(a_input: w_item[], w_insert: w_insert) => (w_item | w_insert)[];
/**
 * Removes duplicates from an array, keeping only the first occurrence.
 * @param z_identify - if specified and a string, identifies the key of each item to use as an identifier
 * if specified and a function, used as a callback to produce the comparison key
 * if omitted, compares items using full equality `===`
 */
export declare const deduplicate: <z_item extends unknown, s_key extends keyof z_item = keyof z_item>(a_items: z_item[], z_identify?: s_key | ((z_item: z_item) => any) | undefined) => z_item[];
/**
 * Escape all special regex characters to turn a string into a verbatim match pattern
 * @param s_input input string
 * @returns escaped string ready for RegExp constructor
 */
export declare const escape_regex: (s_input: string) => string;
/**
 * Typed alias to `Object.entries`
 */
export declare const ode: <si_key extends string, w_value extends unknown>(h_object: Record<si_key, w_value>) => [si_key, w_value][];
/**
 * Typed alias to `Object.fromEntries`
 */
export declare const ofe: <as_keys extends string, w_values extends unknown>(a_entries: [as_keys, w_values][]) => Record<as_keys, w_values>;
/**
 * Helper type for defining the expected type for `[].reduce` alias
 */
type ReduceParameters<w_value extends any = any> = Parameters<Array<w_value>['reduce']>;
/**
 * Reduce object entries to an arbitrary type
 */
export declare const oder: <w_out extends unknown, si_key extends string, w_value extends unknown>(h_thing: Record<si_key, w_value>, f_reduce: ReduceParameters[0], w_init: w_out) => w_out;
/**
 * Reduce object entries to an array via concatenation
 */
export declare const oderac: <w_out extends unknown, si_key extends string, w_value extends unknown>(h_thing: Record<si_key, w_value>, f_concat: (si_key: si_key, w_value: w_value, i_entry: number) => w_out, b_add_undefs?: boolean) => w_out[];
/**
 * Reduce object entries to an array via flattening
 */
export declare const oderaf: <w_out extends unknown, si_key extends string, w_value extends unknown>(h_thing: Record<si_key, w_value>, f_concat: (si_key: si_key, w_value: w_value, i_entry: number) => w_out[]) => w_out[];
/**
 * Reduce object entries to an object via merging
 */
export declare const oderom: <w_value_out extends unknown, si_key_in extends string, w_value_in extends unknown, si_key_out extends string>(h_thing: Record<si_key_in, w_value_in>, f_merge: (si_key: si_key_in, w_value: w_value_in) => Record<si_key_in, w_value_out>) => Record<si_key_out, w_value_out>;
/**
 * Reduce object entries to an object via transforming value function
 */
export declare const fodemtv: <w_out extends unknown, si_key extends string, w_value extends unknown>(h_thing: Record<si_key, w_value>, f_transform: (w_value: w_value, si_key?: si_key | undefined) => w_out) => Record<si_key, w_value> extends infer T ? { [si_key_out in keyof T]: w_out; } : never;
/**
 * Promise-based version of `setTimeout()`
 */
export declare const timeout: (xt_wait: number) => Promise<void>;
export declare const timeout_exec: <w_return extends unknown = any>(xt_wait: number, f_attempt?: (() => Promise<w_return>) | undefined) => Promise<[w_return | undefined, 0 | 1]>;
export interface WithTimeoutConfig<w_value extends any> {
    duration: number;
    trip: () => void;
    run: () => Promise<w_value>;
}
export declare const with_timeout: <w_value extends unknown>(g_with: WithTimeoutConfig<w_value>) => Promise<w_value>;
/**
 * A Promise that never fulfills nor rejects
 */
export declare const forever: <w_type = void>(w_type?: w_type | undefined) => Promise<w_type>;
/**
 * Promse-based version of `queueMicrotask()`
 */
export declare const microtask: () => Promise<void>;
export declare const defer: <w_return extends unknown = any>() => [Promise<w_return>, (w_return: w_return, e_reject?: Error) => void];
export declare const defer_many: <h_input extends Dict<unknown>>(h_input: h_input) => {
    promises: { [si_each in keyof h_input]: Promise<h_input[si_each]>; };
    resolve(h_resolves: { [si_each_1 in keyof h_input]?: h_input[si_each_1]; }): void;
    reject(h_rejects: { [si_each_2 in keyof h_input]?: Error; }): void;
};
/**
 * Cryptographically strong random number
 */
export declare const crypto_random: () => number;
/**
 * Generate a random int within a given range
 */
export declare const random_int: (x_a: number, x_b?: number) => number;
/**
 * Generate a cryptographically strong random int within a given range
 */
export declare const crypto_random_int: (x_a: number, x_b?: number) => number;
type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array;
/**
 * Shuffles an array
 */
export declare const shuffle: <w_list extends any[] | TypedArray>(a_items: w_list, f_random?: (x_a: number, x_b?: number) => number) => w_list;
/**
 * Removes the first occurrence of the given item from the array
 * @param a_items
 * @param w_item
 * @returns
 */
export declare const remove: <w_item>(a_items: w_item[], w_item: w_item) => w_item[];
export {};
