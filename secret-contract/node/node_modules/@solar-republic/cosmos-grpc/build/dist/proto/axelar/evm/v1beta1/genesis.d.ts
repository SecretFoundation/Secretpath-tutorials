import type { Encoded, Opt } from '../../../../api/types.js';
import type { AxelarEvmParams, DecodedAxelarEvmParams } from './params.js';
import type { AxelarEvmBurnerInfo, DecodedAxelarEvmBurnerInfo, AxelarEvmERC20Deposit, DecodedAxelarEvmERC20Deposit, AxelarEvmCommandBatchMetadata, DecodedAxelarEvmCommandBatchMetadata, AxelarEvmGateway, DecodedAxelarEvmGateway, AxelarEvmERC20TokenMetadata, DecodedAxelarEvmERC20TokenMetadata, AxelarEvmEvent, DecodedAxelarEvmEvent } from './types.js';
import type { AxelarUtilsQueueState, DecodedAxelarUtilsQueueState } from '../../utils/v1beta1/queuer.js';
export type EncodedAxelarEvmGenesisState = Encoded<'/axelar.evm.v1beta1.GenesisState'>;
export type EncodedAxelarEvmGenesisStateChain = Encoded<'/axelar.evm.v1beta1.GenesisState.Chain'>;
/**
 * Encodes a `GenesisState` protobuf message: represents the genesis state
 * @param a_chains - `chains`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeAxelarEvmGenesisState: (a_chains?: Opt<Encoded<'/axelar.evm.v1beta1.GenesisState.Chain'>[]>) => EncodedAxelarEvmGenesisState;
/**
 * Encodes a `Chain` protobuf message:
 * @param g_params - `params`:
 * @param a_burner_infos - `burner_infos`:
 * @param g_command_queue - `command_queue`:
 * @param a_confirmed_deposits - `confirmed_deposits`:
 * @param a_burned_deposits - `burned_deposits`:
 * @param a_command_batches - `command_batches`:
 * @param g_gateway - `gateway`:
 * @param a_tokens - `tokens`:
 * @param a_events - `events`:
 * @param g_confirmed_event_queue - `confirmed_event_queue`:
 * @param a_legacy_confirmed_deposits - `legacy_confirmed_deposits`:
 * @param a_legacy_burned_deposits - `legacy_burned_deposits`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeAxelarEvmGenesisStateChain: (atu8_params?: Opt<Encoded<'/axelar.evm.v1beta1.Params'>>, a_burner_infos?: Opt<Encoded<'/axelar.evm.v1beta1.BurnerInfo'>[]>, atu8_command_queue?: Opt<Encoded<'/axelar.utils.v1beta1.QueueState'>>, a_confirmed_deposits?: Opt<Encoded<'/axelar.evm.v1beta1.ERC20Deposit'>[]>, a_burned_deposits?: Opt<Encoded<'/axelar.evm.v1beta1.ERC20Deposit'>[]>, a_command_batches?: Opt<Encoded<'/axelar.evm.v1beta1.CommandBatchMetadata'>[]>, atu8_gateway?: Opt<Encoded<'/axelar.evm.v1beta1.Gateway'>>, a_tokens?: Opt<Encoded<'/axelar.evm.v1beta1.ERC20TokenMetadata'>[]>, a_events?: Opt<Encoded<'/axelar.evm.v1beta1.Event'>[]>, atu8_confirmed_event_queue?: Opt<Encoded<'/axelar.utils.v1beta1.QueueState'>>, a_legacy_confirmed_deposits?: Opt<Encoded<'/axelar.evm.v1beta1.ERC20Deposit'>[]>, a_legacy_burned_deposits?: Opt<Encoded<'/axelar.evm.v1beta1.ERC20Deposit'>[]>) => EncodedAxelarEvmGenesisStateChain;
/**
 * A decoded protobuf GenesisState message
 *
 * Alias for: chains -
 */
export type DecodedAxelarEvmGenesisState = [
    w_0?: undefined,
    w_1?: undefined,
    a_chains?: DecodedAxelarEvmGenesisStateChain[]
];
/**
 * Decodes a protobuf GenesisState message
 * @param atu8_payload - raw bytes to decode
 * @param RESERVED - a second argument is explicitly forbidden. make sure not to pass this function by reference to some callback argument
 * @returns a {@link DecodedAxelarEvmGenesisState}
 */
export declare const decodeAxelarEvmGenesisState: (atu8_payload: Uint8Array, RESERVED?: never) => DecodedAxelarEvmGenesisState;
/**
 * A decoded protobuf Chain message
 *
 * Tuple where:
 *   - 0: params -
 *   - 1: burner_infos -
 *   - 2: command_queue -
 *   - 3: confirmed_deposits -
 *   - 4: burned_deposits -
 *   - 7: command_batches -
 *   - 8: gateway -
 *   - 9: tokens -
 *   - 10: events -
 *   - 11: confirmed_event_queue -
 *   - 12: legacy_confirmed_deposits -
 *   - 13: legacy_burned_deposits -
 */
export type DecodedAxelarEvmGenesisStateChain = [
    a_params?: DecodedAxelarEvmParams,
    a_burner_infos?: DecodedAxelarEvmBurnerInfo[],
    a_command_queue?: DecodedAxelarUtilsQueueState,
    a_confirmed_deposits?: DecodedAxelarEvmERC20Deposit[],
    a_burned_deposits?: DecodedAxelarEvmERC20Deposit[],
    w_0?: undefined,
    w_1?: undefined,
    a_command_batches?: DecodedAxelarEvmCommandBatchMetadata[],
    a_gateway?: DecodedAxelarEvmGateway,
    a_tokens?: DecodedAxelarEvmERC20TokenMetadata[],
    a_events?: DecodedAxelarEvmEvent[],
    a_confirmed_event_queue?: DecodedAxelarUtilsQueueState,
    a_legacy_confirmed_deposits?: DecodedAxelarEvmERC20Deposit[],
    a_legacy_burned_deposits?: DecodedAxelarEvmERC20Deposit[]
];
/**
 * Decodes a protobuf Chain message
 * @param atu8_payload - raw bytes to decode
 * @param RESERVED - a second argument is explicitly forbidden. make sure not to pass this function by reference to some callback argument
 * @returns a {@link DecodedAxelarEvmGenesisStateChain}
 */
export declare const decodeAxelarEvmGenesisStateChain: (atu8_payload: Uint8Array, RESERVED?: never) => DecodedAxelarEvmGenesisStateChain;
/**
 * Destructures the fields of a {@link AxelarEvmGenesisState} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 2: chains -
 */
export declare const destructAxelarEvmGenesisState: (g_struct: AxelarEvmGenesisState) => [EMPTY?: void, EMPTY?: void, chains?: AxelarEvmGenesisStateChain[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_AXELAR_EVM_GENESIS_STATE = "/axelar.evm.v1beta1.GenesisState";
/**
 * JSON serialization of `axelar.evm.v1beta1.GenesisState` - represents the genesis state
 */
export type AxelarEvmGenesisState = {
    chains?: AxelarEvmGenesisStateChain[] | undefined;
};
/**
 * Destructures the fields of a {@link AxelarEvmGenesisStateChain} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: params -
 *   - 1: burner_infos -
 *   - 2: command_queue -
 *   - 3: confirmed_deposits -
 *   - 4: burned_deposits -
 *   - 7: command_batches -
 *   - 8: gateway -
 *   - 9: tokens -
 *   - 10: events -
 *   - 11: confirmed_event_queue -
 *   - 12: legacy_confirmed_deposits -
 *   - 13: legacy_burned_deposits -
 */
export declare const destructAxelarEvmGenesisStateChain: (g_struct: AxelarEvmGenesisStateChain) => [params?: AxelarEvmParams, burner_infos?: AxelarEvmBurnerInfo[], command_queue?: AxelarUtilsQueueState, confirmed_deposits?: AxelarEvmERC20Deposit[], burned_deposits?: AxelarEvmERC20Deposit[], EMPTY?: void, EMPTY?: void, command_batches?: AxelarEvmCommandBatchMetadata[], gateway?: AxelarEvmGateway, tokens?: AxelarEvmERC20TokenMetadata[], events?: AxelarEvmEvent[], confirmed_event_queue?: AxelarUtilsQueueState, legacy_confirmed_deposits?: AxelarEvmERC20Deposit[], legacy_burned_deposits?: AxelarEvmERC20Deposit[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_AXELAR_EVM_GENESIS_STATE_CHAIN = "/axelar.evm.v1beta1.GenesisState.Chain";
/**
 * JSON serialization of `axelar.evm.v1beta1.GenesisState.Chain` -
 */
export type AxelarEvmGenesisStateChain = {
    params?: AxelarEvmParams | undefined;
    burner_infos?: AxelarEvmBurnerInfo[] | undefined;
    command_queue?: AxelarUtilsQueueState | undefined;
    confirmed_deposits?: AxelarEvmERC20Deposit[] | undefined;
    burned_deposits?: AxelarEvmERC20Deposit[] | undefined;
    command_batches?: AxelarEvmCommandBatchMetadata[] | undefined;
    gateway?: AxelarEvmGateway | undefined;
    tokens?: AxelarEvmERC20TokenMetadata[] | undefined;
    events?: AxelarEvmEvent[] | undefined;
    confirmed_event_queue?: AxelarUtilsQueueState | undefined;
    legacy_confirmed_deposits?: AxelarEvmERC20Deposit[] | undefined;
    legacy_burned_deposits?: AxelarEvmERC20Deposit[] | undefined;
};
