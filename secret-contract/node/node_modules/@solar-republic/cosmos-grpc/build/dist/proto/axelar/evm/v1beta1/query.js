import { __UNDEFINED } from '@blake.regalia/belt';
import { decode_protobuf } from '../../../../api/protobuf-reader.js';
import { Protobuf } from '../../../../api/protobuf-writer.js';
import { safe_base64_to_bytes } from '../../../../api/util.js';
import { decodeAxelarEvmParams } from './params.js';
import { decodeAxelarEvmEvent, decodeAxelarEvmBurnerInfo, decodeAxelarEvmTokenDetails } from './types.js';
/**
 * Encodes a `DepositQueryParams` protobuf message: describe the parameters used to query for an EVM deposit address
 * @param sa_address - `address`:
 * @param s_asset - `asset`:
 * @param s_chain - `chain`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmDepositQueryParams = (sa_address, s_asset, s_chain) => Protobuf() // ...
    .s(sa_address) // string address = 1
    .s(s_asset) // string asset = 2
    .s(s_chain) // string chain = 3
    .o;
/**
 * Encodes a `BatchedCommandsRequest` protobuf message:
 * @param s_chain - `chain`:
 * @param s_id - `id`: defines an optional id for the commandsbatch. If not specified the latest will be returned
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmBatchedCommandsRequest = (s_chain, s_id) => Protobuf() // ...
    .s(s_chain) // string chain = 1
    .s(s_id) // string id = 2
    .o;
/**
 * Encodes a `BatchedCommandsResponse` protobuf message:
 * @param s_id - `id`:
 * @param s_data - `data`:
 * @param xc_status - `status`:
 * @param si_key - `key_id`:
 * @param s_execute_data - `execute_data`:
 * @param si_prev_batched_commands - `prev_batched_commands_id`:
 * @param a_command_ids - `command_ids`:
 * @param g_proof - `proof`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmBatchedCommandsResponse = (s_id, s_data, xc_status, si_key, s_execute_data, si_prev_batched_commands, a_command_ids, atu8_proof) => Protobuf() // ...
    .s(s_id) // string id = 1
    .s(s_data) // string data = 2
    .v(xc_status) // BatchedCommandsStatus status = 3
    .s(si_key) // string key_id = 4
    .s(s_execute_data, 6) // string execute_data = 6
    .s(si_prev_batched_commands, 7) // string prev_batched_commands_id = 7
    .S(a_command_ids, 8) // string[] command_ids = 8
    .b(atu8_proof, 9) // Proof proof = 9
    .o;
/**
 * Encodes a `KeyAddressRequest` protobuf message:
 * @param s_chain - `chain`:
 * @param si_key - `key_id`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmKeyAddressRequest = (s_chain, si_key) => Protobuf() // ...
    .s(s_chain) // string chain = 1
    .s(si_key, 4) // string key_id = 4
    .o;
/**
 * Encodes a `KeyAddressResponse` protobuf message:
 * @param si_key - `key_id`:
 * @param a_addresses - `addresses`:
 * @param s_threshold - `threshold`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmKeyAddressResponse = (si_key, a_addresses, s_threshold) => Protobuf() // ...
    .s(si_key) // string key_id = 1
    .B(a_addresses) // WeightedAddress[] addresses = 2
    .s(s_threshold) // string threshold = 3
    .o;
/**
 * Encodes a `QueryTokenAddressResponse` protobuf message:
 * @param sa_address - `address`:
 * @param b_confirmed - `confirmed`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmQueryTokenAddressResponse = (sa_address, b_confirmed) => Protobuf() // ...
    .s(sa_address) // string address = 1
    .v(b_confirmed) // boolean confirmed = 2
    .o;
/**
 * Encodes a `QueryDepositStateParams` protobuf message:
 * @param atu8_tx_id - `tx_id`:
 * @param atu8_burner_address - `burner_address`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmQueryDepositStateParams = (atu8_tx_id, atu8_burner_address) => Protobuf() // ...
    .b(atu8_tx_id) // bytes tx_id = 1
    .b(atu8_burner_address) // bytes burner_address = 2
    .o;
/**
 * Encodes a `DepositStateRequest` protobuf message:
 * @param s_chain - `chain`:
 * @param g_params - `params`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmDepositStateRequest = (s_chain, atu8_params) => Protobuf() // ...
    .s(s_chain) // string chain = 1
    .b(atu8_params) // QueryDepositStateParams params = 2
    .o;
/**
 * Encodes a `DepositStateResponse` protobuf message:
 * @param xc_status - `status`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmDepositStateResponse = (xc_status) => Protobuf() // ...
    .v(xc_status, 2) // DepositStatus status = 2
    .o;
/**
 * Encodes a `EventRequest` protobuf message:
 * @param s_chain - `chain`:
 * @param si_event - `event_id`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmEventRequest = (s_chain, si_event) => Protobuf() // ...
    .s(s_chain) // string chain = 1
    .s(si_event) // string event_id = 2
    .o;
/**
 * Encodes a `EventResponse` protobuf message:
 * @param g_event - `event`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmEventResponse = (atu8_event) => Protobuf() // ...
    .b(atu8_event) // Event event = 1
    .o;
/**
 * Encodes a `QueryBurnerAddressResponse` protobuf message:
 * @param sa_address - `address`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmQueryBurnerAddressResponse = (sa_address) => Protobuf() // ...
    .s(sa_address) // string address = 1
    .o;
/**
 * Encodes a `ChainsRequest` protobuf message:
 * @param xc_status - `status`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmChainsRequest = (xc_status) => Protobuf() // ...
    .v(xc_status) // ChainStatus status = 1
    .o;
/**
 * Encodes a `ChainsResponse` protobuf message:
 * @param a_chains - `chains`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmChainsResponse = (a_chains) => Protobuf() // ...
    .S(a_chains) // string[] chains = 1
    .o;
/**
 * Encodes a `CommandRequest` protobuf message:
 * @param s_chain - `chain`:
 * @param s_id - `id`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmCommandRequest = (s_chain, s_id) => Protobuf() // ...
    .s(s_chain) // string chain = 1
    .s(s_id) // string id = 2
    .o;
/**
 * Encodes a `CommandResponse` protobuf message:
 * @param s_id - `id`:
 * @param s_type - `type`:
 * @param a_params - `params`:
 * @param si_key - `key_id`:
 * @param n_max_gas_cost - `max_gas_cost`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmCommandResponse = (s_id, s_type, a_params, si_key, n_max_gas_cost) => Protobuf() // ...
    .s(s_id) // string id = 1
    .s(s_type) // string type = 2
    .B(a_params) // ParamsEntry[] params = 3
    .s(si_key) // string key_id = 4
    .v(n_max_gas_cost) // uint32 max_gas_cost = 5
    .o;
/**
 * Encodes a `PendingCommandsRequest` protobuf message:
 * @param s_chain - `chain`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmPendingCommandsRequest = (s_chain) => Protobuf() // ...
    .s(s_chain) // string chain = 1
    .o;
/**
 * Encodes a `PendingCommandsResponse` protobuf message:
 * @param a_commands - `commands`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmPendingCommandsResponse = (a_commands) => Protobuf() // ...
    .B(a_commands) // QueryCommandResponse[] commands = 1
    .o;
/**
 * Encodes a `QueryCommandResponse` protobuf message:
 * @param s_id - `id`:
 * @param s_type - `type`:
 * @param a_params - `params`:
 * @param si_key - `key_id`:
 * @param n_max_gas_cost - `max_gas_cost`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmQueryCommandResponse = (s_id, s_type, a_params, si_key, n_max_gas_cost) => Protobuf() // ...
    .s(s_id) // string id = 1
    .s(s_type) // string type = 2
    .B(a_params) // ParamsEntry[] params = 3
    .s(si_key) // string key_id = 4
    .v(n_max_gas_cost) // uint32 max_gas_cost = 5
    .o;
/**
 * Encodes a `BurnerInfoRequest` protobuf message:
 * @param atu8_address - `address`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmBurnerInfoRequest = (atu8_address) => Protobuf() // ...
    .b(atu8_address) // bytes address = 1
    .o;
/**
 * Encodes a `BurnerInfoResponse` protobuf message:
 * @param s_chain - `chain`:
 * @param g_burner_info - `burner_info`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmBurnerInfoResponse = (s_chain, atu8_burner_info) => Protobuf() // ...
    .s(s_chain) // string chain = 1
    .b(atu8_burner_info) // BurnerInfo burner_info = 2
    .o;
/**
 * Encodes a `ConfirmationHeightRequest` protobuf message:
 * @param s_chain - `chain`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmConfirmationHeightRequest = (s_chain) => Protobuf() // ...
    .s(s_chain) // string chain = 1
    .o;
/**
 * Encodes a `ConfirmationHeightResponse` protobuf message:
 * @param sg_height - `height`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmConfirmationHeightResponse = (sg_height) => Protobuf() // ...
    .g(sg_height) // uint64 height = 1
    .o;
/**
 * Encodes a `GatewayAddressRequest` protobuf message:
 * @param s_chain - `chain`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmGatewayAddressRequest = (s_chain) => Protobuf() // ...
    .s(s_chain) // string chain = 1
    .o;
/**
 * Encodes a `GatewayAddressResponse` protobuf message:
 * @param sa_address - `address`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmGatewayAddressResponse = (sa_address) => Protobuf() // ...
    .s(sa_address) // string address = 1
    .o;
/**
 * Encodes a `BytecodeRequest` protobuf message:
 * @param s_chain - `chain`:
 * @param s_contract - `contract`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmBytecodeRequest = (s_chain, s_contract) => Protobuf() // ...
    .s(s_chain) // string chain = 1
    .s(s_contract) // string contract = 2
    .o;
/**
 * Encodes a `BytecodeResponse` protobuf message:
 * @param s_bytecode - `bytecode`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmBytecodeResponse = (s_bytecode) => Protobuf() // ...
    .s(s_bytecode) // string bytecode = 1
    .o;
/**
 * Encodes a `ERC20TokensRequest` protobuf message: describes the chain for which the type of ERC20 tokens are requested.
 * @param s_chain - `chain`:
 * @param xc_type - `type`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmERC20TokensRequest = (s_chain, xc_type) => Protobuf() // ...
    .s(s_chain) // string chain = 1
    .v(xc_type) // TokenType type = 2
    .o;
/**
 * Encodes a `ERC20TokensResponse` protobuf message: describes the asset and symbol for all ERC20 tokens requested for a chain
 * @param a_tokens - `tokens`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmERC20TokensResponse = (a_tokens) => Protobuf() // ...
    .B(a_tokens) // Token[] tokens = 1
    .o;
/**
 * Encodes a `TokenInfoRequest` protobuf message:
 * @param s_chain - `chain`:
 * @param s_asset - `asset`:
 * @param s_symbol - `symbol`:
 * @param sa_address - `address`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmTokenInfoRequest = (s_chain, s_asset, s_symbol, sa_address) => Protobuf() // ...
    .s(s_chain) // string chain = 1
    .s(s_asset) // string asset = 2
    .s(s_symbol) // string symbol = 3
    .s(sa_address) // string address = 4
    .o;
/**
 * Encodes a `TokenInfoResponse` protobuf message:
 * @param s_asset - `asset`:
 * @param g_details - `details`:
 * @param sa_address - `address`:
 * @param b_confirmed - `confirmed`:
 * @param b_is_external - `is_external`:
 * @param sb16_burner_code_hash - `burner_code_hash`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmTokenInfoResponse = (s_asset, atu8_details, sa_address, b_confirmed, b_is_external, sb16_burner_code_hash) => Protobuf() // ...
    .s(s_asset) // string asset = 1
    .b(atu8_details) // TokenDetails details = 2
    .s(sa_address) // string address = 3
    .v(b_confirmed) // boolean confirmed = 4
    .v(b_is_external) // boolean is_external = 5
    .s(sb16_burner_code_hash) // string burner_code_hash = 6
    .o;
/**
 * Encodes a `Proof` protobuf message:
 * @param a_addresses - `addresses`:
 * @param a_weights - `weights`:
 * @param s_threshold - `threshold`:
 * @param a_signatures - `signatures`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmProof = (a_addresses, a_weights, s_threshold, a_signatures) => Protobuf() // ...
    .S(a_addresses) // string[] addresses = 1
    .S(a_weights) // string[] weights = 2
    .s(s_threshold) // string threshold = 3
    .S(a_signatures) // string[] signatures = 4
    .o;
/**
 * Encodes a `ParamsRequest` protobuf message: represents a message that queries the params
 * @param s_chain - `chain`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmParamsRequest = (s_chain) => Protobuf() // ...
    .s(s_chain) // string chain = 1
    .o;
/**
 * Encodes a `ParamsResponse` protobuf message:
 * @param g_params - `params`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmParamsResponse = (atu8_params) => Protobuf() // ...
    .b(atu8_params) // Params params = 1
    .o;
/**
 * Encodes a `WeightedAddress` protobuf message:
 * @param sa_address - `address`:
 * @param s_weight - `weight`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmKeyAddressResponseWeightedAddress = (sa_address, s_weight) => Protobuf() // ...
    .s(sa_address) // string address = 1
    .s(s_weight) // string weight = 2
    .o;
/**
 * Encodes a `ParamsEntry` protobuf message:
 * @param s_key - `key`:
 * @param s_value - `value`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmCommandResponseParamsEntry = (s_key, s_value) => Protobuf() // ...
    .s(s_key) // string key = 1
    .s(s_value) // string value = 2
    .o;
/**
 * Encodes a `ParamsEntry` protobuf message:
 * @param s_key - `key`:
 * @param s_value - `value`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmQueryCommandResponseParamsEntry = (s_key, s_value) => Protobuf() // ...
    .s(s_key) // string key = 1
    .s(s_value) // string value = 2
    .o;
/**
 * Encodes a `Token` protobuf message:
 * @param s_asset - `asset`:
 * @param s_symbol - `symbol`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarEvmERC20TokensResponseToken = (s_asset, s_symbol) => Protobuf() // ...
    .s(s_asset) // string asset = 1
    .s(s_symbol) // string symbol = 2
    .o;
/**
 * Decodes a protobuf DepositQueryParams message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmDepositQueryParams}
 */
export const decodeAxelarEvmDepositQueryParams = (atu8_payload) => decode_protobuf(atu8_payload, [5, 5, 5]);
/**
 * Decodes a protobuf BatchedCommandsRequest message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmBatchedCommandsRequest}
 */
export const decodeAxelarEvmBatchedCommandsRequest = (atu8_payload) => decode_protobuf(atu8_payload, [5, 5]);
/**
 * Decodes a protobuf BatchedCommands message
 * @param atu8_payload - raw bytes to decode
 * @param RESERVED - a second argument is explicitly forbidden. make sure not to pass this function by reference to some callback argument
 * @returns a {@link DecodedAxelarEvmBatchedCommandsResponse}
 */
export const decodeAxelarEvmBatchedCommandsResponse = ((atu8_payload, [s_id, s_data, xc_status, si_key, , s_execute_data, si_prev_batched_commands, a_command_ids, a_proof] = decode_protobuf(atu8_payload, [5, 5, 1, 5, 0, 5, 5, 4, 1], [0, 0, 0, 0, 0, 0, 0, 0, decodeAxelarEvmProof])) => [s_id, s_data, xc_status, si_key, __UNDEFINED, s_execute_data, si_prev_batched_commands, a_command_ids, a_proof]);
/**
 * Decodes a protobuf KeyAddressRequest message
 * @param atu8_payload - raw bytes to decode
 * @param RESERVED - a second argument is explicitly forbidden. make sure not to pass this function by reference to some callback argument
 * @returns a {@link DecodedAxelarEvmKeyAddressRequest}
 */
export const decodeAxelarEvmKeyAddressRequest = ((atu8_payload, [s_chain, , , si_key] = decode_protobuf(atu8_payload, [5, 0, 0, 5])) => [s_chain, __UNDEFINED, __UNDEFINED, si_key]);
/**
 * Decodes a protobuf KeyAddress message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmKeyAddressResponse}
 */
export const decodeAxelarEvmKeyAddressResponse = (atu8_payload) => decode_protobuf(atu8_payload, [5, 0, 5], [0, decodeAxelarEvmKeyAddressResponseWeightedAddress]);
/**
 * Decodes a protobuf QueryTokenAddress message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmQueryTokenAddressResponse}
 */
export const decodeAxelarEvmQueryTokenAddressResponse = (atu8_payload) => decode_protobuf(atu8_payload, [5, 1]);
/**
 * Decodes a protobuf QueryDepositStateParams message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmQueryDepositStateParams}
 */
export const decodeAxelarEvmQueryDepositStateParams = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1]);
/**
 * Decodes a protobuf DepositStateRequest message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmDepositStateRequest}
 */
export const decodeAxelarEvmDepositStateRequest = (atu8_payload) => decode_protobuf(atu8_payload, [5, 1], [0, decodeAxelarEvmQueryDepositStateParams]);
/**
 * Decodes a protobuf DepositState message
 * @param atu8_payload - raw bytes to decode
 * @param RESERVED - a second argument is explicitly forbidden. make sure not to pass this function by reference to some callback argument
 * @returns a {@link DecodedAxelarEvmDepositStateResponse}
 */
export const decodeAxelarEvmDepositStateResponse = ((atu8_payload, [, xc_status] = decode_protobuf(atu8_payload, [0, 1])) => [__UNDEFINED, xc_status]);
/**
 * Decodes a protobuf EventRequest message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmEventRequest}
 */
export const decodeAxelarEvmEventRequest = (atu8_payload) => decode_protobuf(atu8_payload, [5, 5]);
/**
 * Decodes a protobuf Event message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmEventResponse}
 */
export const decodeAxelarEvmEventResponse = (atu8_payload) => decode_protobuf(atu8_payload, [1], [decodeAxelarEvmEvent]);
/**
 * Decodes a protobuf QueryBurnerAddress message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmQueryBurnerAddressResponse}
 */
export const decodeAxelarEvmQueryBurnerAddressResponse = (atu8_payload) => decode_protobuf(atu8_payload, [5]);
/**
 * Decodes a protobuf ChainsRequest message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmChainsRequest}
 */
export const decodeAxelarEvmChainsRequest = (atu8_payload) => decode_protobuf(atu8_payload, [1]);
/**
 * Decodes a protobuf Chains message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmChainsResponse}
 */
export const decodeAxelarEvmChainsResponse = (atu8_payload) => decode_protobuf(atu8_payload, [4]);
/**
 * Decodes a protobuf CommandRequest message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmCommandRequest}
 */
export const decodeAxelarEvmCommandRequest = (atu8_payload) => decode_protobuf(atu8_payload, [5, 5]);
/**
 * Decodes a protobuf Command message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmCommandResponse}
 */
export const decodeAxelarEvmCommandResponse = (atu8_payload) => decode_protobuf(atu8_payload, [5, 5, 0, 5, 1], [0, 0, decodeAxelarEvmCommandResponseParamsEntry]);
/**
 * Decodes a protobuf PendingCommandsRequest message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmPendingCommandsRequest}
 */
export const decodeAxelarEvmPendingCommandsRequest = (atu8_payload) => decode_protobuf(atu8_payload, [5]);
/**
 * Decodes a protobuf PendingCommands message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmPendingCommandsResponse}
 */
export const decodeAxelarEvmPendingCommandsResponse = (atu8_payload) => decode_protobuf(atu8_payload, [0], [decodeAxelarEvmQueryCommandResponse]);
/**
 * Decodes a protobuf QueryCommand message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmQueryCommandResponse}
 */
export const decodeAxelarEvmQueryCommandResponse = (atu8_payload) => decode_protobuf(atu8_payload, [5, 5, 0, 5, 1], [0, 0, decodeAxelarEvmQueryCommandResponseParamsEntry]);
/**
 * Decodes a protobuf BurnerInfoRequest message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmBurnerInfoRequest}
 */
export const decodeAxelarEvmBurnerInfoRequest = (atu8_payload) => decode_protobuf(atu8_payload, [1]);
/**
 * Decodes a protobuf BurnerInfo message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmBurnerInfoResponse}
 */
export const decodeAxelarEvmBurnerInfoResponse = (atu8_payload) => decode_protobuf(atu8_payload, [5, 1], [0, decodeAxelarEvmBurnerInfo]);
/**
 * Decodes a protobuf ConfirmationHeightRequest message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmConfirmationHeightRequest}
 */
export const decodeAxelarEvmConfirmationHeightRequest = (atu8_payload) => decode_protobuf(atu8_payload, [5]);
/**
 * Decodes a protobuf ConfirmationHeight message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmConfirmationHeightResponse}
 */
export const decodeAxelarEvmConfirmationHeightResponse = (atu8_payload) => decode_protobuf(atu8_payload, [3]);
/**
 * Decodes a protobuf GatewayAddressRequest message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmGatewayAddressRequest}
 */
export const decodeAxelarEvmGatewayAddressRequest = (atu8_payload) => decode_protobuf(atu8_payload, [5]);
/**
 * Decodes a protobuf GatewayAddress message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmGatewayAddressResponse}
 */
export const decodeAxelarEvmGatewayAddressResponse = (atu8_payload) => decode_protobuf(atu8_payload, [5]);
/**
 * Decodes a protobuf BytecodeRequest message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmBytecodeRequest}
 */
export const decodeAxelarEvmBytecodeRequest = (atu8_payload) => decode_protobuf(atu8_payload, [5, 5]);
/**
 * Decodes a protobuf Bytecode message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmBytecodeResponse}
 */
export const decodeAxelarEvmBytecodeResponse = (atu8_payload) => decode_protobuf(atu8_payload, [5]);
/**
 * Decodes a protobuf ERC20TokensRequest message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmERC20TokensRequest}
 */
export const decodeAxelarEvmERC20TokensRequest = (atu8_payload) => decode_protobuf(atu8_payload, [5, 1]);
/**
 * Decodes a protobuf ERC20Tokens message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmERC20TokensResponse}
 */
export const decodeAxelarEvmERC20TokensResponse = (atu8_payload) => decode_protobuf(atu8_payload, [0], [decodeAxelarEvmERC20TokensResponseToken]);
/**
 * Decodes a protobuf TokenInfoRequest message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmTokenInfoRequest}
 */
export const decodeAxelarEvmTokenInfoRequest = (atu8_payload) => decode_protobuf(atu8_payload, [5, 5, 5, 5]);
/**
 * Decodes a protobuf TokenInfo message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmTokenInfoResponse}
 */
export const decodeAxelarEvmTokenInfoResponse = (atu8_payload) => decode_protobuf(atu8_payload, [5, 1, 5, 1, 1, 5], [0, decodeAxelarEvmTokenDetails]);
/**
 * Decodes a protobuf Proof message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmProof}
 */
export const decodeAxelarEvmProof = (atu8_payload) => decode_protobuf(atu8_payload, [4, 4, 5, 4]);
/**
 * Decodes a protobuf ParamsRequest message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmParamsRequest}
 */
export const decodeAxelarEvmParamsRequest = (atu8_payload) => decode_protobuf(atu8_payload, [5]);
/**
 * Decodes a protobuf Params message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmParamsResponse}
 */
export const decodeAxelarEvmParamsResponse = (atu8_payload) => decode_protobuf(atu8_payload, [1], [decodeAxelarEvmParams]);
/**
 * Decodes a protobuf WeightedAddress message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmKeyAddressResponseWeightedAddress}
 */
export const decodeAxelarEvmKeyAddressResponseWeightedAddress = (atu8_payload) => decode_protobuf(atu8_payload, [5, 5]);
/**
 * Decodes a protobuf ParamsEntry message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmCommandResponseParamsEntry}
 */
export const decodeAxelarEvmCommandResponseParamsEntry = (atu8_payload) => decode_protobuf(atu8_payload, [5, 5]);
/**
 * Decodes a protobuf ParamsEntry message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmQueryCommandResponseParamsEntry}
 */
export const decodeAxelarEvmQueryCommandResponseParamsEntry = (atu8_payload) => decode_protobuf(atu8_payload, [5, 5]);
/**
 * Decodes a protobuf Token message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarEvmERC20TokensResponseToken}
 */
export const decodeAxelarEvmERC20TokensResponseToken = (atu8_payload) => decode_protobuf(atu8_payload, [5, 5]);
/**
 * Destructures the fields of a {@link AxelarEvmDepositQueryParams} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: address -
 *   - 1: asset -
 *   - 2: chain -
 */
export const destructAxelarEvmDepositQueryParams = (g_struct) => [g_struct.address, g_struct.asset, g_struct.chain];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_DEPOSIT_QUERY_PARAMS = '/axelar.evm.v1beta1.DepositQueryParams';
/**
 * Destructures the fields of a {@link AxelarEvmBatchedCommandsRequest} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: chain -
 *   - 1: id - defines an optional id for the commandsbatch. If not specified the latest will be returned
 */
export const destructAxelarEvmBatchedCommandsRequest = (g_struct) => [g_struct.chain, g_struct.id];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_BATCHED_COMMANDS_REQUEST = '/axelar.evm.v1beta1.BatchedCommandsRequest';
/**
 * Destructures the fields of a {@link AxelarEvmBatchedCommandsResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: id -
 *   - 1: data -
 *   - 2: status -
 *   - 3: key_id -
 *   - 5: execute_data -
 *   - 6: prev_batched_commands_id -
 *   - 7: command_ids -
 *   - 8: proof -
 */
export const destructAxelarEvmBatchedCommandsResponse = (g_struct) => [g_struct.id, g_struct.data, g_struct.status, g_struct.key_id, __UNDEFINED, g_struct.execute_data, g_struct.prev_batched_commands_id, g_struct.command_ids, g_struct.proof];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_BATCHED_COMMANDS_RESPONSE = '/axelar.evm.v1beta1.BatchedCommandsResponse';
/**
 * Destructures the fields of a {@link AxelarEvmProof} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: addresses -
 *   - 1: weights -
 *   - 2: threshold -
 *   - 3: signatures -
 */
export const destructAxelarEvmProof = (g_struct) => [g_struct.addresses, g_struct.weights, g_struct.threshold, g_struct.signatures];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_PROOF = '/axelar.evm.v1beta1.Proof';
/**
 * Destructures the fields of a {@link AxelarEvmKeyAddressRequest} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: chain -
 *   - 3: key_id -
 */
export const destructAxelarEvmKeyAddressRequest = (g_struct) => [g_struct.chain, __UNDEFINED, __UNDEFINED, g_struct.key_id];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_KEY_ADDRESS_REQUEST = '/axelar.evm.v1beta1.KeyAddressRequest';
/**
 * Destructures the fields of a {@link AxelarEvmKeyAddressResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: key_id -
 *   - 1: addresses -
 *   - 2: threshold -
 */
export const destructAxelarEvmKeyAddressResponse = (g_struct) => [g_struct.key_id, g_struct.addresses, g_struct.threshold];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_KEY_ADDRESS_RESPONSE = '/axelar.evm.v1beta1.KeyAddressResponse';
/**
 * Destructures the fields of a {@link AxelarEvmKeyAddressResponseWeightedAddress} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: address -
 *   - 1: weight -
 */
export const destructAxelarEvmKeyAddressResponseWeightedAddress = (g_struct) => [g_struct.address, g_struct.weight];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_KEY_ADDRESS_RESPONSE_WEIGHTED_ADDRESS = '/axelar.evm.v1beta1.KeyAddressResponse.WeightedAddress';
/**
 * Destructures the fields of a {@link AxelarEvmQueryTokenAddressResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: address -
 *   - 1: confirmed -
 */
export const destructAxelarEvmQueryTokenAddressResponse = (g_struct) => [g_struct.address, g_struct.confirmed];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_QUERY_TOKEN_ADDRESS_RESPONSE = '/axelar.evm.v1beta1.QueryTokenAddressResponse';
/**
 * Destructures the fields of a {@link AxelarEvmQueryDepositStateParams} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: tx_id -
 *   - 1: burner_address -
 */
export const destructAxelarEvmQueryDepositStateParams = (g_struct) => [safe_base64_to_bytes(g_struct.tx_id), safe_base64_to_bytes(g_struct.burner_address)];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_QUERY_DEPOSIT_STATE_PARAMS = '/axelar.evm.v1beta1.QueryDepositStateParams';
/**
 * Destructures the fields of a {@link AxelarEvmDepositStateRequest} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: chain -
 *   - 1: params -
 */
export const destructAxelarEvmDepositStateRequest = (g_struct) => [g_struct.chain, g_struct.params];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_DEPOSIT_STATE_REQUEST = '/axelar.evm.v1beta1.DepositStateRequest';
/**
 * Destructures the fields of a {@link AxelarEvmDepositStateResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 1: status -
 */
export const destructAxelarEvmDepositStateResponse = (g_struct) => [__UNDEFINED, g_struct.status];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_DEPOSIT_STATE_RESPONSE = '/axelar.evm.v1beta1.DepositStateResponse';
/**
 * Destructures the fields of a {@link AxelarEvmEventRequest} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: chain -
 *   - 1: event_id -
 */
export const destructAxelarEvmEventRequest = (g_struct) => [g_struct.chain, g_struct.event_id];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_EVENT_REQUEST = '/axelar.evm.v1beta1.EventRequest';
/**
 * Destructures the fields of a {@link AxelarEvmEventResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: event -
 */
export const destructAxelarEvmEventResponse = (g_struct) => [g_struct.event];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_EVENT_RESPONSE = '/axelar.evm.v1beta1.EventResponse';
/**
 * Destructures the fields of a {@link AxelarEvmQueryBurnerAddressResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: address -
 */
export const destructAxelarEvmQueryBurnerAddressResponse = (g_struct) => [g_struct.address];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_QUERY_BURNER_ADDRESS_RESPONSE = '/axelar.evm.v1beta1.QueryBurnerAddressResponse';
/**
 * Destructures the fields of a {@link AxelarEvmChainsRequest} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: status -
 */
export const destructAxelarEvmChainsRequest = (g_struct) => [g_struct.status];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_CHAINS_REQUEST = '/axelar.evm.v1beta1.ChainsRequest';
/**
 * Destructures the fields of a {@link AxelarEvmChainsResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: chains -
 */
export const destructAxelarEvmChainsResponse = (g_struct) => [g_struct.chains];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_CHAINS_RESPONSE = '/axelar.evm.v1beta1.ChainsResponse';
/**
 * Destructures the fields of a {@link AxelarEvmCommandRequest} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: chain -
 *   - 1: id -
 */
export const destructAxelarEvmCommandRequest = (g_struct) => [g_struct.chain, g_struct.id];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_COMMAND_REQUEST = '/axelar.evm.v1beta1.CommandRequest';
/**
 * Destructures the fields of a {@link AxelarEvmCommandResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: id -
 *   - 1: type -
 *   - 2: params -
 *   - 3: key_id -
 *   - 4: max_gas_cost -
 */
export const destructAxelarEvmCommandResponse = (g_struct) => [g_struct.id, g_struct.type, g_struct.params, g_struct.key_id, g_struct.max_gas_cost];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_COMMAND_RESPONSE = '/axelar.evm.v1beta1.CommandResponse';
/**
 * Destructures the fields of a {@link AxelarEvmCommandResponseParamsEntry} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: key -
 *   - 1: value -
 */
export const destructAxelarEvmCommandResponseParamsEntry = (g_struct) => [g_struct.key, g_struct.value];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_COMMAND_RESPONSE_PARAMS_ENTRY = '/axelar.evm.v1beta1.CommandResponse.ParamsEntry';
/**
 * Destructures the fields of a {@link AxelarEvmPendingCommandsRequest} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: chain -
 */
export const destructAxelarEvmPendingCommandsRequest = (g_struct) => [g_struct.chain];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_PENDING_COMMANDS_REQUEST = '/axelar.evm.v1beta1.PendingCommandsRequest';
/**
 * Destructures the fields of a {@link AxelarEvmPendingCommandsResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: commands -
 */
export const destructAxelarEvmPendingCommandsResponse = (g_struct) => [g_struct.commands];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_PENDING_COMMANDS_RESPONSE = '/axelar.evm.v1beta1.PendingCommandsResponse';
/**
 * Destructures the fields of a {@link AxelarEvmQueryCommandResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: id -
 *   - 1: type -
 *   - 2: params -
 *   - 3: key_id -
 *   - 4: max_gas_cost -
 */
export const destructAxelarEvmQueryCommandResponse = (g_struct) => [g_struct.id, g_struct.type, g_struct.params, g_struct.key_id, g_struct.max_gas_cost];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_QUERY_COMMAND_RESPONSE = '/axelar.evm.v1beta1.QueryCommandResponse';
/**
 * Destructures the fields of a {@link AxelarEvmQueryCommandResponseParamsEntry} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: key -
 *   - 1: value -
 */
export const destructAxelarEvmQueryCommandResponseParamsEntry = (g_struct) => [g_struct.key, g_struct.value];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_QUERY_COMMAND_RESPONSE_PARAMS_ENTRY = '/axelar.evm.v1beta1.QueryCommandResponse.ParamsEntry';
/**
 * Destructures the fields of a {@link AxelarEvmBurnerInfoRequest} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: address -
 */
export const destructAxelarEvmBurnerInfoRequest = (g_struct) => [safe_base64_to_bytes(g_struct.address)];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_BURNER_INFO_REQUEST = '/axelar.evm.v1beta1.BurnerInfoRequest';
/**
 * Destructures the fields of a {@link AxelarEvmBurnerInfoResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: chain -
 *   - 1: burner_info -
 */
export const destructAxelarEvmBurnerInfoResponse = (g_struct) => [g_struct.chain, g_struct.burner_info];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_BURNER_INFO_RESPONSE = '/axelar.evm.v1beta1.BurnerInfoResponse';
/**
 * Destructures the fields of a {@link AxelarEvmConfirmationHeightRequest} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: chain -
 */
export const destructAxelarEvmConfirmationHeightRequest = (g_struct) => [g_struct.chain];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_CONFIRMATION_HEIGHT_REQUEST = '/axelar.evm.v1beta1.ConfirmationHeightRequest';
/**
 * Destructures the fields of a {@link AxelarEvmConfirmationHeightResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: height -
 */
export const destructAxelarEvmConfirmationHeightResponse = (g_struct) => [g_struct.height];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_CONFIRMATION_HEIGHT_RESPONSE = '/axelar.evm.v1beta1.ConfirmationHeightResponse';
/**
 * Destructures the fields of a {@link AxelarEvmGatewayAddressRequest} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: chain -
 */
export const destructAxelarEvmGatewayAddressRequest = (g_struct) => [g_struct.chain];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_GATEWAY_ADDRESS_REQUEST = '/axelar.evm.v1beta1.GatewayAddressRequest';
/**
 * Destructures the fields of a {@link AxelarEvmGatewayAddressResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: address -
 */
export const destructAxelarEvmGatewayAddressResponse = (g_struct) => [g_struct.address];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_GATEWAY_ADDRESS_RESPONSE = '/axelar.evm.v1beta1.GatewayAddressResponse';
/**
 * Destructures the fields of a {@link AxelarEvmBytecodeRequest} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: chain -
 *   - 1: contract -
 */
export const destructAxelarEvmBytecodeRequest = (g_struct) => [g_struct.chain, g_struct.contract];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_BYTECODE_REQUEST = '/axelar.evm.v1beta1.BytecodeRequest';
/**
 * Destructures the fields of a {@link AxelarEvmBytecodeResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: bytecode -
 */
export const destructAxelarEvmBytecodeResponse = (g_struct) => [g_struct.bytecode];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_BYTECODE_RESPONSE = '/axelar.evm.v1beta1.BytecodeResponse';
/**
 * Destructures the fields of a {@link AxelarEvmERC20TokensRequest} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: chain -
 *   - 1: type -
 */
export const destructAxelarEvmERC20TokensRequest = (g_struct) => [g_struct.chain, g_struct.type];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_E_R_C20_TOKENS_REQUEST = '/axelar.evm.v1beta1.ERC20TokensRequest';
/**
 * Destructures the fields of a {@link AxelarEvmERC20TokensResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: tokens -
 */
export const destructAxelarEvmERC20TokensResponse = (g_struct) => [g_struct.tokens];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_E_R_C20_TOKENS_RESPONSE = '/axelar.evm.v1beta1.ERC20TokensResponse';
/**
 * Destructures the fields of a {@link AxelarEvmERC20TokensResponseToken} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: asset -
 *   - 1: symbol -
 */
export const destructAxelarEvmERC20TokensResponseToken = (g_struct) => [g_struct.asset, g_struct.symbol];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_E_R_C20_TOKENS_RESPONSE_TOKEN = '/axelar.evm.v1beta1.ERC20TokensResponse.Token';
/**
 * Destructures the fields of a {@link AxelarEvmTokenInfoRequest} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: chain -
 *   - 1: asset -
 *   - 2: symbol -
 *   - 3: address -
 */
export const destructAxelarEvmTokenInfoRequest = (g_struct) => [g_struct.chain, g_struct.asset, g_struct.symbol, g_struct.address];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_TOKEN_INFO_REQUEST = '/axelar.evm.v1beta1.TokenInfoRequest';
/**
 * Destructures the fields of a {@link AxelarEvmTokenInfoResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: asset -
 *   - 1: details -
 *   - 2: address -
 *   - 3: confirmed -
 *   - 4: is_external -
 *   - 5: burner_code_hash -
 */
export const destructAxelarEvmTokenInfoResponse = (g_struct) => [g_struct.asset, g_struct.details, g_struct.address, g_struct.confirmed, g_struct.is_external, g_struct.burner_code_hash];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_TOKEN_INFO_RESPONSE = '/axelar.evm.v1beta1.TokenInfoResponse';
/**
 * Destructures the fields of a {@link AxelarEvmParamsRequest} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: chain -
 */
export const destructAxelarEvmParamsRequest = (g_struct) => [g_struct.chain];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_PARAMS_REQUEST = '/axelar.evm.v1beta1.ParamsRequest';
/**
 * Destructures the fields of a {@link AxelarEvmParamsResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: params -
 */
export const destructAxelarEvmParamsResponse = (g_struct) => [g_struct.params];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_EVM_PARAMS_RESPONSE = '/axelar.evm.v1beta1.ParamsResponse';
/**
 * Protobuf enum value for `axelar.evm.v1beta1.ChainStatus`.
 *
 * **CHAIN_STATUS_UNSPECIFIED** -
 *
 * Belongs to enum type {@link ProtoEnumAxelarEvmChainStatus}
 */
export const XC_PROTO_AXELAR_EVM_CHAIN_STATUS_UNSPECIFIED = 0;
/**
 * JSON enum value for `axelar.evm.v1beta1.ChainStatus`.
 *
 * **CHAIN_STATUS_UNSPECIFIED** -
 *
 * Belongs to enum type {@link JsonEnumAxelarEvmChainStatus}
 */
export const SI_JSON_AXELAR_EVM_CHAIN_STATUS_UNSPECIFIED = 'StatusUnspecified';
/**
 * Protobuf enum value for `axelar.evm.v1beta1.ChainStatus`.
 *
 * **CHAIN_STATUS_ACTIVATED** -
 *
 * Belongs to enum type {@link ProtoEnumAxelarEvmChainStatus}
 */
export const XC_PROTO_AXELAR_EVM_CHAIN_STATUS_ACTIVATED = 1;
/**
 * JSON enum value for `axelar.evm.v1beta1.ChainStatus`.
 *
 * **CHAIN_STATUS_ACTIVATED** -
 *
 * Belongs to enum type {@link JsonEnumAxelarEvmChainStatus}
 */
export const SI_JSON_AXELAR_EVM_CHAIN_STATUS_ACTIVATED = 'Activated';
/**
 * Protobuf enum value for `axelar.evm.v1beta1.ChainStatus`.
 *
 * **CHAIN_STATUS_DEACTIVATED** -
 *
 * Belongs to enum type {@link ProtoEnumAxelarEvmChainStatus}
 */
export const XC_PROTO_AXELAR_EVM_CHAIN_STATUS_DEACTIVATED = 2;
/**
 * JSON enum value for `axelar.evm.v1beta1.ChainStatus`.
 *
 * **CHAIN_STATUS_DEACTIVATED** -
 *
 * Belongs to enum type {@link JsonEnumAxelarEvmChainStatus}
 */
export const SI_JSON_AXELAR_EVM_CHAIN_STATUS_DEACTIVATED = 'Deactivated';
/**
 * Maps a protobuf enum int value for `axelar.evm.v1beta1.ChainStatus` to is JSON equivalent enum string value
 */
export const ProtoToJsonEnumAxelarEvmChainStatus = {
    [XC_PROTO_AXELAR_EVM_CHAIN_STATUS_UNSPECIFIED]: SI_JSON_AXELAR_EVM_CHAIN_STATUS_UNSPECIFIED,
    [XC_PROTO_AXELAR_EVM_CHAIN_STATUS_ACTIVATED]: SI_JSON_AXELAR_EVM_CHAIN_STATUS_ACTIVATED,
    [XC_PROTO_AXELAR_EVM_CHAIN_STATUS_DEACTIVATED]: SI_JSON_AXELAR_EVM_CHAIN_STATUS_DEACTIVATED,
};
/**
 * Maps a JSON enum string value for `axelar.evm.v1beta1.ChainStatus` to is protobuf equivalent enum int value
 */
export const JsonToProtoEnumAxelarEvmChainStatus = {
    [SI_JSON_AXELAR_EVM_CHAIN_STATUS_UNSPECIFIED]: XC_PROTO_AXELAR_EVM_CHAIN_STATUS_UNSPECIFIED,
    [SI_JSON_AXELAR_EVM_CHAIN_STATUS_ACTIVATED]: XC_PROTO_AXELAR_EVM_CHAIN_STATUS_ACTIVATED,
    [SI_JSON_AXELAR_EVM_CHAIN_STATUS_DEACTIVATED]: XC_PROTO_AXELAR_EVM_CHAIN_STATUS_DEACTIVATED,
};
/**
 * Protobuf enum value for `axelar.evm.v1beta1.TokenType`.
 *
 * **TOKEN_TYPE_UNSPECIFIED** -
 *
 * Belongs to enum type {@link ProtoEnumAxelarEvmTokenType}
 */
export const XC_PROTO_AXELAR_EVM_TOKEN_TYPE_UNSPECIFIED = 0;
/**
 * JSON enum value for `axelar.evm.v1beta1.TokenType`.
 *
 * **TOKEN_TYPE_UNSPECIFIED** -
 *
 * Belongs to enum type {@link JsonEnumAxelarEvmTokenType}
 */
export const SI_JSON_AXELAR_EVM_TOKEN_TYPE_UNSPECIFIED = 'Unspecified';
/**
 * Protobuf enum value for `axelar.evm.v1beta1.TokenType`.
 *
 * **TOKEN_TYPE_INTERNAL** -
 *
 * Belongs to enum type {@link ProtoEnumAxelarEvmTokenType}
 */
export const XC_PROTO_AXELAR_EVM_TOKEN_TYPE_INTERNAL = 1;
/**
 * JSON enum value for `axelar.evm.v1beta1.TokenType`.
 *
 * **TOKEN_TYPE_INTERNAL** -
 *
 * Belongs to enum type {@link JsonEnumAxelarEvmTokenType}
 */
export const SI_JSON_AXELAR_EVM_TOKEN_TYPE_INTERNAL = 'Internal';
/**
 * Protobuf enum value for `axelar.evm.v1beta1.TokenType`.
 *
 * **TOKEN_TYPE_EXTERNAL** -
 *
 * Belongs to enum type {@link ProtoEnumAxelarEvmTokenType}
 */
export const XC_PROTO_AXELAR_EVM_TOKEN_TYPE_EXTERNAL = 2;
/**
 * JSON enum value for `axelar.evm.v1beta1.TokenType`.
 *
 * **TOKEN_TYPE_EXTERNAL** -
 *
 * Belongs to enum type {@link JsonEnumAxelarEvmTokenType}
 */
export const SI_JSON_AXELAR_EVM_TOKEN_TYPE_EXTERNAL = 'External';
/**
 * Maps a protobuf enum int value for `axelar.evm.v1beta1.TokenType` to is JSON equivalent enum string value
 */
export const ProtoToJsonEnumAxelarEvmTokenType = {
    [XC_PROTO_AXELAR_EVM_TOKEN_TYPE_UNSPECIFIED]: SI_JSON_AXELAR_EVM_TOKEN_TYPE_UNSPECIFIED,
    [XC_PROTO_AXELAR_EVM_TOKEN_TYPE_INTERNAL]: SI_JSON_AXELAR_EVM_TOKEN_TYPE_INTERNAL,
    [XC_PROTO_AXELAR_EVM_TOKEN_TYPE_EXTERNAL]: SI_JSON_AXELAR_EVM_TOKEN_TYPE_EXTERNAL,
};
/**
 * Maps a JSON enum string value for `axelar.evm.v1beta1.TokenType` to is protobuf equivalent enum int value
 */
export const JsonToProtoEnumAxelarEvmTokenType = {
    [SI_JSON_AXELAR_EVM_TOKEN_TYPE_UNSPECIFIED]: XC_PROTO_AXELAR_EVM_TOKEN_TYPE_UNSPECIFIED,
    [SI_JSON_AXELAR_EVM_TOKEN_TYPE_INTERNAL]: XC_PROTO_AXELAR_EVM_TOKEN_TYPE_INTERNAL,
    [SI_JSON_AXELAR_EVM_TOKEN_TYPE_EXTERNAL]: XC_PROTO_AXELAR_EVM_TOKEN_TYPE_EXTERNAL,
};
//# sourceMappingURL=query.js.map