import { decode_protobuf } from '../../../../api/protobuf-reader.js';
import { Protobuf } from '../../../../api/protobuf-writer.js';
/**
 * Encodes a `Voted` protobuf message:
 * @param s_module - `module`:
 * @param s_action - `action`:
 * @param s_poll - `poll`:
 * @param sa_voter - `voter`:
 * @param s_state - `state`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeAxelarVoteVoted = (s_module, s_action, s_poll, sa_voter, s_state) => Protobuf() // ...
    .s(s_module) // string module = 1
    .s(s_action) // string action = 2
    .s(s_poll) // string poll = 3
    .s(sa_voter) // string voter = 4
    .s(s_state) // string state = 5
    .o;
/**
 * Decodes a protobuf Voted message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedAxelarVoteVoted}
 */
export const decodeAxelarVoteVoted = (atu8_payload) => decode_protobuf(atu8_payload, [5, 5, 5, 5, 5]);
/**
 * Destructures the fields of a {@link AxelarVoteVoted} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: module -
 *   - 1: action -
 *   - 2: poll -
 *   - 3: voter -
 *   - 4: state -
 */
export const destructAxelarVoteVoted = (g_struct) => [g_struct.module, g_struct.action, g_struct.poll, g_struct.voter, g_struct.state];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_AXELAR_VOTE_VOTED = '/axelar.vote.v1beta1.Voted';
//# sourceMappingURL=events.js.map