import type { Encoded, Opt } from '../../../../api/types.js';
export type EncodedCosmosAppModuleDescriptor = Encoded<'/cosmos.app.v1alpha1.ModuleDescriptor'>;
export type EncodedCosmosAppPackageReference = Encoded<'/cosmos.app.v1alpha1.PackageReference'>;
export type EncodedCosmosAppMigrateFromInfo = Encoded<'/cosmos.app.v1alpha1.MigrateFromInfo'>;
/**
 * Encodes a `ModuleDescriptor` protobuf message: describes an app module.
 * @param s_go_import - `go_import`: names the package that should be imported by an app to load the module in the runtime module registry. It is required to make debugging of configuration errors easier for users.
 * @param a_use_packages - `use_package`: refers to a protobuf package that this module uses and exposes to the world. In an app, only one module should "use" or own a single protobuf package. It is assumed that the module uses all of the .proto files in a single package.
 * @param a_can_migrate_froms - `can_migrate_from`: defines which module versions this module can migrate state from. The framework will check that one module version is able to migrate from a previous module version before attempting to update its config. It is assumed that modules can transitively migrate from earlier versions. For instance if v3 declares it can migrate from v2, and v2 declares it can migrate from v1, the framework knows how to migrate from v1 to v3, assuming all 3 module versions are registered at runtime.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosAppModuleDescriptor: (s_go_import?: Opt<string>, a_use_packages?: Opt<Encoded<'/cosmos.app.v1alpha1.PackageReference'>[]>, a_can_migrate_froms?: Opt<Encoded<'/cosmos.app.v1alpha1.MigrateFromInfo'>[]>) => EncodedCosmosAppModuleDescriptor;
/**
 * Encodes a `PackageReference` protobuf message: a reference to a protobuf package used by a module.
 * @param s_name - `name`: the fully-qualified name of the package.
 * @param n_revision - `revision`: the optional revision of the package that is being used. Protobuf packages used in Cosmos should generally have a major version as the last part of the package name, ex. foo.bar.baz.v1. The revision of a package can be thought of as the minor version of a package which has additional backwards compatible definitions that weren't present in a previous version. A package should indicate its revision with a source code comment above the package declaration in one of its files containing the text "Revision N" where N is an integer revision. All packages start at revision 0 the first time they are released in a module. When a new version of a module is released and items are added to existing .proto files, these definitions should contain comments of the form "Since: Revision N" where N is an integer revision. When the module runtime starts up, it will check the pinned proto image and panic if there are runtime protobuf definitions that are not in the pinned descriptor which do not have a "Since Revision N" comment or have a "Since Revision N" comment where N is <= to the revision specified here. This indicates that the protobuf files have been updated, but the pinned file descriptor hasn't. If there are items in the pinned file descriptor with a revision greater than the value indicated here, this will also cause a panic as it may mean that the pinned descriptor for a legacy module has been improperly updated or that there is some other versioning discrepancy. Runtime protobuf definitions will also be checked for compatibility with pinned file descriptors to make sure there are no incompatible changes. This behavior ensures that: * pinned proto images are up-to-date * protobuf files are carefully annotated with revision comments which are important good client UX * protobuf files are changed in backwards and forwards compatible ways
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosAppPackageReference: (s_name?: Opt<string>, n_revision?: Opt<number>) => EncodedCosmosAppPackageReference;
/**
 * Encodes a `MigrateFromInfo` protobuf message: information on a module version that a newer module can migrate from.
 * @param s_module - `module`: the fully-qualified protobuf name of the module config object for the previous module version, ex: "cosmos.group.module.v1.Module".
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosAppMigrateFromInfo: (s_module?: Opt<string>) => EncodedCosmosAppMigrateFromInfo;
/**
 * A decoded protobuf ModuleDescriptor message
 *
 * Tuple where:
 *   - 0: go_import - names the package that should be imported by an app to load the module in the runtime module registry. It is required to make debugging of configuration errors easier for users.
 *   - 1: use_package - refers to a protobuf package that this module uses and exposes to the world. In an app, only one module should "use" or own a single protobuf package. It is assumed that the module uses all of the .proto files in a single package.
 *   - 2: can_migrate_from - defines which module versions this module can migrate state from. The framework will check that one module version is able to migrate from a previous module version before attempting to update its config. It is assumed that modules can transitively migrate from earlier versions. For instance if v3 declares it can migrate from v2, and v2 declares it can migrate from v1, the framework knows how to migrate from v1 to v3, assuming all 3 module versions are registered at runtime.
 */
export type DecodedCosmosAppModuleDescriptor = [
    s_go_import?: string,
    a_use_package?: DecodedCosmosAppPackageReference[],
    a_can_migrate_from?: DecodedCosmosAppMigrateFromInfo[]
];
/**
 * Decodes a protobuf ModuleDescriptor message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosAppModuleDescriptor}
 */
export declare const decodeCosmosAppModuleDescriptor: (atu8_payload: Uint8Array) => DecodedCosmosAppModuleDescriptor;
/**
 * A decoded protobuf PackageReference message
 *
 * Tuple where:
 *   - 0: name - the fully-qualified name of the package.
 *   - 1: revision - the optional revision of the package that is being used. Protobuf packages used in Cosmos should generally have a major version as the last part of the package name, ex. foo.bar.baz.v1. The revision of a package can be thought of as the minor version of a package which has additional backwards compatible definitions that weren't present in a previous version. A package should indicate its revision with a source code comment above the package declaration in one of its files containing the text "Revision N" where N is an integer revision. All packages start at revision 0 the first time they are released in a module. When a new version of a module is released and items are added to existing .proto files, these definitions should contain comments of the form "Since: Revision N" where N is an integer revision. When the module runtime starts up, it will check the pinned proto image and panic if there are runtime protobuf definitions that are not in the pinned descriptor which do not have a "Since Revision N" comment or have a "Since Revision N" comment where N is <= to the revision specified here. This indicates that the protobuf files have been updated, but the pinned file descriptor hasn't. If there are items in the pinned file descriptor with a revision greater than the value indicated here, this will also cause a panic as it may mean that the pinned descriptor for a legacy module has been improperly updated or that there is some other versioning discrepancy. Runtime protobuf definitions will also be checked for compatibility with pinned file descriptors to make sure there are no incompatible changes. This behavior ensures that: * pinned proto images are up-to-date * protobuf files are carefully annotated with revision comments which are important good client UX * protobuf files are changed in backwards and forwards compatible ways
 */
export type DecodedCosmosAppPackageReference = [
    s_name?: string,
    n_revision?: number
];
/**
 * Decodes a protobuf PackageReference message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosAppPackageReference}
 */
export declare const decodeCosmosAppPackageReference: (atu8_payload: Uint8Array) => DecodedCosmosAppPackageReference;
/**
 * A decoded protobuf MigrateFromInfo message
 *
 * Alias for: module - the fully-qualified protobuf name of the module config object for the previous module version, ex: "cosmos.group.module.v1.Module".
 */
export type DecodedCosmosAppMigrateFromInfo = [
    s_module?: string
];
/**
 * Decodes a protobuf MigrateFromInfo message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosAppMigrateFromInfo}
 */
export declare const decodeCosmosAppMigrateFromInfo: (atu8_payload: Uint8Array) => DecodedCosmosAppMigrateFromInfo;
/**
 * Destructures the fields of a {@link CosmosAppModuleDescriptor} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: go_import - names the package that should be imported by an app to load the module in the runtime module registry. It is required to make debugging of configuration errors easier for users.
 *   - 1: use_package - refers to a protobuf package that this module uses and exposes to the world. In an app, only one module should "use" or own a single protobuf package. It is assumed that the module uses all of the .proto files in a single package.
 *   - 2: can_migrate_from - defines which module versions this module can migrate state from. The framework will check that one module version is able to migrate from a previous module version before attempting to update its config. It is assumed that modules can transitively migrate from earlier versions. For instance if v3 declares it can migrate from v2, and v2 declares it can migrate from v1, the framework knows how to migrate from v1 to v3, assuming all 3 module versions are registered at runtime.
 */
export declare const destructCosmosAppModuleDescriptor: (g_struct: CosmosAppModuleDescriptor) => [go_import?: string, use_package?: CosmosAppPackageReference[], can_migrate_from?: CosmosAppMigrateFromInfo[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_APP_MODULE_DESCRIPTOR = "/cosmos.app.v1alpha1.ModuleDescriptor";
/**
 * JSON serialization of `cosmos.app.v1alpha1.ModuleDescriptor` - describes an app module.
 */
export type CosmosAppModuleDescriptor = {
    go_import?: string | undefined;
    use_package?: CosmosAppPackageReference[] | undefined;
    can_migrate_from?: CosmosAppMigrateFromInfo[] | undefined;
};
/**
 * Destructures the fields of a {@link CosmosAppPackageReference} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: name - the fully-qualified name of the package.
 *   - 1: revision - the optional revision of the package that is being used. Protobuf packages used in Cosmos should generally have a major version as the last part of the package name, ex. foo.bar.baz.v1. The revision of a package can be thought of as the minor version of a package which has additional backwards compatible definitions that weren't present in a previous version. A package should indicate its revision with a source code comment above the package declaration in one of its files containing the text "Revision N" where N is an integer revision. All packages start at revision 0 the first time they are released in a module. When a new version of a module is released and items are added to existing .proto files, these definitions should contain comments of the form "Since: Revision N" where N is an integer revision. When the module runtime starts up, it will check the pinned proto image and panic if there are runtime protobuf definitions that are not in the pinned descriptor which do not have a "Since Revision N" comment or have a "Since Revision N" comment where N is <= to the revision specified here. This indicates that the protobuf files have been updated, but the pinned file descriptor hasn't. If there are items in the pinned file descriptor with a revision greater than the value indicated here, this will also cause a panic as it may mean that the pinned descriptor for a legacy module has been improperly updated or that there is some other versioning discrepancy. Runtime protobuf definitions will also be checked for compatibility with pinned file descriptors to make sure there are no incompatible changes. This behavior ensures that: * pinned proto images are up-to-date * protobuf files are carefully annotated with revision comments which are important good client UX * protobuf files are changed in backwards and forwards compatible ways
 */
export declare const destructCosmosAppPackageReference: (g_struct: CosmosAppPackageReference) => [name?: string, revision?: number];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_APP_PACKAGE_REFERENCE = "/cosmos.app.v1alpha1.PackageReference";
/**
 * JSON serialization of `cosmos.app.v1alpha1.PackageReference` - a reference to a protobuf package used by a module.
 */
export type CosmosAppPackageReference = {
    name?: string | undefined;
    revision?: number | undefined;
};
/**
 * Destructures the fields of a {@link CosmosAppMigrateFromInfo} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: module - the fully-qualified protobuf name of the module config object for the previous module version, ex: "cosmos.group.module.v1.Module".
 */
export declare const destructCosmosAppMigrateFromInfo: (g_struct: CosmosAppMigrateFromInfo) => [module?: string];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_APP_MIGRATE_FROM_INFO = "/cosmos.app.v1alpha1.MigrateFromInfo";
/**
 * JSON serialization of `cosmos.app.v1alpha1.MigrateFromInfo` - information on a module version that a newer module can migrate from.
 */
export type CosmosAppMigrateFromInfo = {
    module?: string | undefined;
};
