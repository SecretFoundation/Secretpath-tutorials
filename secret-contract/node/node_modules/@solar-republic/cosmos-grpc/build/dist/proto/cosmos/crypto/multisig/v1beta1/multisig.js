import { decode_protobuf } from '../../../../../api/protobuf-reader.js';
import { Protobuf, map } from '../../../../../api/protobuf-writer.js';
import { safe_base64_to_bytes } from '../../../../../api/util.js';
/**
 * Encodes a `MultiSignature` protobuf message: wraps the signatures from a multisig.LegacyAminoPubKey. See cosmos.tx.v1betata1.ModeInfo.Multi for how to specify which signers signed and with which modes.
 * @param a_signatures - `signatures`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosCryptoMultisigMultiSignature = (a_signatures) => Protobuf() // ...
    .B(a_signatures) // bytes[] signatures = 1
    .o;
/**
 * Encodes a `CompactBitArray` protobuf message: an implementation of a space efficient bit array. This is used to ensure that the encoded data takes up a minimal amount of space after proto encoding. This is not thread safe, and is not intended for concurrent usage.
 * @param n_extra_bits_stored - `extra_bits_stored`:
 * @param atu8_elems - `elems`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosCryptoMultisigCompactBitArray = (n_extra_bits_stored, atu8_elems) => Protobuf() // ...
    .v(n_extra_bits_stored) // uint32 extra_bits_stored = 1
    .b(atu8_elems) // bytes elems = 2
    .o;
/**
 * Decodes a protobuf MultiSignature message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosCryptoMultisigMultiSignature}
 */
export const decodeCosmosCryptoMultisigMultiSignature = (atu8_payload) => decode_protobuf(atu8_payload, [0]);
/**
 * Decodes a protobuf CompactBitArray message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosCryptoMultisigCompactBitArray}
 */
export const decodeCosmosCryptoMultisigCompactBitArray = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1]);
/**
 * Destructures the fields of a {@link CosmosCryptoMultisigMultiSignature} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: signatures -
 */
export const destructCosmosCryptoMultisigMultiSignature = (g_struct) => [map(g_struct.signatures, safe_base64_to_bytes)];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_CRYPTO_MULTISIG_MULTI_SIGNATURE = '/cosmos.crypto.multisig.v1beta1.MultiSignature';
/**
 * Destructures the fields of a {@link CosmosCryptoMultisigCompactBitArray} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: extra_bits_stored -
 *   - 1: elems -
 */
export const destructCosmosCryptoMultisigCompactBitArray = (g_struct) => [g_struct.extra_bits_stored, safe_base64_to_bytes(g_struct.elems)];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_CRYPTO_MULTISIG_COMPACT_BIT_ARRAY = '/cosmos.crypto.multisig.v1beta1.CompactBitArray';
//# sourceMappingURL=multisig.js.map