import { decode_protobuf } from '../../../../api/protobuf-reader.js';
import { Protobuf } from '../../../../api/protobuf-writer.js';
import { safe_base64_to_bytes } from '../../../../api/util.js';
/**
 * Encodes a `ExistenceProof` protobuf message: * ExistenceProof takes a key and a value and a set of steps to perform on it. The result of peforming all these steps will provide a "root hash", which can be compared to the value in a header. Since it is computationally infeasible to produce a hash collission for any of the used cryptographic hash functions, if someone can provide a series of operations to transform a given key and value into a root hash that matches some trusted root, these key and values must be in the referenced merkle tree. The only possible issue is maliablity in LeafOp, such as providing extra prefix data, which should be controlled by a spec. Eg. with lengthOp as NONE, prefix = FOO, key = BAR, value = CHOICE and prefix = F, key = OOBAR, value = CHOICE would produce the same value. With LengthOp this is tricker but not impossible. Which is why the "leafPrefixEqual" field in the ProofSpec is valuable to prevent this mutability. And why all trees should length-prefix the data before hashing it.
 * @param atu8_key - `key`:
 * @param atu8_value - `value`:
 * @param g_leaf - `leaf`:
 * @param a_paths - `path`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosIcs23ExistenceProof = (atu8_key, atu8_value, atu8_leaf, a_paths) => Protobuf() // ...
    .b(atu8_key) // bytes key = 1
    .b(atu8_value) // bytes value = 2
    .b(atu8_leaf) // LeafOp leaf = 3
    .B(a_paths) // InnerOp[] path = 4
    .o;
/**
 * Encodes a `NonExistenceProof` protobuf message: takes a proof of two neighbors, one left of the desired key, one right of the desired key. If both proofs are valid AND they are neighbors, then there is no valid proof for the given key.
 * @param atu8_key - `key`:
 * @param g_left - `left`:
 * @param g_right - `right`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosIcs23NonExistenceProof = (atu8_key, atu8_left, atu8_right) => Protobuf() // ...
    .b(atu8_key) // bytes key = 1
    .b(atu8_left) // ExistenceProof left = 2
    .b(atu8_right) // ExistenceProof right = 3
    .o;
/**
 * Encodes a `CommitmentProof` protobuf message: either an ExistenceProof or a NonExistenceProof, or a Batch of such messages
 * @param g_exist - `exist`:
 * @param g_nonexist - `nonexist`:
 * @param g_batch - `batch`:
 * @param g_compressed - `compressed`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosIcs23CommitmentProof = (atu8_exist, atu8_nonexist, atu8_batch, atu8_compressed) => Protobuf() // ...
    .b(atu8_exist) // ExistenceProof exist = 1
    .b(atu8_nonexist) // NonExistenceProof nonexist = 2
    .b(atu8_batch) // BatchProof batch = 3
    .b(atu8_compressed) // CompressedBatchProof compressed = 4
    .o;
/**
 * Encodes a `LeafOp` protobuf message: * LeafOp represents the raw key-value data we wish to prove, and must be flexible to represent the internal transformation from the original key-value pairs into the basis hash, for many existing merkle trees. key and value are passed in. So that the signature of this operation is: leafOp(key, value) -> output To process this, first prehash the keys and values if needed (ANY means no hash in this case): hkey = prehashKey(key) hvalue = prehashValue(value) Then combine the bytes, and hash it output = hash(prefix || length(hkey) || hkey || length(hvalue) || hvalue)
 * @param xc_hash - `hash`:
 * @param xc_prehash_key - `prehash_key`:
 * @param xc_prehash_value - `prehash_value`:
 * @param xc_length - `length`:
 * @param atu8_prefix - `prefix`: a fixed bytes that may optionally be included at the beginning to differentiate a leaf node from an inner node.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosIcs23LeafOp = (xc_hash, xc_prehash_key, xc_prehash_value, xc_length, atu8_prefix) => Protobuf() // ...
    .v(xc_hash) // HashOp hash = 1
    .v(xc_prehash_key) // HashOp prehash_key = 2
    .v(xc_prehash_value) // HashOp prehash_value = 3
    .v(xc_length) // LengthOp length = 4
    .b(atu8_prefix) // bytes prefix = 5
    .o;
/**
 * Encodes a `InnerOp` protobuf message: * InnerOp represents a merkle-proof step that is not a leaf. It represents concatenating two children and hashing them to provide the next result. The result of the previous step is passed in, so the signature of this op is: innerOp(child) -> output The result of applying InnerOp should be: output = op.hash(op.prefix || child || op.suffix) where the || operator is concatenation of binary data, and child is the result of hashing all the tree below this step. Any special data, like prepending child with the length, or prepending the entire operation with some value to differentiate from leaf nodes, should be included in prefix and suffix. If either of prefix or suffix is empty, we just treat it as an empty string
 * @param xc_hash - `hash`:
 * @param atu8_prefix - `prefix`:
 * @param atu8_suffix - `suffix`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosIcs23InnerOp = (xc_hash, atu8_prefix, atu8_suffix) => Protobuf() // ...
    .v(xc_hash) // HashOp hash = 1
    .b(atu8_prefix) // bytes prefix = 2
    .b(atu8_suffix) // bytes suffix = 3
    .o;
/**
 * Encodes a `ProofSpec` protobuf message: * ProofSpec defines what the expected parameters are for a given proof type. This can be stored in the client and used to validate any incoming proofs. verify(ProofSpec, Proof) -> Proof | Error As demonstrated in tests, if we don't fix the algorithm used to calculate the LeafHash for a given tree, there are many possible key-value pairs that can generate a given hash (by interpretting the preimage differently). We need this for proper security, requires client knows a priori what tree format server uses. But not in code, rather a configuration object.
 * @param g_leaf_spec - `leaf_spec`: any field in the ExistenceProof must be the same as in this spec. except Prefix, which is just the first bytes of prefix (spec can be longer)
 * @param g_inner_spec - `inner_spec`:
 * @param n_max_depth - `max_depth`: (if > 0) is the maximum number of InnerOps allowed (mainly for fixed-depth tries)
 * @param n_min_depth - `min_depth`: (if > 0) is the minimum number of InnerOps allowed (mainly for fixed-depth tries)
 * @param b_prehash_key_before_comparison - `prehash_key_before_comparison`: a flag that indicates whether to use the prehash_key specified by LeafOp to compare lexical ordering of keys for non-existence proofs.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosIcs23ProofSpec = (atu8_leaf_spec, atu8_inner_spec, n_max_depth, n_min_depth, b_prehash_key_before_comparison) => Protobuf() // ...
    .b(atu8_leaf_spec) // LeafOp leaf_spec = 1
    .b(atu8_inner_spec) // InnerSpec inner_spec = 2
    .v(n_max_depth) // int32 max_depth = 3
    .v(n_min_depth) // int32 min_depth = 4
    .v(b_prehash_key_before_comparison) // boolean prehash_key_before_comparison = 5
    .o;
/**
 * Encodes a `InnerSpec` protobuf message: contains all store-specific structure info to determine if two proofs from a given store are neighbors. This enables: isLeftMost(spec: InnerSpec, op: InnerOp) isRightMost(spec: InnerSpec, op: InnerOp) isLeftNeighbor(spec: InnerSpec, left: InnerOp, right: InnerOp)
 * @param a_child_orders - `child_order`: Child order is the ordering of the children node, must count from 0 iavl tree is [0, 1] (left then right) merk is [0, 2, 1] (left, right, here)
 * @param n_child_size - `child_size`:
 * @param n_min_prefix_length - `min_prefix_length`:
 * @param n_max_prefix_length - `max_prefix_length`:
 * @param atu8_empty_child - `empty_child`: empty child is the prehash image that is used when one child is nil (eg. 20 bytes of 0)
 * @param xc_hash - `hash`: the algorithm that must be used for each InnerOp
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosIcs23InnerSpec = (a_child_orders, n_child_size, n_min_prefix_length, n_max_prefix_length, atu8_empty_child, xc_hash) => Protobuf() // ...
    .V(a_child_orders) // int32[] child_order = 1
    .v(n_child_size) // int32 child_size = 2
    .v(n_min_prefix_length) // int32 min_prefix_length = 3
    .v(n_max_prefix_length) // int32 max_prefix_length = 4
    .b(atu8_empty_child) // bytes empty_child = 5
    .v(xc_hash) // HashOp hash = 6
    .o;
/**
 * Encodes a `BatchProof` protobuf message: a group of multiple proof types than can be compressed
 * @param a_entries - `entries`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosIcs23BatchProof = (a_entries) => Protobuf() // ...
    .B(a_entries) // BatchEntry[] entries = 1
    .o;
/**
 * Encodes a `BatchEntry` protobuf message: Use BatchEntry not CommitmentProof, to avoid recursion
 * @param g_exist - `exist`:
 * @param g_nonexist - `nonexist`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosIcs23BatchEntry = (atu8_exist, atu8_nonexist) => Protobuf() // ...
    .b(atu8_exist) // ExistenceProof exist = 1
    .b(atu8_nonexist) // NonExistenceProof nonexist = 2
    .o;
/**
 * Encodes a `CompressedBatchProof` protobuf message:
 * @param a_entries - `entries`:
 * @param a_lookup_inners - `lookup_inners`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosIcs23CompressedBatchProof = (a_entries, a_lookup_inners) => Protobuf() // ...
    .B(a_entries) // CompressedBatchEntry[] entries = 1
    .B(a_lookup_inners) // InnerOp[] lookup_inners = 2
    .o;
/**
 * Encodes a `CompressedBatchEntry` protobuf message: Use BatchEntry not CommitmentProof, to avoid recursion
 * @param g_exist - `exist`:
 * @param g_nonexist - `nonexist`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosIcs23CompressedBatchEntry = (atu8_exist, atu8_nonexist) => Protobuf() // ...
    .b(atu8_exist) // CompressedExistenceProof exist = 1
    .b(atu8_nonexist) // CompressedNonExistenceProof nonexist = 2
    .o;
/**
 * Encodes a `CompressedExistenceProof` protobuf message:
 * @param atu8_key - `key`:
 * @param atu8_value - `value`:
 * @param g_leaf - `leaf`:
 * @param a_paths - `path`: these are indexes into the lookup_inners table in CompressedBatchProof
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosIcs23CompressedExistenceProof = (atu8_key, atu8_value, atu8_leaf, a_paths) => Protobuf() // ...
    .b(atu8_key) // bytes key = 1
    .b(atu8_value) // bytes value = 2
    .b(atu8_leaf) // LeafOp leaf = 3
    .V(a_paths) // int32[] path = 4
    .o;
/**
 * Encodes a `CompressedNonExistenceProof` protobuf message:
 * @param atu8_key - `key`:
 * @param g_left - `left`:
 * @param g_right - `right`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosIcs23CompressedNonExistenceProof = (atu8_key, atu8_left, atu8_right) => Protobuf() // ...
    .b(atu8_key) // bytes key = 1
    .b(atu8_left) // CompressedExistenceProof left = 2
    .b(atu8_right) // CompressedExistenceProof right = 3
    .o;
/**
 * Decodes a protobuf ExistenceProof message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosIcs23ExistenceProof}
 */
export const decodeCosmosIcs23ExistenceProof = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1, 1, 0], [0, 0, decodeCosmosIcs23LeafOp, decodeCosmosIcs23InnerOp]);
/**
 * Decodes a protobuf NonExistenceProof message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosIcs23NonExistenceProof}
 */
export const decodeCosmosIcs23NonExistenceProof = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1, 1], [0, decodeCosmosIcs23ExistenceProof, decodeCosmosIcs23ExistenceProof]);
/**
 * Decodes a protobuf CommitmentProof message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosIcs23CommitmentProof}
 */
export const decodeCosmosIcs23CommitmentProof = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1, 1, 1], [decodeCosmosIcs23ExistenceProof, decodeCosmosIcs23NonExistenceProof, decodeCosmosIcs23BatchProof, decodeCosmosIcs23CompressedBatchProof]);
/**
 * Decodes a protobuf LeafOp message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosIcs23LeafOp}
 */
export const decodeCosmosIcs23LeafOp = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1, 1, 1, 1]);
/**
 * Decodes a protobuf InnerOp message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosIcs23InnerOp}
 */
export const decodeCosmosIcs23InnerOp = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1, 1]);
/**
 * Decodes a protobuf ProofSpec message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosIcs23ProofSpec}
 */
export const decodeCosmosIcs23ProofSpec = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1, 1, 1, 1], [decodeCosmosIcs23LeafOp, decodeCosmosIcs23InnerSpec]);
/**
 * Decodes a protobuf InnerSpec message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosIcs23InnerSpec}
 */
export const decodeCosmosIcs23InnerSpec = (atu8_payload) => decode_protobuf(atu8_payload, [0, 1, 1, 1, 1, 1]);
/**
 * Decodes a protobuf BatchProof message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosIcs23BatchProof}
 */
export const decodeCosmosIcs23BatchProof = (atu8_payload) => decode_protobuf(atu8_payload, [0], [decodeCosmosIcs23BatchEntry]);
/**
 * Decodes a protobuf BatchEntry message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosIcs23BatchEntry}
 */
export const decodeCosmosIcs23BatchEntry = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1], [decodeCosmosIcs23ExistenceProof, decodeCosmosIcs23NonExistenceProof]);
/**
 * Decodes a protobuf CompressedBatchProof message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosIcs23CompressedBatchProof}
 */
export const decodeCosmosIcs23CompressedBatchProof = (atu8_payload) => decode_protobuf(atu8_payload, [0, 0], [decodeCosmosIcs23CompressedBatchEntry, decodeCosmosIcs23InnerOp]);
/**
 * Decodes a protobuf CompressedBatchEntry message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosIcs23CompressedBatchEntry}
 */
export const decodeCosmosIcs23CompressedBatchEntry = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1], [decodeCosmosIcs23CompressedExistenceProof, decodeCosmosIcs23CompressedNonExistenceProof]);
/**
 * Decodes a protobuf CompressedExistenceProof message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosIcs23CompressedExistenceProof}
 */
export const decodeCosmosIcs23CompressedExistenceProof = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1, 1, 0], [0, 0, decodeCosmosIcs23LeafOp]);
/**
 * Decodes a protobuf CompressedNonExistenceProof message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosIcs23CompressedNonExistenceProof}
 */
export const decodeCosmosIcs23CompressedNonExistenceProof = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1, 1], [0, decodeCosmosIcs23CompressedExistenceProof, decodeCosmosIcs23CompressedExistenceProof]);
/**
 * Destructures the fields of a {@link CosmosIcs23ExistenceProof} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: key -
 *   - 1: value -
 *   - 2: leaf -
 *   - 3: path -
 */
export const destructCosmosIcs23ExistenceProof = (g_struct) => [safe_base64_to_bytes(g_struct.key), safe_base64_to_bytes(g_struct.value), g_struct.leaf, g_struct.path];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_ICS23_EXISTENCE_PROOF = '/cosmos.ics23.v1.ExistenceProof';
/**
 * Destructures the fields of a {@link CosmosIcs23LeafOp} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: hash -
 *   - 1: prehash_key -
 *   - 2: prehash_value -
 *   - 3: length -
 *   - 4: prefix - a fixed bytes that may optionally be included at the beginning to differentiate a leaf node from an inner node.
 */
export const destructCosmosIcs23LeafOp = (g_struct) => [g_struct.hash, g_struct.prehash_key, g_struct.prehash_value, g_struct.length, safe_base64_to_bytes(g_struct.prefix)];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_ICS23_LEAF_OP = '/cosmos.ics23.v1.LeafOp';
/**
 * Destructures the fields of a {@link CosmosIcs23InnerOp} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: hash -
 *   - 1: prefix -
 *   - 2: suffix -
 */
export const destructCosmosIcs23InnerOp = (g_struct) => [g_struct.hash, safe_base64_to_bytes(g_struct.prefix), safe_base64_to_bytes(g_struct.suffix)];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_ICS23_INNER_OP = '/cosmos.ics23.v1.InnerOp';
/**
 * Destructures the fields of a {@link CosmosIcs23NonExistenceProof} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: key -
 *   - 1: left -
 *   - 2: right -
 */
export const destructCosmosIcs23NonExistenceProof = (g_struct) => [safe_base64_to_bytes(g_struct.key), g_struct.left, g_struct.right];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_ICS23_NON_EXISTENCE_PROOF = '/cosmos.ics23.v1.NonExistenceProof';
/**
 * Destructures the fields of a {@link CosmosIcs23CommitmentProof} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: exist -
 *   - 1: nonexist -
 *   - 2: batch -
 *   - 3: compressed -
 */
export const destructCosmosIcs23CommitmentProof = (g_struct) => [g_struct.exist, g_struct.nonexist, g_struct.batch, g_struct.compressed];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_ICS23_COMMITMENT_PROOF = '/cosmos.ics23.v1.CommitmentProof';
/**
 * Destructures the fields of a {@link CosmosIcs23BatchProof} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: entries -
 */
export const destructCosmosIcs23BatchProof = (g_struct) => [g_struct.entries];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_ICS23_BATCH_PROOF = '/cosmos.ics23.v1.BatchProof';
/**
 * Destructures the fields of a {@link CosmosIcs23BatchEntry} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: exist -
 *   - 1: nonexist -
 */
export const destructCosmosIcs23BatchEntry = (g_struct) => [g_struct.exist, g_struct.nonexist];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_ICS23_BATCH_ENTRY = '/cosmos.ics23.v1.BatchEntry';
/**
 * Destructures the fields of a {@link CosmosIcs23CompressedBatchProof} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: entries -
 *   - 1: lookup_inners -
 */
export const destructCosmosIcs23CompressedBatchProof = (g_struct) => [g_struct.entries, g_struct.lookup_inners];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_ICS23_COMPRESSED_BATCH_PROOF = '/cosmos.ics23.v1.CompressedBatchProof';
/**
 * Destructures the fields of a {@link CosmosIcs23CompressedBatchEntry} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: exist -
 *   - 1: nonexist -
 */
export const destructCosmosIcs23CompressedBatchEntry = (g_struct) => [g_struct.exist, g_struct.nonexist];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_ICS23_COMPRESSED_BATCH_ENTRY = '/cosmos.ics23.v1.CompressedBatchEntry';
/**
 * Destructures the fields of a {@link CosmosIcs23CompressedExistenceProof} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: key -
 *   - 1: value -
 *   - 2: leaf -
 *   - 3: path - these are indexes into the lookup_inners table in CompressedBatchProof
 */
export const destructCosmosIcs23CompressedExistenceProof = (g_struct) => [safe_base64_to_bytes(g_struct.key), safe_base64_to_bytes(g_struct.value), g_struct.leaf, g_struct.path];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_ICS23_COMPRESSED_EXISTENCE_PROOF = '/cosmos.ics23.v1.CompressedExistenceProof';
/**
 * Destructures the fields of a {@link CosmosIcs23CompressedNonExistenceProof} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: key -
 *   - 1: left -
 *   - 2: right -
 */
export const destructCosmosIcs23CompressedNonExistenceProof = (g_struct) => [safe_base64_to_bytes(g_struct.key), g_struct.left, g_struct.right];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_ICS23_COMPRESSED_NON_EXISTENCE_PROOF = '/cosmos.ics23.v1.CompressedNonExistenceProof';
/**
 * Destructures the fields of a {@link CosmosIcs23ProofSpec} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: leaf_spec - any field in the ExistenceProof must be the same as in this spec. except Prefix, which is just the first bytes of prefix (spec can be longer)
 *   - 1: inner_spec -
 *   - 2: max_depth - (if > 0) is the maximum number of InnerOps allowed (mainly for fixed-depth tries)
 *   - 3: min_depth - (if > 0) is the minimum number of InnerOps allowed (mainly for fixed-depth tries)
 *   - 4: prehash_key_before_comparison - a flag that indicates whether to use the prehash_key specified by LeafOp to compare lexical ordering of keys for non-existence proofs.
 */
export const destructCosmosIcs23ProofSpec = (g_struct) => [g_struct.leaf_spec, g_struct.inner_spec, g_struct.max_depth, g_struct.min_depth, g_struct.prehash_key_before_comparison];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_ICS23_PROOF_SPEC = '/cosmos.ics23.v1.ProofSpec';
/**
 * Destructures the fields of a {@link CosmosIcs23InnerSpec} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: child_order - Child order is the ordering of the children node, must count from 0 iavl tree is [0, 1] (left then right) merk is [0, 2, 1] (left, right, here)
 *   - 1: child_size -
 *   - 2: min_prefix_length -
 *   - 3: max_prefix_length -
 *   - 4: empty_child - empty child is the prehash image that is used when one child is nil (eg. 20 bytes of 0)
 *   - 5: hash - the algorithm that must be used for each InnerOp
 */
export const destructCosmosIcs23InnerSpec = (g_struct) => [g_struct.child_order, g_struct.child_size, g_struct.min_prefix_length, g_struct.max_prefix_length, safe_base64_to_bytes(g_struct.empty_child), g_struct.hash];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_ICS23_INNER_SPEC = '/cosmos.ics23.v1.InnerSpec';
/**
 * Protobuf enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **NO_HASH** - the default if no data passed. Note this is an illegal argument some places.
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23HashOp}
 */
export const XC_PROTO_COSMOS_ICS23HASH_OP_NO_HASH = 0;
/**
 * JSON enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **NO_HASH** - the default if no data passed. Note this is an illegal argument some places.
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23HashOp}
 */
export const SI_JSON_COSMOS_ICS23HASH_OP_NO_HASH = 'NO_HASH';
/**
 * Protobuf enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **SHA256** -
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23HashOp}
 */
export const XC_PROTO_COSMOS_ICS23HASH_OP_SHA256 = 1;
/**
 * JSON enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **SHA256** -
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23HashOp}
 */
export const SI_JSON_COSMOS_ICS23HASH_OP_SHA256 = 'SHA256';
/**
 * Protobuf enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **SHA512** -
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23HashOp}
 */
export const XC_PROTO_COSMOS_ICS23HASH_OP_SHA512 = 2;
/**
 * JSON enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **SHA512** -
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23HashOp}
 */
export const SI_JSON_COSMOS_ICS23HASH_OP_SHA512 = 'SHA512';
/**
 * Protobuf enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **KECCAK256** -
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23HashOp}
 */
export const XC_PROTO_COSMOS_ICS23HASH_OP_KECCAK256 = 3;
/**
 * JSON enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **KECCAK256** -
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23HashOp}
 */
export const SI_JSON_COSMOS_ICS23HASH_OP_KECCAK256 = 'KECCAK256';
/**
 * Protobuf enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **RIPEMD160** -
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23HashOp}
 */
export const XC_PROTO_COSMOS_ICS23HASH_OP_RIPEMD160 = 4;
/**
 * JSON enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **RIPEMD160** -
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23HashOp}
 */
export const SI_JSON_COSMOS_ICS23HASH_OP_RIPEMD160 = 'RIPEMD160';
/**
 * Protobuf enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **BITCOIN** -
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23HashOp}
 */
export const XC_PROTO_COSMOS_ICS23HASH_OP_BITCOIN = 5;
/**
 * JSON enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **BITCOIN** -
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23HashOp}
 */
export const SI_JSON_COSMOS_ICS23HASH_OP_BITCOIN = 'BITCOIN';
/**
 * Protobuf enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **SHA512_256** -
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23HashOp}
 */
export const XC_PROTO_COSMOS_ICS23HASH_OP_SHA512_256 = 6;
/**
 * JSON enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **SHA512_256** -
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23HashOp}
 */
export const SI_JSON_COSMOS_ICS23HASH_OP_SHA512_256 = 'SHA512_256';
/**
 * Protobuf enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **BLAKE2B_512** -
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23HashOp}
 */
export const XC_PROTO_COSMOS_ICS23HASH_OP_BLAKE2B_512 = 7;
/**
 * JSON enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **BLAKE2B_512** -
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23HashOp}
 */
export const SI_JSON_COSMOS_ICS23HASH_OP_BLAKE2B_512 = 'BLAKE2B_512';
/**
 * Protobuf enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **BLAKE2S_256** -
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23HashOp}
 */
export const XC_PROTO_COSMOS_ICS23HASH_OP_BLAKE2S_256 = 8;
/**
 * JSON enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **BLAKE2S_256** -
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23HashOp}
 */
export const SI_JSON_COSMOS_ICS23HASH_OP_BLAKE2S_256 = 'BLAKE2S_256';
/**
 * Protobuf enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **BLAKE3** -
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23HashOp}
 */
export const XC_PROTO_COSMOS_ICS23HASH_OP_BLAKE3 = 9;
/**
 * JSON enum value for `cosmos.ics23.v1.HashOp`.
 *
 * **BLAKE3** -
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23HashOp}
 */
export const SI_JSON_COSMOS_ICS23HASH_OP_BLAKE3 = 'BLAKE3';
/**
 * Maps a protobuf enum int value for `cosmos.ics23.v1.HashOp` to is JSON equivalent enum string value
 */
export const ProtoToJsonEnumCosmosIcs23HashOp = {
    [XC_PROTO_COSMOS_ICS23HASH_OP_NO_HASH]: SI_JSON_COSMOS_ICS23HASH_OP_NO_HASH,
    [XC_PROTO_COSMOS_ICS23HASH_OP_SHA256]: SI_JSON_COSMOS_ICS23HASH_OP_SHA256,
    [XC_PROTO_COSMOS_ICS23HASH_OP_SHA512]: SI_JSON_COSMOS_ICS23HASH_OP_SHA512,
    [XC_PROTO_COSMOS_ICS23HASH_OP_KECCAK256]: SI_JSON_COSMOS_ICS23HASH_OP_KECCAK256,
    [XC_PROTO_COSMOS_ICS23HASH_OP_RIPEMD160]: SI_JSON_COSMOS_ICS23HASH_OP_RIPEMD160,
    [XC_PROTO_COSMOS_ICS23HASH_OP_BITCOIN]: SI_JSON_COSMOS_ICS23HASH_OP_BITCOIN,
    [XC_PROTO_COSMOS_ICS23HASH_OP_SHA512_256]: SI_JSON_COSMOS_ICS23HASH_OP_SHA512_256,
    [XC_PROTO_COSMOS_ICS23HASH_OP_BLAKE2B_512]: SI_JSON_COSMOS_ICS23HASH_OP_BLAKE2B_512,
    [XC_PROTO_COSMOS_ICS23HASH_OP_BLAKE2S_256]: SI_JSON_COSMOS_ICS23HASH_OP_BLAKE2S_256,
    [XC_PROTO_COSMOS_ICS23HASH_OP_BLAKE3]: SI_JSON_COSMOS_ICS23HASH_OP_BLAKE3,
};
/**
 * Maps a JSON enum string value for `cosmos.ics23.v1.HashOp` to is protobuf equivalent enum int value
 */
export const JsonToProtoEnumCosmosIcs23HashOp = {
    [SI_JSON_COSMOS_ICS23HASH_OP_NO_HASH]: XC_PROTO_COSMOS_ICS23HASH_OP_NO_HASH,
    [SI_JSON_COSMOS_ICS23HASH_OP_SHA256]: XC_PROTO_COSMOS_ICS23HASH_OP_SHA256,
    [SI_JSON_COSMOS_ICS23HASH_OP_SHA512]: XC_PROTO_COSMOS_ICS23HASH_OP_SHA512,
    [SI_JSON_COSMOS_ICS23HASH_OP_KECCAK256]: XC_PROTO_COSMOS_ICS23HASH_OP_KECCAK256,
    [SI_JSON_COSMOS_ICS23HASH_OP_RIPEMD160]: XC_PROTO_COSMOS_ICS23HASH_OP_RIPEMD160,
    [SI_JSON_COSMOS_ICS23HASH_OP_BITCOIN]: XC_PROTO_COSMOS_ICS23HASH_OP_BITCOIN,
    [SI_JSON_COSMOS_ICS23HASH_OP_SHA512_256]: XC_PROTO_COSMOS_ICS23HASH_OP_SHA512_256,
    [SI_JSON_COSMOS_ICS23HASH_OP_BLAKE2B_512]: XC_PROTO_COSMOS_ICS23HASH_OP_BLAKE2B_512,
    [SI_JSON_COSMOS_ICS23HASH_OP_BLAKE2S_256]: XC_PROTO_COSMOS_ICS23HASH_OP_BLAKE2S_256,
    [SI_JSON_COSMOS_ICS23HASH_OP_BLAKE3]: XC_PROTO_COSMOS_ICS23HASH_OP_BLAKE3,
};
/**
 * Protobuf enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **NO_PREFIX** - don't include any length info
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23LengthOp}
 */
export const XC_PROTO_COSMOS_ICS23LENGTH_OP_NO_PREFIX = 0;
/**
 * JSON enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **NO_PREFIX** - don't include any length info
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23LengthOp}
 */
export const SI_JSON_COSMOS_ICS23LENGTH_OP_NO_PREFIX = 'NO_PREFIX';
/**
 * Protobuf enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **VAR_PROTO** - uses protobuf (and go-amino) varint encoding of the length
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23LengthOp}
 */
export const XC_PROTO_COSMOS_ICS23LENGTH_OP_VAR_PROTO = 1;
/**
 * JSON enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **VAR_PROTO** - uses protobuf (and go-amino) varint encoding of the length
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23LengthOp}
 */
export const SI_JSON_COSMOS_ICS23LENGTH_OP_VAR_PROTO = 'VAR_PROTO';
/**
 * Protobuf enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **VAR_RLP** - uses rlp int encoding of the length
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23LengthOp}
 */
export const XC_PROTO_COSMOS_ICS23LENGTH_OP_VAR_RLP = 2;
/**
 * JSON enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **VAR_RLP** - uses rlp int encoding of the length
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23LengthOp}
 */
export const SI_JSON_COSMOS_ICS23LENGTH_OP_VAR_RLP = 'VAR_RLP';
/**
 * Protobuf enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **FIXED32_BIG** - uses big-endian encoding of the length as a 32 bit integer
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23LengthOp}
 */
export const XC_PROTO_COSMOS_ICS23LENGTH_OP_FIXED32_BIG = 3;
/**
 * JSON enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **FIXED32_BIG** - uses big-endian encoding of the length as a 32 bit integer
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23LengthOp}
 */
export const SI_JSON_COSMOS_ICS23LENGTH_OP_FIXED32_BIG = 'FIXED32_BIG';
/**
 * Protobuf enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **FIXED32_LITTLE** - uses little-endian encoding of the length as a 32 bit integer
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23LengthOp}
 */
export const XC_PROTO_COSMOS_ICS23LENGTH_OP_FIXED32_LITTLE = 4;
/**
 * JSON enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **FIXED32_LITTLE** - uses little-endian encoding of the length as a 32 bit integer
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23LengthOp}
 */
export const SI_JSON_COSMOS_ICS23LENGTH_OP_FIXED32_LITTLE = 'FIXED32_LITTLE';
/**
 * Protobuf enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **FIXED64_BIG** - uses big-endian encoding of the length as a 64 bit integer
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23LengthOp}
 */
export const XC_PROTO_COSMOS_ICS23LENGTH_OP_FIXED64_BIG = 5;
/**
 * JSON enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **FIXED64_BIG** - uses big-endian encoding of the length as a 64 bit integer
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23LengthOp}
 */
export const SI_JSON_COSMOS_ICS23LENGTH_OP_FIXED64_BIG = 'FIXED64_BIG';
/**
 * Protobuf enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **FIXED64_LITTLE** - uses little-endian encoding of the length as a 64 bit integer
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23LengthOp}
 */
export const XC_PROTO_COSMOS_ICS23LENGTH_OP_FIXED64_LITTLE = 6;
/**
 * JSON enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **FIXED64_LITTLE** - uses little-endian encoding of the length as a 64 bit integer
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23LengthOp}
 */
export const SI_JSON_COSMOS_ICS23LENGTH_OP_FIXED64_LITTLE = 'FIXED64_LITTLE';
/**
 * Protobuf enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **REQUIRE_32_BYTES** - like NONE, but will fail if the input is not exactly 32 bytes (sha256 output)
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23LengthOp}
 */
export const XC_PROTO_COSMOS_ICS23LENGTH_OP_REQUIRE_32_BYTES = 7;
/**
 * JSON enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **REQUIRE_32_BYTES** - like NONE, but will fail if the input is not exactly 32 bytes (sha256 output)
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23LengthOp}
 */
export const SI_JSON_COSMOS_ICS23LENGTH_OP_REQUIRE_32_BYTES = 'REQUIRE_32_BYTES';
/**
 * Protobuf enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **REQUIRE_64_BYTES** - like NONE, but will fail if the input is not exactly 64 bytes (sha512 output)
 *
 * Belongs to enum type {@link ProtoEnumCosmosIcs23LengthOp}
 */
export const XC_PROTO_COSMOS_ICS23LENGTH_OP_REQUIRE_64_BYTES = 8;
/**
 * JSON enum value for `cosmos.ics23.v1.LengthOp`.
 *
 * **REQUIRE_64_BYTES** - like NONE, but will fail if the input is not exactly 64 bytes (sha512 output)
 *
 * Belongs to enum type {@link JsonEnumCosmosIcs23LengthOp}
 */
export const SI_JSON_COSMOS_ICS23LENGTH_OP_REQUIRE_64_BYTES = 'REQUIRE_64_BYTES';
/**
 * Maps a protobuf enum int value for `cosmos.ics23.v1.LengthOp` to is JSON equivalent enum string value
 */
export const ProtoToJsonEnumCosmosIcs23LengthOp = {
    [XC_PROTO_COSMOS_ICS23LENGTH_OP_NO_PREFIX]: SI_JSON_COSMOS_ICS23LENGTH_OP_NO_PREFIX,
    [XC_PROTO_COSMOS_ICS23LENGTH_OP_VAR_PROTO]: SI_JSON_COSMOS_ICS23LENGTH_OP_VAR_PROTO,
    [XC_PROTO_COSMOS_ICS23LENGTH_OP_VAR_RLP]: SI_JSON_COSMOS_ICS23LENGTH_OP_VAR_RLP,
    [XC_PROTO_COSMOS_ICS23LENGTH_OP_FIXED32_BIG]: SI_JSON_COSMOS_ICS23LENGTH_OP_FIXED32_BIG,
    [XC_PROTO_COSMOS_ICS23LENGTH_OP_FIXED32_LITTLE]: SI_JSON_COSMOS_ICS23LENGTH_OP_FIXED32_LITTLE,
    [XC_PROTO_COSMOS_ICS23LENGTH_OP_FIXED64_BIG]: SI_JSON_COSMOS_ICS23LENGTH_OP_FIXED64_BIG,
    [XC_PROTO_COSMOS_ICS23LENGTH_OP_FIXED64_LITTLE]: SI_JSON_COSMOS_ICS23LENGTH_OP_FIXED64_LITTLE,
    [XC_PROTO_COSMOS_ICS23LENGTH_OP_REQUIRE_32_BYTES]: SI_JSON_COSMOS_ICS23LENGTH_OP_REQUIRE_32_BYTES,
    [XC_PROTO_COSMOS_ICS23LENGTH_OP_REQUIRE_64_BYTES]: SI_JSON_COSMOS_ICS23LENGTH_OP_REQUIRE_64_BYTES,
};
/**
 * Maps a JSON enum string value for `cosmos.ics23.v1.LengthOp` to is protobuf equivalent enum int value
 */
export const JsonToProtoEnumCosmosIcs23LengthOp = {
    [SI_JSON_COSMOS_ICS23LENGTH_OP_NO_PREFIX]: XC_PROTO_COSMOS_ICS23LENGTH_OP_NO_PREFIX,
    [SI_JSON_COSMOS_ICS23LENGTH_OP_VAR_PROTO]: XC_PROTO_COSMOS_ICS23LENGTH_OP_VAR_PROTO,
    [SI_JSON_COSMOS_ICS23LENGTH_OP_VAR_RLP]: XC_PROTO_COSMOS_ICS23LENGTH_OP_VAR_RLP,
    [SI_JSON_COSMOS_ICS23LENGTH_OP_FIXED32_BIG]: XC_PROTO_COSMOS_ICS23LENGTH_OP_FIXED32_BIG,
    [SI_JSON_COSMOS_ICS23LENGTH_OP_FIXED32_LITTLE]: XC_PROTO_COSMOS_ICS23LENGTH_OP_FIXED32_LITTLE,
    [SI_JSON_COSMOS_ICS23LENGTH_OP_FIXED64_BIG]: XC_PROTO_COSMOS_ICS23LENGTH_OP_FIXED64_BIG,
    [SI_JSON_COSMOS_ICS23LENGTH_OP_FIXED64_LITTLE]: XC_PROTO_COSMOS_ICS23LENGTH_OP_FIXED64_LITTLE,
    [SI_JSON_COSMOS_ICS23LENGTH_OP_REQUIRE_32_BYTES]: XC_PROTO_COSMOS_ICS23LENGTH_OP_REQUIRE_32_BYTES,
    [SI_JSON_COSMOS_ICS23LENGTH_OP_REQUIRE_64_BYTES]: XC_PROTO_COSMOS_ICS23LENGTH_OP_REQUIRE_64_BYTES,
};
//# sourceMappingURL=proofs.js.map