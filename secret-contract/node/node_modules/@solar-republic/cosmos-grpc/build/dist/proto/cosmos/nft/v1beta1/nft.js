/*
* ================================
*     GENERATED FILE WARNING
* Do not edit this file manually.
* ================================
*/
import { __UNDEFINED } from '@blake.regalia/belt';
import { decode_protobuf } from '../../../../api/protobuf-reader.js';
import { Protobuf } from '../../../../api/protobuf-writer.js';
import { decodeGoogleProtobufAny } from '../../../google/protobuf/any.js';
/**
 * Encodes a `Class` protobuf message: defines the class of the nft type.
 * @param s_id - `id`: defines the unique identifier of the NFT classification, similar to the contract address of ERC721
 * @param s_name - `name`: defines the human-readable name of the NFT classification. Optional
 * @param s_symbol - `symbol`: an abbreviated name for nft classification. Optional
 * @param s_description - `description`: a brief description of nft classification. Optional
 * @param s_uri - `uri`: for the class metadata stored off chain. It can define schema for Class and NFT `Data` attributes. Optional
 * @param s_uri_hash - `uri_hash`: a hash of the document pointed by uri. Optional
 * @param atu8_data - `data`: the app specific metadata of the NFT class. Optional
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosNftClass = (s_id, s_name, s_symbol, s_description, s_uri, s_uri_hash, atu8_data) => Protobuf() // ...
    .s(s_id) // string id = 1
    .s(s_name) // string name = 2
    .s(s_symbol) // string symbol = 3
    .s(s_description) // string description = 4
    .s(s_uri) // string uri = 5
    .s(s_uri_hash) // string uri_hash = 6
    .b(atu8_data) // Any data = 7
    .o;
/**
 * Encodes a `NFT` protobuf message: defines the NFT.
 * @param si_class - `class_id`: associated with the NFT, similar to the contract address of ERC721
 * @param s_id - `id`: a unique identifier of the NFT
 * @param s_uri - `uri`: for the NFT metadata stored off chain
 * @param s_uri_hash - `uri_hash`: a hash of the document pointed by uri
 * @param atu8_data - `data`: an app specific data of the NFT. Optional
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosNftNFT = (si_class, s_id, s_uri, s_uri_hash, atu8_data) => Protobuf() // ...
    .s(si_class) // string class_id = 1
    .s(s_id) // string id = 2
    .s(s_uri) // string uri = 3
    .s(s_uri_hash) // string uri_hash = 4
    .b(atu8_data, 10) // Any data = 10
    .o;
/**
 * Decodes a protobuf Class message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosNftClass}
 */
export const decodeCosmosNftClass = (atu8_payload) => decode_protobuf(atu8_payload, [5, 5, 5, 5, 5, 5, 1], [0, 0, 0, 0, 0, 0, decodeGoogleProtobufAny]);
/**
 * Decodes a protobuf NFT message
 * @param atu8_payload - raw bytes to decode
 * @param RESERVED - a second argument is explicitly forbidden. make sure not to pass this function by reference to some callback argument
 * @returns a {@link DecodedCosmosNftNFT}
 */
export const decodeCosmosNftNFT = ((atu8_payload, [si_class, s_id, s_uri, s_uri_hash, , , , , , a_data] = decode_protobuf(atu8_payload, [5, 5, 5, 5, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, decodeGoogleProtobufAny])) => [si_class, s_id, s_uri, s_uri_hash, __UNDEFINED, __UNDEFINED, __UNDEFINED, __UNDEFINED, __UNDEFINED, a_data]);
/**
 * Destructures the fields of a {@link CosmosNftNFT} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: class_id - associated with the NFT, similar to the contract address of ERC721
 *   - 1: id - a unique identifier of the NFT
 *   - 2: uri - for the NFT metadata stored off chain
 *   - 3: uri_hash - a hash of the document pointed by uri
 *   - 9: data - an app specific data of the NFT. Optional
 */
export const destructCosmosNftNFT = (g_struct) => [g_struct.class_id, g_struct.id, g_struct.uri, g_struct.uri_hash, __UNDEFINED, __UNDEFINED, __UNDEFINED, __UNDEFINED, __UNDEFINED, g_struct.data];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_NFT_N_F_T = '/cosmos.nft.v1beta1.NFT';
/**
 * Destructures the fields of a {@link CosmosNftClass} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: id - defines the unique identifier of the NFT classification, similar to the contract address of ERC721
 *   - 1: name - defines the human-readable name of the NFT classification. Optional
 *   - 2: symbol - an abbreviated name for nft classification. Optional
 *   - 3: description - a brief description of nft classification. Optional
 *   - 4: uri - for the class metadata stored off chain. It can define schema for Class and NFT `Data` attributes. Optional
 *   - 5: uri_hash - a hash of the document pointed by uri. Optional
 *   - 6: data - the app specific metadata of the NFT class. Optional
 */
export const destructCosmosNftClass = (g_struct) => [g_struct.id, g_struct.name, g_struct.symbol, g_struct.description, g_struct.uri, g_struct.uri_hash, g_struct.data];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_NFT_CLASS = '/cosmos.nft.v1beta1.Class';
//# sourceMappingURL=nft.js.map