import type { WeakUint64Str, WeakAccountAddr, SlimCoin, CwUint64, CwBase64, CwAccountAddr } from '@solar-republic/types';
import type { Encoded, JsonAny, Opt } from '../../../../api/types.js';
import type { CosmosBaseCoin } from '../../base/v1beta1/coin.js';
import type { CosmosCryptoMultisigCompactBitArray, DecodedCosmosCryptoMultisigCompactBitArray } from '../../crypto/multisig/v1beta1/multisig.js';
import type { ProtoEnumCosmosTxSigningSignMode, JsonEnumCosmosTxSigningSignMode } from '../signing/v1beta1/signing.js';
import type { DecodedGoogleProtobufAny } from '../../../google/protobuf/any.js';
export type EncodedCosmosTxTx = Encoded<'/cosmos.tx.v1beta1.Tx'>;
export type EncodedCosmosTxTxRaw = Encoded<'/cosmos.tx.v1beta1.TxRaw'>;
export type EncodedCosmosTxSignDoc = Encoded<'/cosmos.tx.v1beta1.SignDoc'>;
export type EncodedCosmosTxSignDocDirectAux = Encoded<'/cosmos.tx.v1beta1.SignDocDirectAux'>;
export type EncodedCosmosTxTxBody = Encoded<'/cosmos.tx.v1beta1.TxBody'>;
export type EncodedCosmosTxAuthInfo = Encoded<'/cosmos.tx.v1beta1.AuthInfo'>;
export type EncodedCosmosTxSignerInfo = Encoded<'/cosmos.tx.v1beta1.SignerInfo'>;
export type EncodedCosmosTxModeInfo = Encoded<'/cosmos.tx.v1beta1.ModeInfo'>;
export type EncodedCosmosTxFee = Encoded<'/cosmos.tx.v1beta1.Fee'>;
export type EncodedCosmosTxTip = Encoded<'/cosmos.tx.v1beta1.Tip'>;
export type EncodedCosmosTxAuxSignerData = Encoded<'/cosmos.tx.v1beta1.AuxSignerData'>;
export type EncodedCosmosTxModeInfoSingle = Encoded<'/cosmos.tx.v1beta1.ModeInfo.Single'>;
export type EncodedCosmosTxModeInfoMulti = Encoded<'/cosmos.tx.v1beta1.ModeInfo.Multi'>;
/**
 * Encodes a `Tx` protobuf message: the standard type used for broadcasting transactions.
 * @param g_body - `body`: the processable content of the transaction
 * @param g_auth_info - `auth_info`: the authorization related content of the transaction, specifically signers, signer modes and fee
 * @param a_signatures - `signatures`: a list of signatures that matches the length and order of AuthInfo's signer_infos to allow connecting signature meta information like public key and signing mode by position.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosTxTx: (atu8_body?: Opt<Encoded<'/cosmos.tx.v1beta1.TxBody'>>, atu8_auth_info?: Opt<Encoded<'/cosmos.tx.v1beta1.AuthInfo'>>, a_signatures?: Opt<Uint8Array[]>) => EncodedCosmosTxTx;
/**
 * Encodes a `TxRaw` protobuf message: a variant of Tx that pins the signer's exact binary representation of body and auth_info. This is used for signing, broadcasting and verification. The binary `serialize(tx: TxRaw)` is stored in Tendermint and the hash `sha256(serialize(tx: TxRaw))` becomes the "txhash", commonly used as the transaction ID.
 * @param atu8_body_bytes - `body_bytes`: a protobuf serialization of a TxBody that matches the representation in SignDoc.
 * @param atu8_auth_info_bytes - `auth_info_bytes`: a protobuf serialization of an AuthInfo that matches the representation in SignDoc.
 * @param a_signatures - `signatures`: a list of signatures that matches the length and order of AuthInfo's signer_infos to allow connecting signature meta information like public key and signing mode by position.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosTxTxRaw: (atu8_body_bytes?: Opt<Uint8Array>, atu8_auth_info_bytes?: Opt<Uint8Array>, a_signatures?: Opt<Uint8Array[]>) => EncodedCosmosTxTxRaw;
/**
 * Encodes a `SignDoc` protobuf message: the type used for generating sign bytes for SIGN_MODE_DIRECT.
 * @param atu8_body_bytes - `body_bytes`: protobuf serialization of a TxBody that matches the representation in TxRaw.
 * @param atu8_auth_info_bytes - `auth_info_bytes`: a protobuf serialization of an AuthInfo that matches the representation in TxRaw.
 * @param si_chain - `chain_id`: the unique identifier of the chain this transaction targets. It prevents signed transactions from being used on another chain by an attacker
 * @param sg_account_number - `account_number`: the account number of the account in state
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosTxSignDoc: (atu8_body_bytes?: Opt<Uint8Array>, atu8_auth_info_bytes?: Opt<Uint8Array>, si_chain?: Opt<string>, sg_account_number?: Opt<WeakUint64Str>) => EncodedCosmosTxSignDoc;
/**
 * Encodes a `SignDocDirectAux` protobuf message: the type used for generating sign bytes for SIGN_MODE_DIRECT_AUX. Since: cosmos-sdk 0.46
 * @param atu8_body_bytes - `body_bytes`: protobuf serialization of a TxBody that matches the representation in TxRaw.
 * @param atu8_public_key - `public_key`: the public key of the signing account.
 * @param si_chain - `chain_id`: the identifier of the chain this transaction targets. It prevents signed transactions from being used on another chain by an attacker.
 * @param sg_account_number - `account_number`: the account number of the account in state.
 * @param sg_sequence - `sequence`: the sequence number of the signing account.
 * @param g_tip - `tip`: s have been depreacted and should not be used
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosTxSignDocDirectAux: (atu8_body_bytes?: Opt<Uint8Array>, atu8_public_key?: Opt<Uint8Array>, si_chain?: Opt<string>, sg_account_number?: Opt<WeakUint64Str>, sg_sequence?: Opt<WeakUint64Str>, atu8_tip?: Opt<Encoded<'/cosmos.tx.v1beta1.Tip'>>) => EncodedCosmosTxSignDocDirectAux;
/**
 * Encodes a `TxBody` protobuf message: the body of a transaction that all signers sign over.
 * @param a_messages - `messages`: a list of messages to be executed. The required signers of those messages define the number and order of elements in AuthInfo's signer_infos and Tx's signatures. Each required signer address is added to the list only the first time it occurs. By convention, the first required signer (usually from the first message) is referred to as the primary signer and pays the fee for the whole transaction.
 * @param s_memo - `memo`: any arbitrary note/comment to be added to the transaction. WARNING: in clients, any publicly exposed text should not be called memo, but should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122).
 * @param sg_timeout_height - `timeout_height`: timeout is the block height after which this transaction will not be processed by the chain
 * @param a_extension_options - `extension_options`: arbitrary options that can be added by chains when the default options are not sufficient. If any of these are present and can't be handled, the transaction will be rejected
 * @param a_non_critical_extension_options - `non_critical_extension_options`: extension_options are arbitrary options that can be added by chains when the default options are not sufficient. If any of these are present and can't be handled, they will be ignored
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosTxTxBody: (a_messages?: Opt<Uint8Array[]>, s_memo?: Opt<string>, sg_timeout_height?: Opt<WeakUint64Str>, a_extension_options?: Opt<Uint8Array[]>, a_non_critical_extension_options?: Opt<Uint8Array[]>) => EncodedCosmosTxTxBody;
/**
 * Encodes a `AuthInfo` protobuf message: describes the fee and signer modes that are used to sign a transaction.
 * @param a_signer_infos - `signer_infos`: defines the signing modes for the required signers. The number and order of elements must match the required signers from TxBody's messages. The first element is the primary signer and the one which pays the fee.
 * @param g_fee - `fee`: Fee is the fee and gas limit for the transaction. The first signer is the primary signer and the one which pays the fee. The fee can be calculated based on the cost of evaluating the body and doing signature verification of the signers. This can be estimated via simulation.
 * @param g_tip - `tip`: Tip is the optional tip used for transactions fees paid in another denom. This field is ignored if the chain didn't enable tips, i.e. didn't add the `TipDecorator` in its posthandler. Since: cosmos-sdk 0.46
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosTxAuthInfo: (a_signer_infos?: Opt<Encoded<'/cosmos.tx.v1beta1.SignerInfo'>[]>, atu8_fee?: Opt<Encoded<'/cosmos.tx.v1beta1.Fee'>>, atu8_tip?: Opt<Encoded<'/cosmos.tx.v1beta1.Tip'>>) => EncodedCosmosTxAuthInfo;
/**
 * Encodes a `SignerInfo` protobuf message: describes the public key and signing mode of a single top-level signer.
 * @param atu8_public_key - `public_key`: the public key of the signer. It is optional for accounts that already exist in state. If unset, the verifier can use the required \ signer address for this position and lookup the public key.
 * @param g_mode_info - `mode_info`: describes the signing mode of the signer and is a nested structure to support nested multisig pubkey's
 * @param sg_sequence - `sequence`: the sequence of the account, which describes the number of committed transactions signed by a given address. It is used to prevent replay attacks.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosTxSignerInfo: (atu8_public_key?: Opt<Uint8Array>, atu8_mode_info?: Opt<Encoded<'/cosmos.tx.v1beta1.ModeInfo'>>, sg_sequence?: Opt<WeakUint64Str>) => EncodedCosmosTxSignerInfo;
/**
 * Encodes a `ModeInfo` protobuf message: describes the signing mode of a single or nested multisig signer.
 * @param g_single - `single`: represents a single signer
 * @param g_multi - `multi`: represents a nested multisig signer
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosTxModeInfo: (atu8_single?: Opt<Encoded<'/cosmos.tx.v1beta1.ModeInfo.Single'>>, atu8_multi?: Opt<Encoded<'/cosmos.tx.v1beta1.ModeInfo.Multi'>>) => EncodedCosmosTxModeInfo;
/**
 * Encodes a `Fee` protobuf message: includes the amount of coins paid in fees and the maximum gas to be used by the transaction. The ratio yields an effective "gasprice", which must be above some miminum to be accepted into the mempool.
 * @param a_amounts - `amount`: the amount of coins to be paid as a fee
 * @param sg_gas_limit - `gas_limit`: the maximum gas that can be used in transaction processing before an out of gas error occurs
 * @param sa_payer - `payer`: if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees. the payer must be a tx signer (and thus have signed this field in AuthInfo). setting this field does *not* change the ordering of required signers for the transaction.
 * @param sa_granter - `granter`: if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used to pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does not support fee grants, this will fail
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosTxFee: (a_amounts?: Opt<SlimCoin[]>, sg_gas_limit?: Opt<WeakUint64Str>, sa_payer?: Opt<WeakAccountAddr>, sa_granter?: Opt<WeakAccountAddr>) => EncodedCosmosTxFee;
/**
 * Encodes a `Tip` protobuf message: the tip used for meta-transactions. Since: cosmos-sdk 0.46
 * @param a_amounts - `amount`: the amount of the tip
 * @param s_tipper - `tipper`: the address of the account paying for the tip
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosTxTip: (a_amounts?: Opt<SlimCoin[]>, s_tipper?: Opt<string>) => EncodedCosmosTxTip;
/**
 * Encodes a `AuxSignerData` protobuf message: the intermediary format that an auxiliary signer (e.g. a tipper) builds and sends to the fee payer (who will build and broadcast the actual tx). AuxSignerData is not a valid tx in itself, and will be rejected by the node if sent directly as-is. Since: cosmos-sdk 0.46
 * @param sa_address - `address`: the bech32-encoded address of the auxiliary signer. If using AuxSignerData across different chains, the bech32 prefix of the target chain (where the final transaction is broadcasted) should be used.
 * @param g_sign_doc - `sign_doc`: the SIGN_MODE_DIRECT_AUX sign doc that the auxiliary signer signs. Note: we use the same sign doc even if we're signing with LEGACY_AMINO_JSON.
 * @param xc_mode - `mode`: the signing mode of the single signer.
 * @param atu8_sig - `sig`: the signature of the sign doc.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosTxAuxSignerData: (sa_address?: Opt<WeakAccountAddr>, atu8_sign_doc?: Opt<Encoded<'/cosmos.tx.v1beta1.SignDocDirectAux'>>, xc_mode?: Opt<ProtoEnumCosmosTxSigningSignMode>, atu8_sig?: Opt<Uint8Array>) => EncodedCosmosTxAuxSignerData;
/**
 * Encodes a `Single` protobuf message:
 * @param xc_mode - `mode`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosTxModeInfoSingle: (xc_mode?: Opt<ProtoEnumCosmosTxSigningSignMode>) => EncodedCosmosTxModeInfoSingle;
/**
 * Encodes a `Multi` protobuf message:
 * @param g_bitarray - `bitarray`:
 * @param a_mode_infos - `mode_infos`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeCosmosTxModeInfoMulti: (atu8_bitarray?: Opt<Encoded<'/cosmos.crypto.multisig.v1beta1.CompactBitArray'>>, a_mode_infos?: Opt<Encoded<'/cosmos.tx.v1beta1.ModeInfo'>[]>) => EncodedCosmosTxModeInfoMulti;
/**
 * A decoded protobuf Tx message
 *
 * Tuple where:
 *   - 0: body - the processable content of the transaction
 *   - 1: auth_info - the authorization related content of the transaction, specifically signers, signer modes and fee
 *   - 2: signatures - a list of signatures that matches the length and order of AuthInfo's signer_infos to allow connecting signature meta information like public key and signing mode by position.
 */
export type DecodedCosmosTxTx = [
    a_body?: DecodedCosmosTxTxBody,
    a_auth_info?: DecodedCosmosTxAuthInfo,
    a_signatures?: Uint8Array[]
];
/**
 * Decodes a protobuf Tx message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosTxTx}
 */
export declare const decodeCosmosTxTx: (atu8_payload: Uint8Array) => DecodedCosmosTxTx;
/**
 * A decoded protobuf TxRaw message
 *
 * Tuple where:
 *   - 0: body_bytes - a protobuf serialization of a TxBody that matches the representation in SignDoc.
 *   - 1: auth_info_bytes - a protobuf serialization of an AuthInfo that matches the representation in SignDoc.
 *   - 2: signatures - a list of signatures that matches the length and order of AuthInfo's signer_infos to allow connecting signature meta information like public key and signing mode by position.
 */
export type DecodedCosmosTxTxRaw = [
    atu8_body_bytes?: Uint8Array,
    atu8_auth_info_bytes?: Uint8Array,
    a_signatures?: Uint8Array[]
];
/**
 * Decodes a protobuf TxRaw message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosTxTxRaw}
 */
export declare const decodeCosmosTxTxRaw: (atu8_payload: Uint8Array) => DecodedCosmosTxTxRaw;
/**
 * A decoded protobuf SignDoc message
 *
 * Tuple where:
 *   - 0: body_bytes - protobuf serialization of a TxBody that matches the representation in TxRaw.
 *   - 1: auth_info_bytes - a protobuf serialization of an AuthInfo that matches the representation in TxRaw.
 *   - 2: chain_id - the unique identifier of the chain this transaction targets. It prevents signed transactions from being used on another chain by an attacker
 *   - 3: account_number - the account number of the account in state
 */
export type DecodedCosmosTxSignDoc = [
    atu8_body_bytes?: Uint8Array,
    atu8_auth_info_bytes?: Uint8Array,
    si_chain?: string,
    sg_account_number?: CwUint64
];
/**
 * Decodes a protobuf SignDoc message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosTxSignDoc}
 */
export declare const decodeCosmosTxSignDoc: (atu8_payload: Uint8Array) => DecodedCosmosTxSignDoc;
/**
 * A decoded protobuf SignDocDirectAux message
 *
 * Tuple where:
 *   - 0: body_bytes - protobuf serialization of a TxBody that matches the representation in TxRaw.
 *   - 1: public_key - the public key of the signing account.
 *   - 2: chain_id - the identifier of the chain this transaction targets. It prevents signed transactions from being used on another chain by an attacker.
 *   - 3: account_number - the account number of the account in state.
 *   - 4: sequence - the sequence number of the signing account.
 *   - 5: tip - s have been depreacted and should not be used
 */
export type DecodedCosmosTxSignDocDirectAux = [
    atu8_body_bytes?: Uint8Array,
    a_public_key?: DecodedGoogleProtobufAny,
    si_chain?: string,
    sg_account_number?: CwUint64,
    sg_sequence?: CwUint64,
    a_tip?: DecodedCosmosTxTip
];
/**
 * Decodes a protobuf SignDocDirectAux message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosTxSignDocDirectAux}
 */
export declare const decodeCosmosTxSignDocDirectAux: (atu8_payload: Uint8Array) => DecodedCosmosTxSignDocDirectAux;
/**
 * A decoded protobuf TxBody message
 *
 * Tuple where:
 *   - 0: messages - a list of messages to be executed. The required signers of those messages define the number and order of elements in AuthInfo's signer_infos and Tx's signatures. Each required signer address is added to the list only the first time it occurs. By convention, the first required signer (usually from the first message) is referred to as the primary signer and pays the fee for the whole transaction.
 *   - 1: memo - any arbitrary note/comment to be added to the transaction. WARNING: in clients, any publicly exposed text should not be called memo, but should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122).
 *   - 2: timeout_height - timeout is the block height after which this transaction will not be processed by the chain
 *  - 1022: extension_options - arbitrary options that can be added by chains when the default options are not sufficient. If any of these are present and can't be handled, the transaction will be rejected
 *  - 2046: non_critical_extension_options - extension_options are arbitrary options that can be added by chains when the default options are not sufficient. If any of these are present and can't be handled, they will be ignored
 */
export type DecodedCosmosTxTxBody = [
    a_messages?: DecodedGoogleProtobufAny[],
    s_memo?: string,
    sg_timeout_height?: CwUint64
] & {
    1022?: DecodedGoogleProtobufAny[];
    2046?: DecodedGoogleProtobufAny[];
};
/**
 * Decodes a protobuf TxBody message
 * @param atu8_payload - raw bytes to decode
 * @param RESERVED - a second argument is explicitly forbidden. make sure not to pass this function by reference to some callback argument
 * @returns a {@link DecodedCosmosTxTxBody}
 */
export declare const decodeCosmosTxTxBody: (atu8_payload: Uint8Array, RESERVED?: never) => DecodedCosmosTxTxBody;
/**
 * A decoded protobuf AuthInfo message
 *
 * Tuple where:
 *   - 0: signer_infos - defines the signing modes for the required signers. The number and order of elements must match the required signers from TxBody's messages. The first element is the primary signer and the one which pays the fee.
 *   - 1: fee - Fee is the fee and gas limit for the transaction. The first signer is the primary signer and the one which pays the fee. The fee can be calculated based on the cost of evaluating the body and doing signature verification of the signers. This can be estimated via simulation.
 *   - 2: tip - Tip is the optional tip used for transactions fees paid in another denom. This field is ignored if the chain didn't enable tips, i.e. didn't add the `TipDecorator` in its posthandler. Since: cosmos-sdk 0.46
 */
export type DecodedCosmosTxAuthInfo = [
    a_signer_infos?: DecodedCosmosTxSignerInfo[],
    a_fee?: DecodedCosmosTxFee,
    a_tip?: DecodedCosmosTxTip
];
/**
 * Decodes a protobuf AuthInfo message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosTxAuthInfo}
 */
export declare const decodeCosmosTxAuthInfo: (atu8_payload: Uint8Array) => DecodedCosmosTxAuthInfo;
/**
 * A decoded protobuf SignerInfo message
 *
 * Tuple where:
 *   - 0: public_key - the public key of the signer. It is optional for accounts that already exist in state. If unset, the verifier can use the required \ signer address for this position and lookup the public key.
 *   - 1: mode_info - describes the signing mode of the signer and is a nested structure to support nested multisig pubkey's
 *   - 2: sequence - the sequence of the account, which describes the number of committed transactions signed by a given address. It is used to prevent replay attacks.
 */
export type DecodedCosmosTxSignerInfo = [
    a_public_key?: DecodedGoogleProtobufAny,
    a_mode_info?: DecodedCosmosTxModeInfo,
    sg_sequence?: CwUint64
];
/**
 * Decodes a protobuf SignerInfo message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosTxSignerInfo}
 */
export declare const decodeCosmosTxSignerInfo: (atu8_payload: Uint8Array) => DecodedCosmosTxSignerInfo;
/**
 * A decoded protobuf ModeInfo message
 *
 * Tuple where:
 *   - 0: single - represents a single signer
 *   - 1: multi - represents a nested multisig signer
 */
export type DecodedCosmosTxModeInfo = [
    a_single?: DecodedCosmosTxModeInfoSingle,
    a_multi?: DecodedCosmosTxModeInfoMulti
];
/**
 * Decodes a protobuf ModeInfo message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosTxModeInfo}
 */
export declare const decodeCosmosTxModeInfo: (atu8_payload: Uint8Array) => DecodedCosmosTxModeInfo;
/**
 * A decoded protobuf Fee message
 *
 * Tuple where:
 *   - 0: amount - the amount of coins to be paid as a fee
 *   - 1: gas_limit - the maximum gas that can be used in transaction processing before an out of gas error occurs
 *   - 2: payer - if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees. the payer must be a tx signer (and thus have signed this field in AuthInfo). setting this field does *not* change the ordering of required signers for the transaction.
 *   - 3: granter - if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used to pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does not support fee grants, this will fail
 */
export type DecodedCosmosTxFee = [
    a_amount?: [
        string,
        string
    ][],
    sg_gas_limit?: CwUint64,
    sa_payer?: CwAccountAddr,
    sa_granter?: CwAccountAddr
];
/**
 * Decodes a protobuf Fee message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosTxFee}
 */
export declare const decodeCosmosTxFee: (atu8_payload: Uint8Array) => DecodedCosmosTxFee;
/**
 * A decoded protobuf Tip message
 *
 * Tuple where:
 *   - 0: amount - the amount of the tip
 *   - 1: tipper - the address of the account paying for the tip
 */
export type DecodedCosmosTxTip = [
    a_amount?: [
        string,
        string
    ][],
    s_tipper?: string
];
/**
 * Decodes a protobuf Tip message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosTxTip}
 */
export declare const decodeCosmosTxTip: (atu8_payload: Uint8Array) => DecodedCosmosTxTip;
/**
 * A decoded protobuf AuxSignerData message
 *
 * Tuple where:
 *   - 0: address - the bech32-encoded address of the auxiliary signer. If using AuxSignerData across different chains, the bech32 prefix of the target chain (where the final transaction is broadcasted) should be used.
 *   - 1: sign_doc - the SIGN_MODE_DIRECT_AUX sign doc that the auxiliary signer signs. Note: we use the same sign doc even if we're signing with LEGACY_AMINO_JSON.
 *   - 2: mode - the signing mode of the single signer.
 *   - 3: sig - the signature of the sign doc.
 */
export type DecodedCosmosTxAuxSignerData = [
    sa_address?: CwAccountAddr,
    a_sign_doc?: DecodedCosmosTxSignDocDirectAux,
    xc_mode?: ProtoEnumCosmosTxSigningSignMode,
    atu8_sig?: Uint8Array
];
/**
 * Decodes a protobuf AuxSignerData message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosTxAuxSignerData}
 */
export declare const decodeCosmosTxAuxSignerData: (atu8_payload: Uint8Array) => DecodedCosmosTxAuxSignerData;
/**
 * A decoded protobuf Single message
 *
 * Alias for: mode -
 */
export type DecodedCosmosTxModeInfoSingle = [
    xc_mode?: ProtoEnumCosmosTxSigningSignMode
];
/**
 * Decodes a protobuf Single message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosTxModeInfoSingle}
 */
export declare const decodeCosmosTxModeInfoSingle: (atu8_payload: Uint8Array) => DecodedCosmosTxModeInfoSingle;
/**
 * A decoded protobuf Multi message
 *
 * Tuple where:
 *   - 0: bitarray -
 *   - 1: mode_infos -
 */
export type DecodedCosmosTxModeInfoMulti = [
    a_bitarray?: DecodedCosmosCryptoMultisigCompactBitArray,
    a_mode_infos?: DecodedCosmosTxModeInfo[]
];
/**
 * Decodes a protobuf Multi message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosTxModeInfoMulti}
 */
export declare const decodeCosmosTxModeInfoMulti: (atu8_payload: Uint8Array) => DecodedCosmosTxModeInfoMulti;
/**
 * Destructures the fields of a {@link CosmosTxTx} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: body - the processable content of the transaction
 *   - 1: auth_info - the authorization related content of the transaction, specifically signers, signer modes and fee
 *   - 2: signatures - a list of signatures that matches the length and order of AuthInfo's signer_infos to allow connecting signature meta information like public key and signing mode by position.
 */
export declare const destructCosmosTxTx: (g_struct: CosmosTxTx) => [body?: CosmosTxTxBody, auth_info?: CosmosTxAuthInfo, signatures?: Uint8Array[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_TX_TX = "/cosmos.tx.v1beta1.Tx";
/**
 * JSON serialization of `cosmos.tx.v1beta1.Tx` - the standard type used for broadcasting transactions.
 */
export type CosmosTxTx = {
    body?: CosmosTxTxBody | undefined;
    auth_info?: CosmosTxAuthInfo | undefined;
    signatures?: CwBase64[] | undefined;
};
/**
 * Destructures the fields of a {@link CosmosTxTxBody} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: messages - a list of messages to be executed. The required signers of those messages define the number and order of elements in AuthInfo's signer_infos and Tx's signatures. Each required signer address is added to the list only the first time it occurs. By convention, the first required signer (usually from the first message) is referred to as the primary signer and pays the fee for the whole transaction.
 *   - 1: memo - any arbitrary note/comment to be added to the transaction. WARNING: in clients, any publicly exposed text should not be called memo, but should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122).
 *   - 2: timeout_height - timeout is the block height after which this transaction will not be processed by the chain
 *   - 1022: extension_options - arbitrary options that can be added by chains when the default options are not sufficient. If any of these are present and can't be handled, the transaction will be rejected
 *   - 2046: non_critical_extension_options - extension_options are arbitrary options that can be added by chains when the default options are not sufficient. If any of these are present and can't be handled, they will be ignored
 */
export declare const destructCosmosTxTxBody: (g_struct: CosmosTxTxBody) => [messages?: JsonAny[], memo?: string, timeout_height?: CwUint64] & {
    1023?: JsonAny[];
    2047?: JsonAny[];
};
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_TX_TX_BODY = "/cosmos.tx.v1beta1.TxBody";
/**
 * JSON serialization of `cosmos.tx.v1beta1.TxBody` - the body of a transaction that all signers sign over.
 */
export type CosmosTxTxBody = {
    messages?: JsonAny[] | undefined;
    memo?: string | undefined;
    timeout_height?: CwUint64 | undefined;
    extension_options?: JsonAny[] | undefined;
    non_critical_extension_options?: JsonAny[] | undefined;
};
/**
 * Destructures the fields of a {@link CosmosTxAuthInfo} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: signer_infos - defines the signing modes for the required signers. The number and order of elements must match the required signers from TxBody's messages. The first element is the primary signer and the one which pays the fee.
 *   - 1: fee - Fee is the fee and gas limit for the transaction. The first signer is the primary signer and the one which pays the fee. The fee can be calculated based on the cost of evaluating the body and doing signature verification of the signers. This can be estimated via simulation.
 *   - 2: tip - Tip is the optional tip used for transactions fees paid in another denom. This field is ignored if the chain didn't enable tips, i.e. didn't add the `TipDecorator` in its posthandler. Since: cosmos-sdk 0.46
 */
export declare const destructCosmosTxAuthInfo: (g_struct: CosmosTxAuthInfo) => [signer_infos?: CosmosTxSignerInfo[], fee?: CosmosTxFee, tip?: CosmosTxTip];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_TX_AUTH_INFO = "/cosmos.tx.v1beta1.AuthInfo";
/**
 * JSON serialization of `cosmos.tx.v1beta1.AuthInfo` - describes the fee and signer modes that are used to sign a transaction.
 */
export type CosmosTxAuthInfo = {
    signer_infos?: CosmosTxSignerInfo[] | undefined;
    fee?: CosmosTxFee | undefined;
    tip?: CosmosTxTip | undefined;
};
/**
 * Destructures the fields of a {@link CosmosTxSignerInfo} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: public_key - the public key of the signer. It is optional for accounts that already exist in state. If unset, the verifier can use the required \ signer address for this position and lookup the public key.
 *   - 1: mode_info - describes the signing mode of the signer and is a nested structure to support nested multisig pubkey's
 *   - 2: sequence - the sequence of the account, which describes the number of committed transactions signed by a given address. It is used to prevent replay attacks.
 */
export declare const destructCosmosTxSignerInfo: (g_struct: CosmosTxSignerInfo) => [public_key?: JsonAny, mode_info?: CosmosTxModeInfo, sequence?: CwUint64];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_TX_SIGNER_INFO = "/cosmos.tx.v1beta1.SignerInfo";
/**
 * JSON serialization of `cosmos.tx.v1beta1.SignerInfo` - describes the public key and signing mode of a single top-level signer.
 */
export type CosmosTxSignerInfo = {
    public_key?: JsonAny | undefined;
    mode_info?: CosmosTxModeInfo | undefined;
    sequence?: CwUint64 | undefined;
};
/**
 * Destructures the fields of a {@link CosmosTxModeInfo} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: single - represents a single signer
 *   - 1: multi - represents a nested multisig signer
 */
export declare const destructCosmosTxModeInfo: (g_struct: CosmosTxModeInfo) => [single?: CosmosTxModeInfoSingle, multi?: CosmosTxModeInfoMulti];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_TX_MODE_INFO = "/cosmos.tx.v1beta1.ModeInfo";
/**
 * JSON serialization of `cosmos.tx.v1beta1.ModeInfo` - describes the signing mode of a single or nested multisig signer.
 */
export type CosmosTxModeInfo = {
    single?: CosmosTxModeInfoSingle | undefined;
    multi?: CosmosTxModeInfoMulti | undefined;
};
/**
 * Destructures the fields of a {@link CosmosTxModeInfoSingle} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: mode -
 */
export declare const destructCosmosTxModeInfoSingle: (g_struct: CosmosTxModeInfoSingle) => [mode?: JsonEnumCosmosTxSigningSignMode];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_TX_MODE_INFO_SINGLE = "/cosmos.tx.v1beta1.ModeInfo.Single";
/**
 * JSON serialization of `cosmos.tx.v1beta1.ModeInfo.Single` -
 */
export type CosmosTxModeInfoSingle = {
    mode?: JsonEnumCosmosTxSigningSignMode | undefined;
};
/**
 * Destructures the fields of a {@link CosmosTxModeInfoMulti} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: bitarray -
 *   - 1: mode_infos -
 */
export declare const destructCosmosTxModeInfoMulti: (g_struct: CosmosTxModeInfoMulti) => [bitarray?: CosmosCryptoMultisigCompactBitArray, mode_infos?: CosmosTxModeInfo[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_TX_MODE_INFO_MULTI = "/cosmos.tx.v1beta1.ModeInfo.Multi";
/**
 * JSON serialization of `cosmos.tx.v1beta1.ModeInfo.Multi` -
 */
export type CosmosTxModeInfoMulti = {
    bitarray?: CosmosCryptoMultisigCompactBitArray | undefined;
    mode_infos?: CosmosTxModeInfo[] | undefined;
};
/**
 * Destructures the fields of a {@link CosmosTxFee} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: amount - the amount of coins to be paid as a fee
 *   - 1: gas_limit - the maximum gas that can be used in transaction processing before an out of gas error occurs
 *   - 2: payer - if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees. the payer must be a tx signer (and thus have signed this field in AuthInfo). setting this field does *not* change the ordering of required signers for the transaction.
 *   - 3: granter - if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used to pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does not support fee grants, this will fail
 */
export declare const destructCosmosTxFee: (g_struct: CosmosTxFee) => [amount?: CosmosBaseCoin[], gas_limit?: CwUint64, payer?: CwAccountAddr, granter?: CwAccountAddr];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_TX_FEE = "/cosmos.tx.v1beta1.Fee";
/**
 * JSON serialization of `cosmos.tx.v1beta1.Fee` - includes the amount of coins paid in fees and the maximum gas to be used by the transaction. The ratio yields an effective "gasprice", which must be above some miminum to be accepted into the mempool.
 */
export type CosmosTxFee = {
    amount?: CosmosBaseCoin[] | undefined;
    gas_limit?: CwUint64 | undefined;
    payer?: CwAccountAddr | undefined;
    granter?: CwAccountAddr | undefined;
};
/**
 * Destructures the fields of a {@link CosmosTxTip} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: amount - the amount of the tip
 *   - 1: tipper - the address of the account paying for the tip
 */
export declare const destructCosmosTxTip: (g_struct: CosmosTxTip) => [amount?: CosmosBaseCoin[], tipper?: string];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_TX_TIP = "/cosmos.tx.v1beta1.Tip";
/**
 * JSON serialization of `cosmos.tx.v1beta1.Tip` - the tip used for meta-transactions. Since: cosmos-sdk 0.46
 */
export type CosmosTxTip = {
    amount?: CosmosBaseCoin[] | undefined;
    tipper?: string | undefined;
};
/**
 * Destructures the fields of a {@link CosmosTxTxRaw} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: body_bytes - a protobuf serialization of a TxBody that matches the representation in SignDoc.
 *   - 1: auth_info_bytes - a protobuf serialization of an AuthInfo that matches the representation in SignDoc.
 *   - 2: signatures - a list of signatures that matches the length and order of AuthInfo's signer_infos to allow connecting signature meta information like public key and signing mode by position.
 */
export declare const destructCosmosTxTxRaw: (g_struct: CosmosTxTxRaw) => [body_bytes?: Uint8Array, auth_info_bytes?: Uint8Array, signatures?: Uint8Array[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_TX_TX_RAW = "/cosmos.tx.v1beta1.TxRaw";
/**
 * JSON serialization of `cosmos.tx.v1beta1.TxRaw` - a variant of Tx that pins the signer's exact binary representation of body and auth_info. This is used for signing, broadcasting and verification. The binary `serialize(tx: TxRaw)` is stored in Tendermint and the hash `sha256(serialize(tx: TxRaw))` becomes the "txhash", commonly used as the transaction ID.
 */
export type CosmosTxTxRaw = {
    body_bytes?: CwBase64 | undefined;
    auth_info_bytes?: CwBase64 | undefined;
    signatures?: CwBase64[] | undefined;
};
/**
 * Destructures the fields of a {@link CosmosTxSignDoc} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: body_bytes - protobuf serialization of a TxBody that matches the representation in TxRaw.
 *   - 1: auth_info_bytes - a protobuf serialization of an AuthInfo that matches the representation in TxRaw.
 *   - 2: chain_id - the unique identifier of the chain this transaction targets. It prevents signed transactions from being used on another chain by an attacker
 *   - 3: account_number - the account number of the account in state
 */
export declare const destructCosmosTxSignDoc: (g_struct: CosmosTxSignDoc) => [body_bytes?: Uint8Array, auth_info_bytes?: Uint8Array, chain_id?: string, account_number?: CwUint64];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_TX_SIGN_DOC = "/cosmos.tx.v1beta1.SignDoc";
/**
 * JSON serialization of `cosmos.tx.v1beta1.SignDoc` - the type used for generating sign bytes for SIGN_MODE_DIRECT.
 */
export type CosmosTxSignDoc = {
    body_bytes?: CwBase64 | undefined;
    auth_info_bytes?: CwBase64 | undefined;
    chain_id?: string | undefined;
    account_number?: CwUint64 | undefined;
};
/**
 * Destructures the fields of a {@link CosmosTxSignDocDirectAux} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: body_bytes - protobuf serialization of a TxBody that matches the representation in TxRaw.
 *   - 1: public_key - the public key of the signing account.
 *   - 2: chain_id - the identifier of the chain this transaction targets. It prevents signed transactions from being used on another chain by an attacker.
 *   - 3: account_number - the account number of the account in state.
 *   - 4: sequence - the sequence number of the signing account.
 *   - 5: tip - s have been depreacted and should not be used
 */
export declare const destructCosmosTxSignDocDirectAux: (g_struct: CosmosTxSignDocDirectAux) => [body_bytes?: Uint8Array, public_key?: JsonAny, chain_id?: string, account_number?: CwUint64, sequence?: CwUint64, tip?: CosmosTxTip];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_TX_SIGN_DOC_DIRECT_AUX = "/cosmos.tx.v1beta1.SignDocDirectAux";
/**
 * JSON serialization of `cosmos.tx.v1beta1.SignDocDirectAux` - the type used for generating sign bytes for SIGN_MODE_DIRECT_AUX. Since: cosmos-sdk 0.46
 */
export type CosmosTxSignDocDirectAux = {
    body_bytes?: CwBase64 | undefined;
    public_key?: JsonAny | undefined;
    chain_id?: string | undefined;
    account_number?: CwUint64 | undefined;
    sequence?: CwUint64 | undefined;
    tip?: CosmosTxTip | undefined;
};
/**
 * Destructures the fields of a {@link CosmosTxAuxSignerData} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: address - the bech32-encoded address of the auxiliary signer. If using AuxSignerData across different chains, the bech32 prefix of the target chain (where the final transaction is broadcasted) should be used.
 *   - 1: sign_doc - the SIGN_MODE_DIRECT_AUX sign doc that the auxiliary signer signs. Note: we use the same sign doc even if we're signing with LEGACY_AMINO_JSON.
 *   - 2: mode - the signing mode of the single signer.
 *   - 3: sig - the signature of the sign doc.
 */
export declare const destructCosmosTxAuxSignerData: (g_struct: CosmosTxAuxSignerData) => [address?: CwAccountAddr, sign_doc?: CosmosTxSignDocDirectAux, mode?: JsonEnumCosmosTxSigningSignMode, sig?: Uint8Array];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_COSMOS_TX_AUX_SIGNER_DATA = "/cosmos.tx.v1beta1.AuxSignerData";
/**
 * JSON serialization of `cosmos.tx.v1beta1.AuxSignerData` - the intermediary format that an auxiliary signer (e.g. a tipper) builds and sends to the fee payer (who will build and broadcast the actual tx). AuxSignerData is not a valid tx in itself, and will be rejected by the node if sent directly as-is. Since: cosmos-sdk 0.46
 */
export type CosmosTxAuxSignerData = {
    address?: CwAccountAddr | undefined;
    sign_doc?: CosmosTxSignDocDirectAux | undefined;
    mode?: JsonEnumCosmosTxSigningSignMode | undefined;
    sig?: CwBase64 | undefined;
};
