import { oda } from '@blake.regalia/belt';
import { decode_protobuf, decode_coin } from '../../../../api/protobuf-reader.js';
import { Protobuf, map, coins } from '../../../../api/protobuf-writer.js';
import { safe_base64_to_bytes } from '../../../../api/util.js';
import { decodeCosmosCryptoMultisigCompactBitArray } from '../../crypto/multisig/v1beta1/multisig.js';
import { decodeGoogleProtobufAny } from '../../../google/protobuf/any.js';
/**
 * Encodes a `Tx` protobuf message: the standard type used for broadcasting transactions.
 * @param g_body - `body`: the processable content of the transaction
 * @param g_auth_info - `auth_info`: the authorization related content of the transaction, specifically signers, signer modes and fee
 * @param a_signatures - `signatures`: a list of signatures that matches the length and order of AuthInfo's signer_infos to allow connecting signature meta information like public key and signing mode by position.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosTxTx = (atu8_body, atu8_auth_info, a_signatures) => Protobuf() // ...
    .b(atu8_body) // TxBody body = 1
    .b(atu8_auth_info) // AuthInfo auth_info = 2
    .B(a_signatures) // bytes[] signatures = 3
    .o;
/**
 * Encodes a `TxRaw` protobuf message: a variant of Tx that pins the signer's exact binary representation of body and auth_info. This is used for signing, broadcasting and verification. The binary `serialize(tx: TxRaw)` is stored in Tendermint and the hash `sha256(serialize(tx: TxRaw))` becomes the "txhash", commonly used as the transaction ID.
 * @param atu8_body_bytes - `body_bytes`: a protobuf serialization of a TxBody that matches the representation in SignDoc.
 * @param atu8_auth_info_bytes - `auth_info_bytes`: a protobuf serialization of an AuthInfo that matches the representation in SignDoc.
 * @param a_signatures - `signatures`: a list of signatures that matches the length and order of AuthInfo's signer_infos to allow connecting signature meta information like public key and signing mode by position.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosTxTxRaw = (atu8_body_bytes, atu8_auth_info_bytes, a_signatures) => Protobuf() // ...
    .b(atu8_body_bytes) // bytes body_bytes = 1
    .b(atu8_auth_info_bytes) // bytes auth_info_bytes = 2
    .B(a_signatures) // bytes[] signatures = 3
    .o;
/**
 * Encodes a `SignDoc` protobuf message: the type used for generating sign bytes for SIGN_MODE_DIRECT.
 * @param atu8_body_bytes - `body_bytes`: protobuf serialization of a TxBody that matches the representation in TxRaw.
 * @param atu8_auth_info_bytes - `auth_info_bytes`: a protobuf serialization of an AuthInfo that matches the representation in TxRaw.
 * @param si_chain - `chain_id`: the unique identifier of the chain this transaction targets. It prevents signed transactions from being used on another chain by an attacker
 * @param sg_account_number - `account_number`: the account number of the account in state
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosTxSignDoc = (atu8_body_bytes, atu8_auth_info_bytes, si_chain, sg_account_number) => Protobuf() // ...
    .b(atu8_body_bytes) // bytes body_bytes = 1
    .b(atu8_auth_info_bytes) // bytes auth_info_bytes = 2
    .s(si_chain) // string chain_id = 3
    .g(sg_account_number) // uint64 account_number = 4
    .o;
/**
 * Encodes a `SignDocDirectAux` protobuf message: the type used for generating sign bytes for SIGN_MODE_DIRECT_AUX. Since: cosmos-sdk 0.46
 * @param atu8_body_bytes - `body_bytes`: protobuf serialization of a TxBody that matches the representation in TxRaw.
 * @param atu8_public_key - `public_key`: the public key of the signing account.
 * @param si_chain - `chain_id`: the identifier of the chain this transaction targets. It prevents signed transactions from being used on another chain by an attacker.
 * @param sg_account_number - `account_number`: the account number of the account in state.
 * @param sg_sequence - `sequence`: the sequence number of the signing account.
 * @param g_tip - `tip`: s have been depreacted and should not be used
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosTxSignDocDirectAux = (atu8_body_bytes, atu8_public_key, si_chain, sg_account_number, sg_sequence, atu8_tip) => Protobuf() // ...
    .b(atu8_body_bytes) // bytes body_bytes = 1
    .b(atu8_public_key) // Any public_key = 2
    .s(si_chain) // string chain_id = 3
    .g(sg_account_number) // uint64 account_number = 4
    .g(sg_sequence) // uint64 sequence = 5
    .b(atu8_tip) // Tip tip = 6
    .o;
/**
 * Encodes a `TxBody` protobuf message: the body of a transaction that all signers sign over.
 * @param a_messages - `messages`: a list of messages to be executed. The required signers of those messages define the number and order of elements in AuthInfo's signer_infos and Tx's signatures. Each required signer address is added to the list only the first time it occurs. By convention, the first required signer (usually from the first message) is referred to as the primary signer and pays the fee for the whole transaction.
 * @param s_memo - `memo`: any arbitrary note/comment to be added to the transaction. WARNING: in clients, any publicly exposed text should not be called memo, but should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122).
 * @param sg_timeout_height - `timeout_height`: timeout is the block height after which this transaction will not be processed by the chain
 * @param a_extension_options - `extension_options`: arbitrary options that can be added by chains when the default options are not sufficient. If any of these are present and can't be handled, the transaction will be rejected
 * @param a_non_critical_extension_options - `non_critical_extension_options`: extension_options are arbitrary options that can be added by chains when the default options are not sufficient. If any of these are present and can't be handled, they will be ignored
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosTxTxBody = (a_messages, s_memo, sg_timeout_height, a_extension_options, a_non_critical_extension_options) => Protobuf() // ...
    .B(a_messages) // Any[] messages = 1
    .s(s_memo) // string memo = 2
    .g(sg_timeout_height) // uint64 timeout_height = 3
    .B(a_extension_options, 1023) // Any[] extension_options = 1023
    .B(a_non_critical_extension_options, 2047) // Any[] non_critical_extension_options = 2047
    .o;
/**
 * Encodes a `AuthInfo` protobuf message: describes the fee and signer modes that are used to sign a transaction.
 * @param a_signer_infos - `signer_infos`: defines the signing modes for the required signers. The number and order of elements must match the required signers from TxBody's messages. The first element is the primary signer and the one which pays the fee.
 * @param g_fee - `fee`: Fee is the fee and gas limit for the transaction. The first signer is the primary signer and the one which pays the fee. The fee can be calculated based on the cost of evaluating the body and doing signature verification of the signers. This can be estimated via simulation.
 * @param g_tip - `tip`: Tip is the optional tip used for transactions fees paid in another denom. This field is ignored if the chain didn't enable tips, i.e. didn't add the `TipDecorator` in its posthandler. Since: cosmos-sdk 0.46
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosTxAuthInfo = (a_signer_infos, atu8_fee, atu8_tip) => Protobuf() // ...
    .B(a_signer_infos) // SignerInfo[] signer_infos = 1
    .b(atu8_fee) // Fee fee = 2
    .b(atu8_tip) // Tip tip = 3
    .o;
/**
 * Encodes a `SignerInfo` protobuf message: describes the public key and signing mode of a single top-level signer.
 * @param atu8_public_key - `public_key`: the public key of the signer. It is optional for accounts that already exist in state. If unset, the verifier can use the required \ signer address for this position and lookup the public key.
 * @param g_mode_info - `mode_info`: describes the signing mode of the signer and is a nested structure to support nested multisig pubkey's
 * @param sg_sequence - `sequence`: the sequence of the account, which describes the number of committed transactions signed by a given address. It is used to prevent replay attacks.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosTxSignerInfo = (atu8_public_key, atu8_mode_info, sg_sequence) => Protobuf() // ...
    .b(atu8_public_key) // Any public_key = 1
    .b(atu8_mode_info) // ModeInfo mode_info = 2
    .g(sg_sequence) // uint64 sequence = 3
    .o;
/**
 * Encodes a `ModeInfo` protobuf message: describes the signing mode of a single or nested multisig signer.
 * @param g_single - `single`: represents a single signer
 * @param g_multi - `multi`: represents a nested multisig signer
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosTxModeInfo = (atu8_single, atu8_multi) => Protobuf() // ...
    .b(atu8_single) // Single single = 1
    .b(atu8_multi) // Multi multi = 2
    .o;
/**
 * Encodes a `Fee` protobuf message: includes the amount of coins paid in fees and the maximum gas to be used by the transaction. The ratio yields an effective "gasprice", which must be above some miminum to be accepted into the mempool.
 * @param a_amounts - `amount`: the amount of coins to be paid as a fee
 * @param sg_gas_limit - `gas_limit`: the maximum gas that can be used in transaction processing before an out of gas error occurs
 * @param sa_payer - `payer`: if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees. the payer must be a tx signer (and thus have signed this field in AuthInfo). setting this field does *not* change the ordering of required signers for the transaction.
 * @param sa_granter - `granter`: if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used to pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does not support fee grants, this will fail
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosTxFee = (a_amounts, sg_gas_limit, sa_payer, sa_granter) => Protobuf() // ...
    .B(coins(a_amounts)) // Coin[] amount = 1
    .g(sg_gas_limit) // uint64 gas_limit = 2
    .s(sa_payer) // string payer = 3
    .s(sa_granter) // string granter = 4
    .o;
/**
 * Encodes a `Tip` protobuf message: the tip used for meta-transactions. Since: cosmos-sdk 0.46
 * @param a_amounts - `amount`: the amount of the tip
 * @param s_tipper - `tipper`: the address of the account paying for the tip
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosTxTip = (a_amounts, s_tipper) => Protobuf() // ...
    .B(coins(a_amounts)) // Coin[] amount = 1
    .s(s_tipper) // string tipper = 2
    .o;
/**
 * Encodes a `AuxSignerData` protobuf message: the intermediary format that an auxiliary signer (e.g. a tipper) builds and sends to the fee payer (who will build and broadcast the actual tx). AuxSignerData is not a valid tx in itself, and will be rejected by the node if sent directly as-is. Since: cosmos-sdk 0.46
 * @param sa_address - `address`: the bech32-encoded address of the auxiliary signer. If using AuxSignerData across different chains, the bech32 prefix of the target chain (where the final transaction is broadcasted) should be used.
 * @param g_sign_doc - `sign_doc`: the SIGN_MODE_DIRECT_AUX sign doc that the auxiliary signer signs. Note: we use the same sign doc even if we're signing with LEGACY_AMINO_JSON.
 * @param xc_mode - `mode`: the signing mode of the single signer.
 * @param atu8_sig - `sig`: the signature of the sign doc.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosTxAuxSignerData = (sa_address, atu8_sign_doc, xc_mode, atu8_sig) => Protobuf() // ...
    .s(sa_address) // string address = 1
    .b(atu8_sign_doc) // SignDocDirectAux sign_doc = 2
    .v(xc_mode) // SignMode mode = 3
    .b(atu8_sig) // bytes sig = 4
    .o;
/**
 * Encodes a `Single` protobuf message:
 * @param xc_mode - `mode`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosTxModeInfoSingle = (xc_mode) => Protobuf() // ...
    .v(xc_mode) // SignMode mode = 1
    .o;
/**
 * Encodes a `Multi` protobuf message:
 * @param g_bitarray - `bitarray`:
 * @param a_mode_infos - `mode_infos`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeCosmosTxModeInfoMulti = (atu8_bitarray, a_mode_infos) => Protobuf() // ...
    .b(atu8_bitarray) // CompactBitArray bitarray = 1
    .B(a_mode_infos) // ModeInfo[] mode_infos = 2
    .o;
/**
 * Decodes a protobuf Tx message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosTxTx}
 */
export const decodeCosmosTxTx = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1, 0], [decodeCosmosTxTxBody, decodeCosmosTxAuthInfo]);
/**
 * Decodes a protobuf TxRaw message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosTxTxRaw}
 */
export const decodeCosmosTxTxRaw = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1, 0]);
/**
 * Decodes a protobuf SignDoc message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosTxSignDoc}
 */
export const decodeCosmosTxSignDoc = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1, 5, 3]);
/**
 * Decodes a protobuf SignDocDirectAux message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosTxSignDocDirectAux}
 */
export const decodeCosmosTxSignDocDirectAux = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1, 5, 3, 3, 1], [0, decodeGoogleProtobufAny, 0, 0, 0, decodeCosmosTxTip]);
/**
 * Decodes a protobuf TxBody message
 * @param atu8_payload - raw bytes to decode
 * @param RESERVED - a second argument is explicitly forbidden. make sure not to pass this function by reference to some callback argument
 * @returns a {@link DecodedCosmosTxTxBody}
 */
export const decodeCosmosTxTxBody = ((atu8_payload, a_decoded = decode_protobuf(atu8_payload, [0, 5, 3], [decodeGoogleProtobufAny, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, decodeGoogleProtobufAny, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, decodeGoogleProtobufAny]), { 1022: a_extension_options, 2046: a_non_critical_extension_options } = a_decoded, [a_messages, s_memo, sg_timeout_height] = a_decoded) => oda([a_messages, s_memo, sg_timeout_height], {
    1022: a_extension_options,
    2046: a_non_critical_extension_options,
}));
/**
 * Decodes a protobuf AuthInfo message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosTxAuthInfo}
 */
export const decodeCosmosTxAuthInfo = (atu8_payload) => decode_protobuf(atu8_payload, [0, 1, 1], [decodeCosmosTxSignerInfo, decodeCosmosTxFee, decodeCosmosTxTip]);
/**
 * Decodes a protobuf SignerInfo message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosTxSignerInfo}
 */
export const decodeCosmosTxSignerInfo = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1, 3], [decodeGoogleProtobufAny, decodeCosmosTxModeInfo]);
/**
 * Decodes a protobuf ModeInfo message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosTxModeInfo}
 */
export const decodeCosmosTxModeInfo = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1], [decodeCosmosTxModeInfoSingle, decodeCosmosTxModeInfoMulti]);
/**
 * Decodes a protobuf Fee message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosTxFee}
 */
export const decodeCosmosTxFee = (atu8_payload) => decode_protobuf(atu8_payload, [0, 3, 5, 5], [decode_coin]);
/**
 * Decodes a protobuf Tip message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosTxTip}
 */
export const decodeCosmosTxTip = (atu8_payload) => decode_protobuf(atu8_payload, [0, 5], [decode_coin]);
/**
 * Decodes a protobuf AuxSignerData message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosTxAuxSignerData}
 */
export const decodeCosmosTxAuxSignerData = (atu8_payload) => decode_protobuf(atu8_payload, [5, 1, 1, 1], [0, decodeCosmosTxSignDocDirectAux]);
/**
 * Decodes a protobuf Single message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosTxModeInfoSingle}
 */
export const decodeCosmosTxModeInfoSingle = (atu8_payload) => decode_protobuf(atu8_payload, [1]);
/**
 * Decodes a protobuf Multi message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedCosmosTxModeInfoMulti}
 */
export const decodeCosmosTxModeInfoMulti = (atu8_payload) => decode_protobuf(atu8_payload, [1, 0], [decodeCosmosCryptoMultisigCompactBitArray, decodeCosmosTxModeInfo]);
/**
 * Destructures the fields of a {@link CosmosTxTx} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: body - the processable content of the transaction
 *   - 1: auth_info - the authorization related content of the transaction, specifically signers, signer modes and fee
 *   - 2: signatures - a list of signatures that matches the length and order of AuthInfo's signer_infos to allow connecting signature meta information like public key and signing mode by position.
 */
export const destructCosmosTxTx = (g_struct) => [g_struct.body, g_struct.auth_info, map(g_struct.signatures, safe_base64_to_bytes)];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_TX_TX = '/cosmos.tx.v1beta1.Tx';
/**
 * Destructures the fields of a {@link CosmosTxTxBody} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: messages - a list of messages to be executed. The required signers of those messages define the number and order of elements in AuthInfo's signer_infos and Tx's signatures. Each required signer address is added to the list only the first time it occurs. By convention, the first required signer (usually from the first message) is referred to as the primary signer and pays the fee for the whole transaction.
 *   - 1: memo - any arbitrary note/comment to be added to the transaction. WARNING: in clients, any publicly exposed text should not be called memo, but should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122).
 *   - 2: timeout_height - timeout is the block height after which this transaction will not be processed by the chain
 *   - 1022: extension_options - arbitrary options that can be added by chains when the default options are not sufficient. If any of these are present and can't be handled, the transaction will be rejected
 *   - 2046: non_critical_extension_options - extension_options are arbitrary options that can be added by chains when the default options are not sufficient. If any of these are present and can't be handled, they will be ignored
 */
export const destructCosmosTxTxBody = (g_struct) => oda([g_struct.messages, g_struct.memo, g_struct.timeout_height], {
    1023: g_struct.extension_options,
    2047: g_struct.non_critical_extension_options,
});
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_TX_TX_BODY = '/cosmos.tx.v1beta1.TxBody';
/**
 * Destructures the fields of a {@link CosmosTxAuthInfo} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: signer_infos - defines the signing modes for the required signers. The number and order of elements must match the required signers from TxBody's messages. The first element is the primary signer and the one which pays the fee.
 *   - 1: fee - Fee is the fee and gas limit for the transaction. The first signer is the primary signer and the one which pays the fee. The fee can be calculated based on the cost of evaluating the body and doing signature verification of the signers. This can be estimated via simulation.
 *   - 2: tip - Tip is the optional tip used for transactions fees paid in another denom. This field is ignored if the chain didn't enable tips, i.e. didn't add the `TipDecorator` in its posthandler. Since: cosmos-sdk 0.46
 */
export const destructCosmosTxAuthInfo = (g_struct) => [g_struct.signer_infos, g_struct.fee, g_struct.tip];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_TX_AUTH_INFO = '/cosmos.tx.v1beta1.AuthInfo';
/**
 * Destructures the fields of a {@link CosmosTxSignerInfo} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: public_key - the public key of the signer. It is optional for accounts that already exist in state. If unset, the verifier can use the required \ signer address for this position and lookup the public key.
 *   - 1: mode_info - describes the signing mode of the signer and is a nested structure to support nested multisig pubkey's
 *   - 2: sequence - the sequence of the account, which describes the number of committed transactions signed by a given address. It is used to prevent replay attacks.
 */
export const destructCosmosTxSignerInfo = (g_struct) => [g_struct.public_key, g_struct.mode_info, g_struct.sequence];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_TX_SIGNER_INFO = '/cosmos.tx.v1beta1.SignerInfo';
/**
 * Destructures the fields of a {@link CosmosTxModeInfo} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: single - represents a single signer
 *   - 1: multi - represents a nested multisig signer
 */
export const destructCosmosTxModeInfo = (g_struct) => [g_struct.single, g_struct.multi];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_TX_MODE_INFO = '/cosmos.tx.v1beta1.ModeInfo';
/**
 * Destructures the fields of a {@link CosmosTxModeInfoSingle} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: mode -
 */
export const destructCosmosTxModeInfoSingle = (g_struct) => [g_struct.mode];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_TX_MODE_INFO_SINGLE = '/cosmos.tx.v1beta1.ModeInfo.Single';
/**
 * Destructures the fields of a {@link CosmosTxModeInfoMulti} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: bitarray -
 *   - 1: mode_infos -
 */
export const destructCosmosTxModeInfoMulti = (g_struct) => [g_struct.bitarray, g_struct.mode_infos];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_TX_MODE_INFO_MULTI = '/cosmos.tx.v1beta1.ModeInfo.Multi';
/**
 * Destructures the fields of a {@link CosmosTxFee} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: amount - the amount of coins to be paid as a fee
 *   - 1: gas_limit - the maximum gas that can be used in transaction processing before an out of gas error occurs
 *   - 2: payer - if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees. the payer must be a tx signer (and thus have signed this field in AuthInfo). setting this field does *not* change the ordering of required signers for the transaction.
 *   - 3: granter - if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used to pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does not support fee grants, this will fail
 */
export const destructCosmosTxFee = (g_struct) => [g_struct.amount, g_struct.gas_limit, g_struct.payer, g_struct.granter];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_TX_FEE = '/cosmos.tx.v1beta1.Fee';
/**
 * Destructures the fields of a {@link CosmosTxTip} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: amount - the amount of the tip
 *   - 1: tipper - the address of the account paying for the tip
 */
export const destructCosmosTxTip = (g_struct) => [g_struct.amount, g_struct.tipper];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_TX_TIP = '/cosmos.tx.v1beta1.Tip';
/**
 * Destructures the fields of a {@link CosmosTxTxRaw} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: body_bytes - a protobuf serialization of a TxBody that matches the representation in SignDoc.
 *   - 1: auth_info_bytes - a protobuf serialization of an AuthInfo that matches the representation in SignDoc.
 *   - 2: signatures - a list of signatures that matches the length and order of AuthInfo's signer_infos to allow connecting signature meta information like public key and signing mode by position.
 */
export const destructCosmosTxTxRaw = (g_struct) => [safe_base64_to_bytes(g_struct.body_bytes), safe_base64_to_bytes(g_struct.auth_info_bytes), map(g_struct.signatures, safe_base64_to_bytes)];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_TX_TX_RAW = '/cosmos.tx.v1beta1.TxRaw';
/**
 * Destructures the fields of a {@link CosmosTxSignDoc} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: body_bytes - protobuf serialization of a TxBody that matches the representation in TxRaw.
 *   - 1: auth_info_bytes - a protobuf serialization of an AuthInfo that matches the representation in TxRaw.
 *   - 2: chain_id - the unique identifier of the chain this transaction targets. It prevents signed transactions from being used on another chain by an attacker
 *   - 3: account_number - the account number of the account in state
 */
export const destructCosmosTxSignDoc = (g_struct) => [safe_base64_to_bytes(g_struct.body_bytes), safe_base64_to_bytes(g_struct.auth_info_bytes), g_struct.chain_id, g_struct.account_number];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_TX_SIGN_DOC = '/cosmos.tx.v1beta1.SignDoc';
/**
 * Destructures the fields of a {@link CosmosTxSignDocDirectAux} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: body_bytes - protobuf serialization of a TxBody that matches the representation in TxRaw.
 *   - 1: public_key - the public key of the signing account.
 *   - 2: chain_id - the identifier of the chain this transaction targets. It prevents signed transactions from being used on another chain by an attacker.
 *   - 3: account_number - the account number of the account in state.
 *   - 4: sequence - the sequence number of the signing account.
 *   - 5: tip - s have been depreacted and should not be used
 */
export const destructCosmosTxSignDocDirectAux = (g_struct) => [safe_base64_to_bytes(g_struct.body_bytes), g_struct.public_key, g_struct.chain_id, g_struct.account_number, g_struct.sequence, g_struct.tip];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_TX_SIGN_DOC_DIRECT_AUX = '/cosmos.tx.v1beta1.SignDocDirectAux';
/**
 * Destructures the fields of a {@link CosmosTxAuxSignerData} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: address - the bech32-encoded address of the auxiliary signer. If using AuxSignerData across different chains, the bech32 prefix of the target chain (where the final transaction is broadcasted) should be used.
 *   - 1: sign_doc - the SIGN_MODE_DIRECT_AUX sign doc that the auxiliary signer signs. Note: we use the same sign doc even if we're signing with LEGACY_AMINO_JSON.
 *   - 2: mode - the signing mode of the single signer.
 *   - 3: sig - the signature of the sign doc.
 */
export const destructCosmosTxAuxSignerData = (g_struct) => [g_struct.address, g_struct.sign_doc, g_struct.mode, safe_base64_to_bytes(g_struct.sig)];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_COSMOS_TX_AUX_SIGNER_DATA = '/cosmos.tx.v1beta1.AuxSignerData';
//# sourceMappingURL=tx.js.map