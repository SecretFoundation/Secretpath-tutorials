import type { WeakUint64Str, CwUint64, CwBase64 } from '@solar-republic/types';
import type { Encoded, Opt } from '../../../../../api/types.js';
import type { IbcCoreClientHeight, DecodedIbcCoreClientHeight } from '../../client/v1/client.js';
export type EncodedIbcCoreChannelChannel = Encoded<'/ibc.core.channel.v1.Channel'>;
export type EncodedIbcCoreChannelIdentifiedChannel = Encoded<'/ibc.core.channel.v1.IdentifiedChannel'>;
export type EncodedIbcCoreChannelCounterparty = Encoded<'/ibc.core.channel.v1.Counterparty'>;
export type EncodedIbcCoreChannelPacket = Encoded<'/ibc.core.channel.v1.Packet'>;
export type EncodedIbcCoreChannelPacketState = Encoded<'/ibc.core.channel.v1.PacketState'>;
export type EncodedIbcCoreChannelPacketId = Encoded<'/ibc.core.channel.v1.PacketId'>;
export type EncodedIbcCoreChannelAcknowledgement = Encoded<'/ibc.core.channel.v1.Acknowledgement'>;
export type EncodedIbcCoreChannelTimeout = Encoded<'/ibc.core.channel.v1.Timeout'>;
export type EncodedIbcCoreChannelParams = Encoded<'/ibc.core.channel.v1.Params'>;
/**
 * Encodes a `Channel` protobuf message: defines pipeline for exactly-once packet delivery between specific modules on separate blockchains, which has at least one end capable of sending packets and one end capable of receiving packets.
 * @param xc_state - `state`: current state of the channel end
 * @param xc_ordering - `ordering`: whether the channel is ordered or unordered
 * @param g_counterparty - `counterparty`: channel end
 * @param a_connection_hops - `connection_hops`: list of connection identifiers, in order, along which packets sent on this channel will travel
 * @param s_version - `version`: opaque channel version, which is agreed upon during the handshake
 * @param sg_upgrade_sequence - `upgrade_sequence`: upgrade sequence indicates the latest upgrade attempt performed by this channel the value of 0 indicates the channel has never been upgraded
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeIbcCoreChannelChannel: (xc_state?: Opt<ProtoEnumIbcCoreChannelState>, xc_ordering?: Opt<ProtoEnumIbcCoreChannelOrder>, atu8_counterparty?: Opt<Encoded<'/ibc.core.channel.v1.Counterparty'>>, a_connection_hops?: Opt<string[]>, s_version?: Opt<string>, sg_upgrade_sequence?: Opt<WeakUint64Str>) => EncodedIbcCoreChannelChannel;
/**
 * Encodes a `IdentifiedChannel` protobuf message: defines a channel with additional port and channel identifier fields.
 * @param xc_state - `state`: current state of the channel end
 * @param xc_ordering - `ordering`: whether the channel is ordered or unordered
 * @param g_counterparty - `counterparty`: channel end
 * @param a_connection_hops - `connection_hops`: list of connection identifiers, in order, along which packets sent on this channel will travel
 * @param s_version - `version`: opaque channel version, which is agreed upon during the handshake
 * @param si_port - `port_id`: port identifier
 * @param si_channel - `channel_id`: channel identifier
 * @param sg_upgrade_sequence - `upgrade_sequence`: upgrade sequence indicates the latest upgrade attempt performed by this channel the value of 0 indicates the channel has never been upgraded
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeIbcCoreChannelIdentifiedChannel: (xc_state?: Opt<ProtoEnumIbcCoreChannelState>, xc_ordering?: Opt<ProtoEnumIbcCoreChannelOrder>, atu8_counterparty?: Opt<Encoded<'/ibc.core.channel.v1.Counterparty'>>, a_connection_hops?: Opt<string[]>, s_version?: Opt<string>, si_port?: Opt<string>, si_channel?: Opt<string>, sg_upgrade_sequence?: Opt<WeakUint64Str>) => EncodedIbcCoreChannelIdentifiedChannel;
/**
 * Encodes a `Counterparty` protobuf message: defines a channel end counterparty
 * @param si_port - `port_id`: port on the counterparty chain which owns the other end of the channel.
 * @param si_channel - `channel_id`: channel end on the counterparty chain
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeIbcCoreChannelCounterparty: (si_port?: Opt<string>, si_channel?: Opt<string>) => EncodedIbcCoreChannelCounterparty;
/**
 * Encodes a `Packet` protobuf message: defines a type that carries data across different chains through IBC
 * @param sg_sequence - `sequence`: number corresponds to the order of sends and receives, where a Packet with an earlier sequence number must be sent and received before a Packet with a later sequence number.
 * @param s_source_port - `source_port`: identifies the port on the sending chain.
 * @param s_source_channel - `source_channel`: identifies the channel end on the sending chain.
 * @param s_destination_port - `destination_port`: identifies the port on the receiving chain.
 * @param s_destination_channel - `destination_channel`: identifies the channel end on the receiving chain.
 * @param atu8_data - `data`: actual opaque bytes transferred directly to the application module
 * @param g_timeout_height - `timeout_height`: block height after which the packet times out
 * @param sg_timeout_timestamp - `timeout_timestamp`: block timestamp (in nanoseconds) after which the packet times out
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeIbcCoreChannelPacket: (sg_sequence?: Opt<WeakUint64Str>, s_source_port?: Opt<string>, s_source_channel?: Opt<string>, s_destination_port?: Opt<string>, s_destination_channel?: Opt<string>, atu8_data?: Opt<Uint8Array>, atu8_timeout_height?: Opt<Encoded<'/ibc.core.client.v1.Height'>>, sg_timeout_timestamp?: Opt<WeakUint64Str>) => EncodedIbcCoreChannelPacket;
/**
 * Encodes a `PacketState` protobuf message: defines the generic type necessary to retrieve and store packet commitments, acknowledgements, and receipts. Caller is responsible for knowing the context necessary to interpret this state as a commitment, acknowledgement, or a receipt.
 * @param si_port - `port_id`: channel port identifier.
 * @param si_channel - `channel_id`: channel unique identifier.
 * @param sg_sequence - `sequence`: packet sequence.
 * @param atu8_data - `data`: embedded data that represents packet state.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeIbcCoreChannelPacketState: (si_port?: Opt<string>, si_channel?: Opt<string>, sg_sequence?: Opt<WeakUint64Str>, atu8_data?: Opt<Uint8Array>) => EncodedIbcCoreChannelPacketState;
/**
 * Encodes a `PacketId` protobuf message: an identifier for a unique Packet Source chains refer to packets by source port/channel Destination chains refer to packets by destination port/channel
 * @param si_port - `port_id`: channel port identifier
 * @param si_channel - `channel_id`: channel unique identifier
 * @param sg_sequence - `sequence`: packet sequence
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeIbcCoreChannelPacketId: (si_port?: Opt<string>, si_channel?: Opt<string>, sg_sequence?: Opt<WeakUint64Str>) => EncodedIbcCoreChannelPacketId;
/**
 * Encodes a `Acknowledgement` protobuf message: the recommended acknowledgement format to be used by app-specific protocols. NOTE: The field numbers 21 and 22 were explicitly chosen to avoid accidental conflicts with other protobuf message formats used for acknowledgements. The first byte of any message with this format will be the non-ASCII values `0xaa` (result) or `0xb2` (error). Implemented as defined by ICS: https://github.com/cosmos/ibc/tree/master/spec/core/ics-004-channel-and-packet-semantics#acknowledgement-envelope
 * @param atu8_result - `result`:
 * @param s_error - `error`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeIbcCoreChannelAcknowledgement: (atu8_result?: Opt<Uint8Array>, s_error?: Opt<string>) => EncodedIbcCoreChannelAcknowledgement;
/**
 * Encodes a `Timeout` protobuf message: defines an execution deadline structure for 04-channel handlers. This includes packet lifecycle handlers as well as the upgrade handshake handlers. A valid Timeout contains either one or both of a timestamp and block height (sequence).
 * @param g_height - `height`: block height after which the packet or upgrade times out
 * @param sg_timestamp - `timestamp`: block timestamp (in nanoseconds) after which the packet or upgrade times out
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeIbcCoreChannelTimeout: (atu8_height?: Opt<Encoded<'/ibc.core.client.v1.Height'>>, sg_timestamp?: Opt<WeakUint64Str>) => EncodedIbcCoreChannelTimeout;
/**
 * Encodes a `Params` protobuf message: defines the set of IBC channel parameters.
 * @param g_upgrade_timeout - `upgrade_timeout`: the relative timeout after which channel upgrades will time out.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeIbcCoreChannelParams: (atu8_upgrade_timeout?: Opt<Encoded<'/ibc.core.channel.v1.Timeout'>>) => EncodedIbcCoreChannelParams;
/**
 * A decoded protobuf Channel message
 *
 * Tuple where:
 *   - 0: state - current state of the channel end
 *   - 1: ordering - whether the channel is ordered or unordered
 *   - 2: counterparty - channel end
 *   - 3: connection_hops - list of connection identifiers, in order, along which packets sent on this channel will travel
 *   - 4: version - opaque channel version, which is agreed upon during the handshake
 *   - 5: upgrade_sequence - upgrade sequence indicates the latest upgrade attempt performed by this channel the value of 0 indicates the channel has never been upgraded
 */
export type DecodedIbcCoreChannelChannel = [
    xc_state?: ProtoEnumIbcCoreChannelState,
    xc_ordering?: ProtoEnumIbcCoreChannelOrder,
    a_counterparty?: DecodedIbcCoreChannelCounterparty,
    a_connection_hops?: string[],
    s_version?: string,
    sg_upgrade_sequence?: CwUint64
];
/**
 * Decodes a protobuf Channel message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcCoreChannelChannel}
 */
export declare const decodeIbcCoreChannelChannel: (atu8_payload: Uint8Array) => DecodedIbcCoreChannelChannel;
/**
 * A decoded protobuf IdentifiedChannel message
 *
 * Tuple where:
 *   - 0: state - current state of the channel end
 *   - 1: ordering - whether the channel is ordered or unordered
 *   - 2: counterparty - channel end
 *   - 3: connection_hops - list of connection identifiers, in order, along which packets sent on this channel will travel
 *   - 4: version - opaque channel version, which is agreed upon during the handshake
 *   - 5: port_id - port identifier
 *   - 6: channel_id - channel identifier
 *   - 7: upgrade_sequence - upgrade sequence indicates the latest upgrade attempt performed by this channel the value of 0 indicates the channel has never been upgraded
 */
export type DecodedIbcCoreChannelIdentifiedChannel = [
    xc_state?: ProtoEnumIbcCoreChannelState,
    xc_ordering?: ProtoEnumIbcCoreChannelOrder,
    a_counterparty?: DecodedIbcCoreChannelCounterparty,
    a_connection_hops?: string[],
    s_version?: string,
    si_port?: string,
    si_channel?: string,
    sg_upgrade_sequence?: CwUint64
];
/**
 * Decodes a protobuf IdentifiedChannel message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcCoreChannelIdentifiedChannel}
 */
export declare const decodeIbcCoreChannelIdentifiedChannel: (atu8_payload: Uint8Array) => DecodedIbcCoreChannelIdentifiedChannel;
/**
 * A decoded protobuf Counterparty message
 *
 * Tuple where:
 *   - 0: port_id - port on the counterparty chain which owns the other end of the channel.
 *   - 1: channel_id - channel end on the counterparty chain
 */
export type DecodedIbcCoreChannelCounterparty = [
    si_port?: string,
    si_channel?: string
];
/**
 * Decodes a protobuf Counterparty message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcCoreChannelCounterparty}
 */
export declare const decodeIbcCoreChannelCounterparty: (atu8_payload: Uint8Array) => DecodedIbcCoreChannelCounterparty;
/**
 * A decoded protobuf Packet message
 *
 * Tuple where:
 *   - 0: sequence - number corresponds to the order of sends and receives, where a Packet with an earlier sequence number must be sent and received before a Packet with a later sequence number.
 *   - 1: source_port - identifies the port on the sending chain.
 *   - 2: source_channel - identifies the channel end on the sending chain.
 *   - 3: destination_port - identifies the port on the receiving chain.
 *   - 4: destination_channel - identifies the channel end on the receiving chain.
 *   - 5: data - actual opaque bytes transferred directly to the application module
 *   - 6: timeout_height - block height after which the packet times out
 *   - 7: timeout_timestamp - block timestamp (in nanoseconds) after which the packet times out
 */
export type DecodedIbcCoreChannelPacket = [
    sg_sequence?: CwUint64,
    s_source_port?: string,
    s_source_channel?: string,
    s_destination_port?: string,
    s_destination_channel?: string,
    atu8_data?: Uint8Array,
    a_timeout_height?: DecodedIbcCoreClientHeight,
    sg_timeout_timestamp?: CwUint64
];
/**
 * Decodes a protobuf Packet message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcCoreChannelPacket}
 */
export declare const decodeIbcCoreChannelPacket: (atu8_payload: Uint8Array) => DecodedIbcCoreChannelPacket;
/**
 * A decoded protobuf PacketState message
 *
 * Tuple where:
 *   - 0: port_id - channel port identifier.
 *   - 1: channel_id - channel unique identifier.
 *   - 2: sequence - packet sequence.
 *   - 3: data - embedded data that represents packet state.
 */
export type DecodedIbcCoreChannelPacketState = [
    si_port?: string,
    si_channel?: string,
    sg_sequence?: CwUint64,
    atu8_data?: Uint8Array
];
/**
 * Decodes a protobuf PacketState message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcCoreChannelPacketState}
 */
export declare const decodeIbcCoreChannelPacketState: (atu8_payload: Uint8Array) => DecodedIbcCoreChannelPacketState;
/**
 * A decoded protobuf PacketId message
 *
 * Tuple where:
 *   - 0: port_id - channel port identifier
 *   - 1: channel_id - channel unique identifier
 *   - 2: sequence - packet sequence
 */
export type DecodedIbcCoreChannelPacketId = [
    si_port?: string,
    si_channel?: string,
    sg_sequence?: CwUint64
];
/**
 * Decodes a protobuf PacketId message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcCoreChannelPacketId}
 */
export declare const decodeIbcCoreChannelPacketId: (atu8_payload: Uint8Array) => DecodedIbcCoreChannelPacketId;
/**
 * A decoded protobuf Acknowledgement message
 *
 * Tuple where:
 *  - 20: result -
 *  - 21: error -
 */
export type DecodedIbcCoreChannelAcknowledgement = [] & {
    20?: Uint8Array;
    21?: string;
};
/**
 * Decodes a protobuf Acknowledgement message
 * @param atu8_payload - raw bytes to decode
 * @param RESERVED - a second argument is explicitly forbidden. make sure not to pass this function by reference to some callback argument
 * @returns a {@link DecodedIbcCoreChannelAcknowledgement}
 */
export declare const decodeIbcCoreChannelAcknowledgement: (atu8_payload: Uint8Array, RESERVED?: never) => DecodedIbcCoreChannelAcknowledgement;
/**
 * A decoded protobuf Timeout message
 *
 * Tuple where:
 *   - 0: height - block height after which the packet or upgrade times out
 *   - 1: timestamp - block timestamp (in nanoseconds) after which the packet or upgrade times out
 */
export type DecodedIbcCoreChannelTimeout = [
    a_height?: DecodedIbcCoreClientHeight,
    sg_timestamp?: CwUint64
];
/**
 * Decodes a protobuf Timeout message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcCoreChannelTimeout}
 */
export declare const decodeIbcCoreChannelTimeout: (atu8_payload: Uint8Array) => DecodedIbcCoreChannelTimeout;
/**
 * A decoded protobuf Params message
 *
 * Alias for: upgrade_timeout - the relative timeout after which channel upgrades will time out.
 */
export type DecodedIbcCoreChannelParams = [
    a_upgrade_timeout?: DecodedIbcCoreChannelTimeout
];
/**
 * Decodes a protobuf Params message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcCoreChannelParams}
 */
export declare const decodeIbcCoreChannelParams: (atu8_payload: Uint8Array) => DecodedIbcCoreChannelParams;
/**
 * Destructures the fields of a {@link IbcCoreChannelIdentifiedChannel} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: state - current state of the channel end
 *   - 1: ordering - whether the channel is ordered or unordered
 *   - 2: counterparty - channel end
 *   - 3: connection_hops - list of connection identifiers, in order, along which packets sent on this channel will travel
 *   - 4: version - opaque channel version, which is agreed upon during the handshake
 *   - 5: port_id - port identifier
 *   - 6: channel_id - channel identifier
 *   - 7: upgrade_sequence - upgrade sequence indicates the latest upgrade attempt performed by this channel the value of 0 indicates the channel has never been upgraded
 */
export declare const destructIbcCoreChannelIdentifiedChannel: (g_struct: IbcCoreChannelIdentifiedChannel) => [state?: JsonEnumIbcCoreChannelState, ordering?: JsonEnumIbcCoreChannelOrder, counterparty?: IbcCoreChannelCounterparty, connection_hops?: string[], version?: string, port_id?: string, channel_id?: string, upgrade_sequence?: CwUint64];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_IBC_CORE_CHANNEL_IDENTIFIED_CHANNEL = "/ibc.core.channel.v1.IdentifiedChannel";
/**
 * JSON serialization of `ibc.core.channel.v1.IdentifiedChannel` - defines a channel with additional port and channel identifier fields.
 */
export type IbcCoreChannelIdentifiedChannel = {
    state?: JsonEnumIbcCoreChannelState | undefined;
    ordering?: JsonEnumIbcCoreChannelOrder | undefined;
    counterparty?: IbcCoreChannelCounterparty | undefined;
    connection_hops?: string[] | undefined;
    version?: string | undefined;
    port_id?: string | undefined;
    channel_id?: string | undefined;
    upgrade_sequence?: CwUint64 | undefined;
};
/**
 * Destructures the fields of a {@link IbcCoreChannelCounterparty} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: port_id - port on the counterparty chain which owns the other end of the channel.
 *   - 1: channel_id - channel end on the counterparty chain
 */
export declare const destructIbcCoreChannelCounterparty: (g_struct: IbcCoreChannelCounterparty) => [port_id?: string, channel_id?: string];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_IBC_CORE_CHANNEL_COUNTERPARTY = "/ibc.core.channel.v1.Counterparty";
/**
 * JSON serialization of `ibc.core.channel.v1.Counterparty` - defines a channel end counterparty
 */
export type IbcCoreChannelCounterparty = {
    port_id?: string | undefined;
    channel_id?: string | undefined;
};
/**
 * Destructures the fields of a {@link IbcCoreChannelPacketState} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: port_id - channel port identifier.
 *   - 1: channel_id - channel unique identifier.
 *   - 2: sequence - packet sequence.
 *   - 3: data - embedded data that represents packet state.
 */
export declare const destructIbcCoreChannelPacketState: (g_struct: IbcCoreChannelPacketState) => [port_id?: string, channel_id?: string, sequence?: CwUint64, data?: Uint8Array];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_IBC_CORE_CHANNEL_PACKET_STATE = "/ibc.core.channel.v1.PacketState";
/**
 * JSON serialization of `ibc.core.channel.v1.PacketState` - defines the generic type necessary to retrieve and store packet commitments, acknowledgements, and receipts. Caller is responsible for knowing the context necessary to interpret this state as a commitment, acknowledgement, or a receipt.
 */
export type IbcCoreChannelPacketState = {
    port_id?: string | undefined;
    channel_id?: string | undefined;
    sequence?: CwUint64 | undefined;
    data?: CwBase64 | undefined;
};
/**
 * Destructures the fields of a {@link IbcCoreChannelParams} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: upgrade_timeout - the relative timeout after which channel upgrades will time out.
 */
export declare const destructIbcCoreChannelParams: (g_struct: IbcCoreChannelParams) => [upgrade_timeout?: IbcCoreChannelTimeout];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_IBC_CORE_CHANNEL_PARAMS = "/ibc.core.channel.v1.Params";
/**
 * JSON serialization of `ibc.core.channel.v1.Params` - defines the set of IBC channel parameters.
 */
export type IbcCoreChannelParams = {
    upgrade_timeout?: IbcCoreChannelTimeout | undefined;
};
/**
 * Destructures the fields of a {@link IbcCoreChannelTimeout} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: height - block height after which the packet or upgrade times out
 *   - 1: timestamp - block timestamp (in nanoseconds) after which the packet or upgrade times out
 */
export declare const destructIbcCoreChannelTimeout: (g_struct: IbcCoreChannelTimeout) => [height?: IbcCoreClientHeight, timestamp?: CwUint64];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_IBC_CORE_CHANNEL_TIMEOUT = "/ibc.core.channel.v1.Timeout";
/**
 * JSON serialization of `ibc.core.channel.v1.Timeout` - defines an execution deadline structure for 04-channel handlers. This includes packet lifecycle handlers as well as the upgrade handshake handlers. A valid Timeout contains either one or both of a timestamp and block height (sequence).
 */
export type IbcCoreChannelTimeout = {
    height?: IbcCoreClientHeight | undefined;
    timestamp?: CwUint64 | undefined;
};
/**
 * Destructures the fields of a {@link IbcCoreChannelChannel} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: state - current state of the channel end
 *   - 1: ordering - whether the channel is ordered or unordered
 *   - 2: counterparty - channel end
 *   - 3: connection_hops - list of connection identifiers, in order, along which packets sent on this channel will travel
 *   - 4: version - opaque channel version, which is agreed upon during the handshake
 *   - 5: upgrade_sequence - upgrade sequence indicates the latest upgrade attempt performed by this channel the value of 0 indicates the channel has never been upgraded
 */
export declare const destructIbcCoreChannelChannel: (g_struct: IbcCoreChannelChannel) => [state?: JsonEnumIbcCoreChannelState, ordering?: JsonEnumIbcCoreChannelOrder, counterparty?: IbcCoreChannelCounterparty, connection_hops?: string[], version?: string, upgrade_sequence?: CwUint64];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_IBC_CORE_CHANNEL_CHANNEL = "/ibc.core.channel.v1.Channel";
/**
 * JSON serialization of `ibc.core.channel.v1.Channel` - defines pipeline for exactly-once packet delivery between specific modules on separate blockchains, which has at least one end capable of sending packets and one end capable of receiving packets.
 */
export type IbcCoreChannelChannel = {
    state?: JsonEnumIbcCoreChannelState | undefined;
    ordering?: JsonEnumIbcCoreChannelOrder | undefined;
    counterparty?: IbcCoreChannelCounterparty | undefined;
    connection_hops?: string[] | undefined;
    version?: string | undefined;
    upgrade_sequence?: CwUint64 | undefined;
};
/**
 * Destructures the fields of a {@link IbcCoreChannelPacket} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: sequence - number corresponds to the order of sends and receives, where a Packet with an earlier sequence number must be sent and received before a Packet with a later sequence number.
 *   - 1: source_port - identifies the port on the sending chain.
 *   - 2: source_channel - identifies the channel end on the sending chain.
 *   - 3: destination_port - identifies the port on the receiving chain.
 *   - 4: destination_channel - identifies the channel end on the receiving chain.
 *   - 5: data - actual opaque bytes transferred directly to the application module
 *   - 6: timeout_height - block height after which the packet times out
 *   - 7: timeout_timestamp - block timestamp (in nanoseconds) after which the packet times out
 */
export declare const destructIbcCoreChannelPacket: (g_struct: IbcCoreChannelPacket) => [sequence?: CwUint64, source_port?: string, source_channel?: string, destination_port?: string, destination_channel?: string, data?: Uint8Array, timeout_height?: IbcCoreClientHeight, timeout_timestamp?: CwUint64];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_IBC_CORE_CHANNEL_PACKET = "/ibc.core.channel.v1.Packet";
/**
 * JSON serialization of `ibc.core.channel.v1.Packet` - defines a type that carries data across different chains through IBC
 */
export type IbcCoreChannelPacket = {
    sequence?: CwUint64 | undefined;
    source_port?: string | undefined;
    source_channel?: string | undefined;
    destination_port?: string | undefined;
    destination_channel?: string | undefined;
    data?: CwBase64 | undefined;
    timeout_height?: IbcCoreClientHeight | undefined;
    timeout_timestamp?: CwUint64 | undefined;
};
/**
 * Destructures the fields of a {@link IbcCoreChannelPacketId} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: port_id - channel port identifier
 *   - 1: channel_id - channel unique identifier
 *   - 2: sequence - packet sequence
 */
export declare const destructIbcCoreChannelPacketId: (g_struct: IbcCoreChannelPacketId) => [port_id?: string, channel_id?: string, sequence?: CwUint64];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_IBC_CORE_CHANNEL_PACKET_ID = "/ibc.core.channel.v1.PacketId";
/**
 * JSON serialization of `ibc.core.channel.v1.PacketId` - an identifier for a unique Packet Source chains refer to packets by source port/channel Destination chains refer to packets by destination port/channel
 */
export type IbcCoreChannelPacketId = {
    port_id?: string | undefined;
    channel_id?: string | undefined;
    sequence?: CwUint64 | undefined;
};
/**
 * Destructures the fields of a {@link IbcCoreChannelAcknowledgement} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 20: result -
 *   - 21: error -
 */
export declare const destructIbcCoreChannelAcknowledgement: (g_struct: IbcCoreChannelAcknowledgement) => [] & {
    21?: Uint8Array;
    22?: string;
};
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_IBC_CORE_CHANNEL_ACKNOWLEDGEMENT = "/ibc.core.channel.v1.Acknowledgement";
/**
 * JSON serialization of `ibc.core.channel.v1.Acknowledgement` - the recommended acknowledgement format to be used by app-specific protocols. NOTE: The field numbers 21 and 22 were explicitly chosen to avoid accidental conflicts with other protobuf message formats used for acknowledgements. The first byte of any message with this format will be the non-ASCII values `0xaa` (result) or `0xb2` (error). Implemented as defined by ICS: https://github.com/cosmos/ibc/tree/master/spec/core/ics-004-channel-and-packet-semantics#acknowledgement-envelope
 */
export type IbcCoreChannelAcknowledgement = {
    result?: CwBase64 | undefined;
    error?: string | undefined;
};
/**
 * Protobuf enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_UNINITIALIZED_UNSPECIFIED** - Default State
 *
 * Belongs to enum type {@link ProtoEnumIbcCoreChannelState}
 */
export declare const XC_PROTO_IBC_CORE_CHANNEL_STATE_UNINITIALIZED_UNSPECIFIED = 0;
/**
 * JSON enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_UNINITIALIZED_UNSPECIFIED** - Default State
 *
 * Belongs to enum type {@link JsonEnumIbcCoreChannelState}
 */
export declare const SI_JSON_IBC_CORE_CHANNEL_STATE_UNINITIALIZED_UNSPECIFIED = "UNINITIALIZED";
/**
 * Protobuf enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_INIT** - A channel has just started the opening handshake.
 *
 * Belongs to enum type {@link ProtoEnumIbcCoreChannelState}
 */
export declare const XC_PROTO_IBC_CORE_CHANNEL_STATE_INIT = 1;
/**
 * JSON enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_INIT** - A channel has just started the opening handshake.
 *
 * Belongs to enum type {@link JsonEnumIbcCoreChannelState}
 */
export declare const SI_JSON_IBC_CORE_CHANNEL_STATE_INIT = "INIT";
/**
 * Protobuf enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_TRYOPEN** - A channel has acknowledged the handshake step on the counterparty chain.
 *
 * Belongs to enum type {@link ProtoEnumIbcCoreChannelState}
 */
export declare const XC_PROTO_IBC_CORE_CHANNEL_STATE_TRYOPEN = 2;
/**
 * JSON enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_TRYOPEN** - A channel has acknowledged the handshake step on the counterparty chain.
 *
 * Belongs to enum type {@link JsonEnumIbcCoreChannelState}
 */
export declare const SI_JSON_IBC_CORE_CHANNEL_STATE_TRYOPEN = "TRYOPEN";
/**
 * Protobuf enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_OPEN** - A channel has completed the handshake. Open channels are ready to send and receive packets.
 *
 * Belongs to enum type {@link ProtoEnumIbcCoreChannelState}
 */
export declare const XC_PROTO_IBC_CORE_CHANNEL_STATE_OPEN = 3;
/**
 * JSON enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_OPEN** - A channel has completed the handshake. Open channels are ready to send and receive packets.
 *
 * Belongs to enum type {@link JsonEnumIbcCoreChannelState}
 */
export declare const SI_JSON_IBC_CORE_CHANNEL_STATE_OPEN = "OPEN";
/**
 * Protobuf enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_CLOSED** - A channel has been closed and can no longer be used to send or receive packets.
 *
 * Belongs to enum type {@link ProtoEnumIbcCoreChannelState}
 */
export declare const XC_PROTO_IBC_CORE_CHANNEL_STATE_CLOSED = 4;
/**
 * JSON enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_CLOSED** - A channel has been closed and can no longer be used to send or receive packets.
 *
 * Belongs to enum type {@link JsonEnumIbcCoreChannelState}
 */
export declare const SI_JSON_IBC_CORE_CHANNEL_STATE_CLOSED = "CLOSED";
/**
 * Protobuf enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_FLUSHING** - A channel has just accepted the upgrade handshake attempt and is flushing in-flight packets.
 *
 * Belongs to enum type {@link ProtoEnumIbcCoreChannelState}
 */
export declare const XC_PROTO_IBC_CORE_CHANNEL_STATE_FLUSHING = 5;
/**
 * JSON enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_FLUSHING** - A channel has just accepted the upgrade handshake attempt and is flushing in-flight packets.
 *
 * Belongs to enum type {@link JsonEnumIbcCoreChannelState}
 */
export declare const SI_JSON_IBC_CORE_CHANNEL_STATE_FLUSHING = "FLUSHING";
/**
 * Protobuf enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_FLUSHCOMPLETE** - A channel has just completed flushing any in-flight packets.
 *
 * Belongs to enum type {@link ProtoEnumIbcCoreChannelState}
 */
export declare const XC_PROTO_IBC_CORE_CHANNEL_STATE_FLUSHCOMPLETE = 6;
/**
 * JSON enum value for `ibc.core.channel.v1.State`.
 *
 * **STATE_FLUSHCOMPLETE** - A channel has just completed flushing any in-flight packets.
 *
 * Belongs to enum type {@link JsonEnumIbcCoreChannelState}
 */
export declare const SI_JSON_IBC_CORE_CHANNEL_STATE_FLUSHCOMPLETE = "FLUSHCOMPLETE";
/**
 * Raw protobuf enum values for `ibc.core.channel.v1.State` to be used when passing to an encoder or comparing to a decoded protobuf value.
 *
 * Values:
 *   - {@link XC_PROTO_IBC_CORE_CHANNEL_STATE_UNINITIALIZED_UNSPECIFIED}
 *   - {@link XC_PROTO_IBC_CORE_CHANNEL_STATE_INIT}
 *   - {@link XC_PROTO_IBC_CORE_CHANNEL_STATE_TRYOPEN}
 *   - {@link XC_PROTO_IBC_CORE_CHANNEL_STATE_OPEN}
 *   - {@link XC_PROTO_IBC_CORE_CHANNEL_STATE_CLOSED}
 *   - {@link XC_PROTO_IBC_CORE_CHANNEL_STATE_FLUSHING}
 *   - {@link XC_PROTO_IBC_CORE_CHANNEL_STATE_FLUSHCOMPLETE}
 */
export type ProtoEnumIbcCoreChannelState = typeof XC_PROTO_IBC_CORE_CHANNEL_STATE_UNINITIALIZED_UNSPECIFIED | typeof XC_PROTO_IBC_CORE_CHANNEL_STATE_INIT | typeof XC_PROTO_IBC_CORE_CHANNEL_STATE_TRYOPEN | typeof XC_PROTO_IBC_CORE_CHANNEL_STATE_OPEN | typeof XC_PROTO_IBC_CORE_CHANNEL_STATE_CLOSED | typeof XC_PROTO_IBC_CORE_CHANNEL_STATE_FLUSHING | typeof XC_PROTO_IBC_CORE_CHANNEL_STATE_FLUSHCOMPLETE;
/**
 * JSON enum values for `ibc.core.channel.v1.State` to be used when passing to a gRPC-gateway method or comparing to a response value
 *
 * Values:
 *   - {@link SI_JSON_IBC_CORE_CHANNEL_STATE_UNINITIALIZED_UNSPECIFIED}
 *   - {@link SI_JSON_IBC_CORE_CHANNEL_STATE_INIT}
 *   - {@link SI_JSON_IBC_CORE_CHANNEL_STATE_TRYOPEN}
 *   - {@link SI_JSON_IBC_CORE_CHANNEL_STATE_OPEN}
 *   - {@link SI_JSON_IBC_CORE_CHANNEL_STATE_CLOSED}
 *   - {@link SI_JSON_IBC_CORE_CHANNEL_STATE_FLUSHING}
 *   - {@link SI_JSON_IBC_CORE_CHANNEL_STATE_FLUSHCOMPLETE}
 */
export type JsonEnumIbcCoreChannelState = typeof SI_JSON_IBC_CORE_CHANNEL_STATE_UNINITIALIZED_UNSPECIFIED | typeof SI_JSON_IBC_CORE_CHANNEL_STATE_INIT | typeof SI_JSON_IBC_CORE_CHANNEL_STATE_TRYOPEN | typeof SI_JSON_IBC_CORE_CHANNEL_STATE_OPEN | typeof SI_JSON_IBC_CORE_CHANNEL_STATE_CLOSED | typeof SI_JSON_IBC_CORE_CHANNEL_STATE_FLUSHING | typeof SI_JSON_IBC_CORE_CHANNEL_STATE_FLUSHCOMPLETE;
/**
 * Maps a protobuf enum int value for `ibc.core.channel.v1.State` to is JSON equivalent enum string value
 */
export declare const ProtoToJsonEnumIbcCoreChannelState: Record<ProtoEnumIbcCoreChannelState, JsonEnumIbcCoreChannelState>;
/**
 * Maps a JSON enum string value for `ibc.core.channel.v1.State` to is protobuf equivalent enum int value
 */
export declare const JsonToProtoEnumIbcCoreChannelState: Record<JsonEnumIbcCoreChannelState, ProtoEnumIbcCoreChannelState>;
/**
 * Protobuf enum value for `ibc.core.channel.v1.Order`.
 *
 * **ORDER_NONE_UNSPECIFIED** - zero-value for channel ordering
 *
 * Belongs to enum type {@link ProtoEnumIbcCoreChannelOrder}
 */
export declare const XC_PROTO_IBC_CORE_CHANNEL_ORDER_NONE_UNSPECIFIED = 0;
/**
 * JSON enum value for `ibc.core.channel.v1.Order`.
 *
 * **ORDER_NONE_UNSPECIFIED** - zero-value for channel ordering
 *
 * Belongs to enum type {@link JsonEnumIbcCoreChannelOrder}
 */
export declare const SI_JSON_IBC_CORE_CHANNEL_ORDER_NONE_UNSPECIFIED = "NONE";
/**
 * Protobuf enum value for `ibc.core.channel.v1.Order`.
 *
 * **ORDER_UNORDERED** - packets can be delivered in any order, which may differ from the order in which they were sent.
 *
 * Belongs to enum type {@link ProtoEnumIbcCoreChannelOrder}
 */
export declare const XC_PROTO_IBC_CORE_CHANNEL_ORDER_UNORDERED = 1;
/**
 * JSON enum value for `ibc.core.channel.v1.Order`.
 *
 * **ORDER_UNORDERED** - packets can be delivered in any order, which may differ from the order in which they were sent.
 *
 * Belongs to enum type {@link JsonEnumIbcCoreChannelOrder}
 */
export declare const SI_JSON_IBC_CORE_CHANNEL_ORDER_UNORDERED = "UNORDERED";
/**
 * Protobuf enum value for `ibc.core.channel.v1.Order`.
 *
 * **ORDER_ORDERED** - packets are delivered exactly in the order which they were sent
 *
 * Belongs to enum type {@link ProtoEnumIbcCoreChannelOrder}
 */
export declare const XC_PROTO_IBC_CORE_CHANNEL_ORDER_ORDERED = 2;
/**
 * JSON enum value for `ibc.core.channel.v1.Order`.
 *
 * **ORDER_ORDERED** - packets are delivered exactly in the order which they were sent
 *
 * Belongs to enum type {@link JsonEnumIbcCoreChannelOrder}
 */
export declare const SI_JSON_IBC_CORE_CHANNEL_ORDER_ORDERED = "ORDERED";
/**
 * Raw protobuf enum values for `ibc.core.channel.v1.Order` to be used when passing to an encoder or comparing to a decoded protobuf value.
 *
 * Values:
 *   - {@link XC_PROTO_IBC_CORE_CHANNEL_ORDER_NONE_UNSPECIFIED}
 *   - {@link XC_PROTO_IBC_CORE_CHANNEL_ORDER_UNORDERED}
 *   - {@link XC_PROTO_IBC_CORE_CHANNEL_ORDER_ORDERED}
 */
export type ProtoEnumIbcCoreChannelOrder = typeof XC_PROTO_IBC_CORE_CHANNEL_ORDER_NONE_UNSPECIFIED | typeof XC_PROTO_IBC_CORE_CHANNEL_ORDER_UNORDERED | typeof XC_PROTO_IBC_CORE_CHANNEL_ORDER_ORDERED;
/**
 * JSON enum values for `ibc.core.channel.v1.Order` to be used when passing to a gRPC-gateway method or comparing to a response value
 *
 * Values:
 *   - {@link SI_JSON_IBC_CORE_CHANNEL_ORDER_NONE_UNSPECIFIED}
 *   - {@link SI_JSON_IBC_CORE_CHANNEL_ORDER_UNORDERED}
 *   - {@link SI_JSON_IBC_CORE_CHANNEL_ORDER_ORDERED}
 */
export type JsonEnumIbcCoreChannelOrder = typeof SI_JSON_IBC_CORE_CHANNEL_ORDER_NONE_UNSPECIFIED | typeof SI_JSON_IBC_CORE_CHANNEL_ORDER_UNORDERED | typeof SI_JSON_IBC_CORE_CHANNEL_ORDER_ORDERED;
/**
 * Maps a protobuf enum int value for `ibc.core.channel.v1.Order` to is JSON equivalent enum string value
 */
export declare const ProtoToJsonEnumIbcCoreChannelOrder: Record<ProtoEnumIbcCoreChannelOrder, JsonEnumIbcCoreChannelOrder>;
/**
 * Maps a JSON enum string value for `ibc.core.channel.v1.Order` to is protobuf equivalent enum int value
 */
export declare const JsonToProtoEnumIbcCoreChannelOrder: Record<JsonEnumIbcCoreChannelOrder, ProtoEnumIbcCoreChannelOrder>;
