import type { WeakUint64Str, CwUint64 } from '@solar-republic/types';
import type { Encoded, Opt } from '../../../../../api/types.js';
import type { IbcCoreChannelTimeout, DecodedIbcCoreChannelTimeout, ProtoEnumIbcCoreChannelOrder, JsonEnumIbcCoreChannelOrder } from './channel.js';
export type EncodedIbcCoreChannelUpgrade = Encoded<'/ibc.core.channel.v1.Upgrade'>;
export type EncodedIbcCoreChannelUpgradeFields = Encoded<'/ibc.core.channel.v1.UpgradeFields'>;
export type EncodedIbcCoreChannelErrorReceipt = Encoded<'/ibc.core.channel.v1.ErrorReceipt'>;
/**
 * Encodes a `Upgrade` protobuf message: a verifiable type which contains the relevant information for an attempted upgrade. It provides the proposed changes to the channel end, the timeout for this upgrade attempt and the next packet sequence which allows the counterparty to efficiently know the highest sequence it has received. The next sequence send is used for pruning and upgrading from unordered to ordered channels.
 * @param g_fields - `fields`:
 * @param g_timeout - `timeout`:
 * @param sg_next_sequence_send - `next_sequence_send`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeIbcCoreChannelUpgrade: (atu8_fields?: Opt<Encoded<'/ibc.core.channel.v1.UpgradeFields'>>, atu8_timeout?: Opt<Encoded<'/ibc.core.channel.v1.Timeout'>>, sg_next_sequence_send?: Opt<WeakUint64Str>) => EncodedIbcCoreChannelUpgrade;
/**
 * Encodes a `UpgradeFields` protobuf message: the fields in a channel end which may be changed during a channel upgrade.
 * @param xc_ordering - `ordering`:
 * @param a_connection_hops - `connection_hops`:
 * @param s_version - `version`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeIbcCoreChannelUpgradeFields: (xc_ordering?: Opt<ProtoEnumIbcCoreChannelOrder>, a_connection_hops?: Opt<string[]>, s_version?: Opt<string>) => EncodedIbcCoreChannelUpgradeFields;
/**
 * Encodes a `ErrorReceipt` protobuf message: defines a type which encapsulates the upgrade sequence and error associated with the upgrade handshake failure. When a channel upgrade handshake is aborted both chains are expected to increment to the next sequence.
 * @param sg_sequence - `sequence`: the channel upgrade sequence
 * @param s_message - `message`: the error message detailing the cause of failure
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeIbcCoreChannelErrorReceipt: (sg_sequence?: Opt<WeakUint64Str>, s_message?: Opt<string>) => EncodedIbcCoreChannelErrorReceipt;
/**
 * A decoded protobuf Upgrade message
 *
 * Tuple where:
 *   - 0: fields -
 *   - 1: timeout -
 *   - 2: next_sequence_send -
 */
export type DecodedIbcCoreChannelUpgrade = [
    a_fields?: DecodedIbcCoreChannelUpgradeFields,
    a_timeout?: DecodedIbcCoreChannelTimeout,
    sg_next_sequence_send?: CwUint64
];
/**
 * Decodes a protobuf Upgrade message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcCoreChannelUpgrade}
 */
export declare const decodeIbcCoreChannelUpgrade: (atu8_payload: Uint8Array) => DecodedIbcCoreChannelUpgrade;
/**
 * A decoded protobuf UpgradeFields message
 *
 * Tuple where:
 *   - 0: ordering -
 *   - 1: connection_hops -
 *   - 2: version -
 */
export type DecodedIbcCoreChannelUpgradeFields = [
    xc_ordering?: ProtoEnumIbcCoreChannelOrder,
    a_connection_hops?: string[],
    s_version?: string
];
/**
 * Decodes a protobuf UpgradeFields message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcCoreChannelUpgradeFields}
 */
export declare const decodeIbcCoreChannelUpgradeFields: (atu8_payload: Uint8Array) => DecodedIbcCoreChannelUpgradeFields;
/**
 * A decoded protobuf ErrorReceipt message
 *
 * Tuple where:
 *   - 0: sequence - the channel upgrade sequence
 *   - 1: message - the error message detailing the cause of failure
 */
export type DecodedIbcCoreChannelErrorReceipt = [
    sg_sequence?: CwUint64,
    s_message?: string
];
/**
 * Decodes a protobuf ErrorReceipt message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcCoreChannelErrorReceipt}
 */
export declare const decodeIbcCoreChannelErrorReceipt: (atu8_payload: Uint8Array) => DecodedIbcCoreChannelErrorReceipt;
/**
 * Destructures the fields of a {@link IbcCoreChannelUpgradeFields} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: ordering -
 *   - 1: connection_hops -
 *   - 2: version -
 */
export declare const destructIbcCoreChannelUpgradeFields: (g_struct: IbcCoreChannelUpgradeFields) => [ordering?: JsonEnumIbcCoreChannelOrder, connection_hops?: string[], version?: string];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_IBC_CORE_CHANNEL_UPGRADE_FIELDS = "/ibc.core.channel.v1.UpgradeFields";
/**
 * JSON serialization of `ibc.core.channel.v1.UpgradeFields` - the fields in a channel end which may be changed during a channel upgrade.
 */
export type IbcCoreChannelUpgradeFields = {
    ordering?: JsonEnumIbcCoreChannelOrder | undefined;
    connection_hops?: string[] | undefined;
    version?: string | undefined;
};
/**
 * Destructures the fields of a {@link IbcCoreChannelUpgrade} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: fields -
 *   - 1: timeout -
 *   - 2: next_sequence_send -
 */
export declare const destructIbcCoreChannelUpgrade: (g_struct: IbcCoreChannelUpgrade) => [fields?: IbcCoreChannelUpgradeFields, timeout?: IbcCoreChannelTimeout, next_sequence_send?: CwUint64];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_IBC_CORE_CHANNEL_UPGRADE = "/ibc.core.channel.v1.Upgrade";
/**
 * JSON serialization of `ibc.core.channel.v1.Upgrade` - a verifiable type which contains the relevant information for an attempted upgrade. It provides the proposed changes to the channel end, the timeout for this upgrade attempt and the next packet sequence which allows the counterparty to efficiently know the highest sequence it has received. The next sequence send is used for pruning and upgrading from unordered to ordered channels.
 */
export type IbcCoreChannelUpgrade = {
    fields?: IbcCoreChannelUpgradeFields | undefined;
    timeout?: IbcCoreChannelTimeout | undefined;
    next_sequence_send?: CwUint64 | undefined;
};
/**
 * Destructures the fields of a {@link IbcCoreChannelErrorReceipt} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: sequence - the channel upgrade sequence
 *   - 1: message - the error message detailing the cause of failure
 */
export declare const destructIbcCoreChannelErrorReceipt: (g_struct: IbcCoreChannelErrorReceipt) => [sequence?: CwUint64, message?: string];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_IBC_CORE_CHANNEL_ERROR_RECEIPT = "/ibc.core.channel.v1.ErrorReceipt";
/**
 * JSON serialization of `ibc.core.channel.v1.ErrorReceipt` - defines a type which encapsulates the upgrade sequence and error associated with the upgrade handshake failure. When a channel upgrade handshake is aborted both chains are expected to increment to the next sequence.
 */
export type IbcCoreChannelErrorReceipt = {
    sequence?: CwUint64 | undefined;
    message?: string | undefined;
};
