import type { CwBase64 } from '@solar-republic/types';
import type { Encoded, Opt } from '../../../../../api/types.js';
import type { CosmosIcs23CommitmentProof, DecodedCosmosIcs23CommitmentProof } from '../../../../cosmos/ics23/v1/proofs.js';
export type EncodedIbcCoreCommitmentMerkleRoot = Encoded<'/ibc.core.commitment.v1.MerkleRoot'>;
export type EncodedIbcCoreCommitmentMerklePrefix = Encoded<'/ibc.core.commitment.v1.MerklePrefix'>;
export type EncodedIbcCoreCommitmentMerklePath = Encoded<'/ibc.core.commitment.v1.MerklePath'>;
export type EncodedIbcCoreCommitmentMerkleProof = Encoded<'/ibc.core.commitment.v1.MerkleProof'>;
/**
 * Encodes a `MerkleRoot` protobuf message: defines a merkle root hash. In the Cosmos SDK, the AppHash of a block header becomes the root.
 * @param atu8_hash - `hash`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeIbcCoreCommitmentMerkleRoot: (atu8_hash?: Opt<Uint8Array>) => EncodedIbcCoreCommitmentMerkleRoot;
/**
 * Encodes a `MerklePrefix` protobuf message: merkle path prefixed to the key. The constructed key from the Path and the key will be append(Path.KeyPath, append(Path.KeyPrefix, key...))
 * @param atu8_key_prefix - `key_prefix`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeIbcCoreCommitmentMerklePrefix: (atu8_key_prefix?: Opt<Uint8Array>) => EncodedIbcCoreCommitmentMerklePrefix;
/**
 * Encodes a `MerklePath` protobuf message: the path used to verify commitment proofs, which can be an arbitrary structured object (defined by a commitment type). MerklePath is represented from root-to-leaf
 * @param a_key_paths - `key_path`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeIbcCoreCommitmentMerklePath: (a_key_paths?: Opt<string[]>) => EncodedIbcCoreCommitmentMerklePath;
/**
 * Encodes a `MerkleProof` protobuf message: a wrapper type over a chain of CommitmentProofs. It demonstrates membership or non-membership for an element or set of elements, verifiable in conjunction with a known commitment root. Proofs should be succinct. MerkleProofs are ordered from leaf-to-root
 * @param a_proofs - `proofs`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeIbcCoreCommitmentMerkleProof: (a_proofs?: Opt<Encoded<'/cosmos.ics23.v1.CommitmentProof'>[]>) => EncodedIbcCoreCommitmentMerkleProof;
/**
 * A decoded protobuf MerkleRoot message
 *
 * Alias for: hash -
 */
export type DecodedIbcCoreCommitmentMerkleRoot = [
    atu8_hash?: Uint8Array
];
/**
 * Decodes a protobuf MerkleRoot message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcCoreCommitmentMerkleRoot}
 */
export declare const decodeIbcCoreCommitmentMerkleRoot: (atu8_payload: Uint8Array) => DecodedIbcCoreCommitmentMerkleRoot;
/**
 * A decoded protobuf MerklePrefix message
 *
 * Alias for: key_prefix -
 */
export type DecodedIbcCoreCommitmentMerklePrefix = [
    atu8_key_prefix?: Uint8Array
];
/**
 * Decodes a protobuf MerklePrefix message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcCoreCommitmentMerklePrefix}
 */
export declare const decodeIbcCoreCommitmentMerklePrefix: (atu8_payload: Uint8Array) => DecodedIbcCoreCommitmentMerklePrefix;
/**
 * A decoded protobuf MerklePath message
 *
 * Alias for: key_path -
 */
export type DecodedIbcCoreCommitmentMerklePath = [
    a_key_paths?: string[]
];
/**
 * Decodes a protobuf MerklePath message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcCoreCommitmentMerklePath}
 */
export declare const decodeIbcCoreCommitmentMerklePath: (atu8_payload: Uint8Array) => DecodedIbcCoreCommitmentMerklePath;
/**
 * A decoded protobuf MerkleProof message
 *
 * Alias for: proofs -
 */
export type DecodedIbcCoreCommitmentMerkleProof = [
    a_proofs?: DecodedCosmosIcs23CommitmentProof[]
];
/**
 * Decodes a protobuf MerkleProof message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcCoreCommitmentMerkleProof}
 */
export declare const decodeIbcCoreCommitmentMerkleProof: (atu8_payload: Uint8Array) => DecodedIbcCoreCommitmentMerkleProof;
/**
 * Destructures the fields of a {@link IbcCoreCommitmentMerklePrefix} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: key_prefix -
 */
export declare const destructIbcCoreCommitmentMerklePrefix: (g_struct: IbcCoreCommitmentMerklePrefix) => [key_prefix?: Uint8Array];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_IBC_CORE_COMMITMENT_MERKLE_PREFIX = "/ibc.core.commitment.v1.MerklePrefix";
/**
 * JSON serialization of `ibc.core.commitment.v1.MerklePrefix` - merkle path prefixed to the key. The constructed key from the Path and the key will be append(Path.KeyPath, append(Path.KeyPrefix, key...))
 */
export type IbcCoreCommitmentMerklePrefix = {
    key_prefix?: CwBase64 | undefined;
};
/**
 * Destructures the fields of a {@link IbcCoreCommitmentMerkleRoot} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: hash -
 */
export declare const destructIbcCoreCommitmentMerkleRoot: (g_struct: IbcCoreCommitmentMerkleRoot) => [hash?: Uint8Array];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_IBC_CORE_COMMITMENT_MERKLE_ROOT = "/ibc.core.commitment.v1.MerkleRoot";
/**
 * JSON serialization of `ibc.core.commitment.v1.MerkleRoot` - defines a merkle root hash. In the Cosmos SDK, the AppHash of a block header becomes the root.
 */
export type IbcCoreCommitmentMerkleRoot = {
    hash?: CwBase64 | undefined;
};
/**
 * Destructures the fields of a {@link IbcCoreCommitmentMerklePath} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: key_path -
 */
export declare const destructIbcCoreCommitmentMerklePath: (g_struct: IbcCoreCommitmentMerklePath) => [key_path?: string[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_IBC_CORE_COMMITMENT_MERKLE_PATH = "/ibc.core.commitment.v1.MerklePath";
/**
 * JSON serialization of `ibc.core.commitment.v1.MerklePath` - the path used to verify commitment proofs, which can be an arbitrary structured object (defined by a commitment type). MerklePath is represented from root-to-leaf
 */
export type IbcCoreCommitmentMerklePath = {
    key_path?: string[] | undefined;
};
/**
 * Destructures the fields of a {@link IbcCoreCommitmentMerkleProof} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: proofs -
 */
export declare const destructIbcCoreCommitmentMerkleProof: (g_struct: IbcCoreCommitmentMerkleProof) => [proofs?: CosmosIcs23CommitmentProof[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_IBC_CORE_COMMITMENT_MERKLE_PROOF = "/ibc.core.commitment.v1.MerkleProof";
/**
 * JSON serialization of `ibc.core.commitment.v1.MerkleProof` - a wrapper type over a chain of CommitmentProofs. It demonstrates membership or non-membership for an element or set of elements, verifiable in conjunction with a known commitment root. Proofs should be succinct. MerkleProofs are ordered from leaf-to-root
 */
export type IbcCoreCommitmentMerkleProof = {
    proofs?: CosmosIcs23CommitmentProof[] | undefined;
};
