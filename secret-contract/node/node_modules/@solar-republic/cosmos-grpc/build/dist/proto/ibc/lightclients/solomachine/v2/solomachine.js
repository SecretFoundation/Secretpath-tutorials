import { decode_protobuf } from '../../../../../api/protobuf-reader.js';
import { Protobuf } from '../../../../../api/protobuf-writer.js';
import { safe_base64_to_bytes } from '../../../../../api/util.js';
import { decodeGoogleProtobufAny } from '../../../../google/protobuf/any.js';
import { decodeIbcCoreChannelChannel } from '../../../core/channel/v1/channel.js';
import { decodeIbcCoreConnectionConnectionEnd } from '../../../core/connection/v1/connection.js';
/**
 * Encodes a `ClientState` protobuf message: defines a solo machine client that tracks the current consensus state and if the client is frozen.
 * @param sg_sequence - `sequence`: latest sequence of the client state
 * @param b_is_frozen - `is_frozen`: frozen sequence of the solo machine
 * @param g_consensus_state - `consensus_state`:
 * @param b_allow_update_after_proposal - `allow_update_after_proposal`: when set to true, will allow governance to update a solo machine client. The client will be unfrozen if it is frozen.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcLightclientsSolomachineClientState = (sg_sequence, b_is_frozen, atu8_consensus_state, b_allow_update_after_proposal) => Protobuf() // ...
    .g(sg_sequence) // uint64 sequence = 1
    .v(b_is_frozen) // boolean is_frozen = 2
    .b(atu8_consensus_state) // ConsensusState consensus_state = 3
    .v(b_allow_update_after_proposal) // boolean allow_update_after_proposal = 4
    .o;
/**
 * Encodes a `ConsensusState` protobuf message: defines a solo machine consensus state. The sequence of a consensus state is contained in the "height" key used in storing the consensus state.
 * @param atu8_public_key - `public_key`: public key of the solo machine
 * @param s_diversifier - `diversifier`: allows the same public key to be re-used across different solo machine clients (potentially on different chains) without being considered misbehaviour.
 * @param sg_timestamp - `timestamp`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcLightclientsSolomachineConsensusState = (atu8_public_key, s_diversifier, sg_timestamp) => Protobuf() // ...
    .b(atu8_public_key) // Any public_key = 1
    .s(s_diversifier) // string diversifier = 2
    .g(sg_timestamp) // uint64 timestamp = 3
    .o;
/**
 * Encodes a `Header` protobuf message: defines a solo machine consensus header
 * @param sg_sequence - `sequence`: to update solo machine public key at
 * @param sg_timestamp - `timestamp`:
 * @param atu8_signature - `signature`:
 * @param atu8_new_public_key - `new_public_key`:
 * @param s_new_diversifier - `new_diversifier`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcLightclientsSolomachineHeader = (sg_sequence, sg_timestamp, atu8_signature, atu8_new_public_key, s_new_diversifier) => Protobuf() // ...
    .g(sg_sequence) // uint64 sequence = 1
    .g(sg_timestamp) // uint64 timestamp = 2
    .b(atu8_signature) // bytes signature = 3
    .b(atu8_new_public_key) // Any new_public_key = 4
    .s(s_new_diversifier) // string new_diversifier = 5
    .o;
/**
 * Encodes a `Misbehaviour` protobuf message: defines misbehaviour for a solo machine which consists of a sequence and two signatures over different messages at that sequence.
 * @param si_client - `client_id`:
 * @param sg_sequence - `sequence`:
 * @param g_signature_one - `signature_one`:
 * @param g_signature_two - `signature_two`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcLightclientsSolomachineMisbehaviour = (si_client, sg_sequence, atu8_signature_one, atu8_signature_two) => Protobuf() // ...
    .s(si_client) // string client_id = 1
    .g(sg_sequence) // uint64 sequence = 2
    .b(atu8_signature_one) // SignatureAndData signature_one = 3
    .b(atu8_signature_two) // SignatureAndData signature_two = 4
    .o;
/**
 * Encodes a `SignatureAndData` protobuf message: contains a signature and the data signed over to create that signature.
 * @param atu8_signature - `signature`:
 * @param xc_data_type - `data_type`:
 * @param atu8_data - `data`:
 * @param sg_timestamp - `timestamp`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcLightclientsSolomachineSignatureAndData = (atu8_signature, xc_data_type, atu8_data, sg_timestamp) => Protobuf() // ...
    .b(atu8_signature) // bytes signature = 1
    .v(xc_data_type) // DataType data_type = 2
    .b(atu8_data) // bytes data = 3
    .g(sg_timestamp) // uint64 timestamp = 4
    .o;
/**
 * Encodes a `TimestampedSignatureData` protobuf message: contains the signature data and the timestamp of the signature.
 * @param atu8_signature_data - `signature_data`:
 * @param sg_timestamp - `timestamp`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcLightclientsSolomachineTimestampedSignatureData = (atu8_signature_data, sg_timestamp) => Protobuf() // ...
    .b(atu8_signature_data) // bytes signature_data = 1
    .g(sg_timestamp) // uint64 timestamp = 2
    .o;
/**
 * Encodes a `SignBytes` protobuf message: defines the signed bytes used for signature verification.
 * @param sg_sequence - `sequence`:
 * @param sg_timestamp - `timestamp`:
 * @param s_diversifier - `diversifier`:
 * @param xc_data_type - `data_type`: type of the data used
 * @param atu8_data - `data`: marshaled data
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcLightclientsSolomachineSignBytes = (sg_sequence, sg_timestamp, s_diversifier, xc_data_type, atu8_data) => Protobuf() // ...
    .g(sg_sequence) // uint64 sequence = 1
    .g(sg_timestamp) // uint64 timestamp = 2
    .s(s_diversifier) // string diversifier = 3
    .v(xc_data_type) // DataType data_type = 4
    .b(atu8_data) // bytes data = 5
    .o;
/**
 * Encodes a `HeaderData` protobuf message: returns the SignBytes data for update verification.
 * @param atu8_new_pub_key - `new_pub_key`: header public key
 * @param s_new_diversifier - `new_diversifier`: header diversifier
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcLightclientsSolomachineHeaderData = (atu8_new_pub_key, s_new_diversifier) => Protobuf() // ...
    .b(atu8_new_pub_key) // Any new_pub_key = 1
    .s(s_new_diversifier) // string new_diversifier = 2
    .o;
/**
 * Encodes a `ClientStateData` protobuf message: returns the SignBytes data for client state verification.
 * @param atu8_path - `path`:
 * @param atu8_client_state - `client_state`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcLightclientsSolomachineClientStateData = (atu8_path, atu8_client_state) => Protobuf() // ...
    .b(atu8_path) // bytes path = 1
    .b(atu8_client_state) // Any client_state = 2
    .o;
/**
 * Encodes a `ConsensusStateData` protobuf message: returns the SignBytes data for consensus state verification.
 * @param atu8_path - `path`:
 * @param atu8_consensus_state - `consensus_state`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcLightclientsSolomachineConsensusStateData = (atu8_path, atu8_consensus_state) => Protobuf() // ...
    .b(atu8_path) // bytes path = 1
    .b(atu8_consensus_state) // Any consensus_state = 2
    .o;
/**
 * Encodes a `ConnectionStateData` protobuf message: returns the SignBytes data for connection state verification.
 * @param atu8_path - `path`:
 * @param g_connection - `connection`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcLightclientsSolomachineConnectionStateData = (atu8_path, atu8_connection) => Protobuf() // ...
    .b(atu8_path) // bytes path = 1
    .b(atu8_connection) // ConnectionEnd connection = 2
    .o;
/**
 * Encodes a `ChannelStateData` protobuf message: returns the SignBytes data for channel state verification.
 * @param atu8_path - `path`:
 * @param g_channel - `channel`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcLightclientsSolomachineChannelStateData = (atu8_path, atu8_channel) => Protobuf() // ...
    .b(atu8_path) // bytes path = 1
    .b(atu8_channel) // Channel channel = 2
    .o;
/**
 * Encodes a `PacketCommitmentData` protobuf message: returns the SignBytes data for packet commitment verification.
 * @param atu8_path - `path`:
 * @param atu8_commitment - `commitment`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcLightclientsSolomachinePacketCommitmentData = (atu8_path, atu8_commitment) => Protobuf() // ...
    .b(atu8_path) // bytes path = 1
    .b(atu8_commitment) // bytes commitment = 2
    .o;
/**
 * Encodes a `PacketAcknowledgementData` protobuf message: returns the SignBytes data for acknowledgement verification.
 * @param atu8_path - `path`:
 * @param atu8_acknowledgement - `acknowledgement`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcLightclientsSolomachinePacketAcknowledgementData = (atu8_path, atu8_acknowledgement) => Protobuf() // ...
    .b(atu8_path) // bytes path = 1
    .b(atu8_acknowledgement) // bytes acknowledgement = 2
    .o;
/**
 * Encodes a `PacketReceiptAbsenceData` protobuf message: returns the SignBytes data for packet receipt absence verification.
 * @param atu8_path - `path`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcLightclientsSolomachinePacketReceiptAbsenceData = (atu8_path) => Protobuf() // ...
    .b(atu8_path) // bytes path = 1
    .o;
/**
 * Encodes a `NextSequenceRecvData` protobuf message: returns the SignBytes data for verification of the next sequence to be received.
 * @param atu8_path - `path`:
 * @param sg_next_seq_recv - `next_seq_recv`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeIbcLightclientsSolomachineNextSequenceRecvData = (atu8_path, sg_next_seq_recv) => Protobuf() // ...
    .b(atu8_path) // bytes path = 1
    .g(sg_next_seq_recv) // uint64 next_seq_recv = 2
    .o;
/**
 * Decodes a protobuf ClientState message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineClientState}
 */
export const decodeIbcLightclientsSolomachineClientState = (atu8_payload) => decode_protobuf(atu8_payload, [3, 1, 1, 1], [0, 0, decodeIbcLightclientsSolomachineConsensusState]);
/**
 * Decodes a protobuf ConsensusState message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineConsensusState}
 */
export const decodeIbcLightclientsSolomachineConsensusState = (atu8_payload) => decode_protobuf(atu8_payload, [1, 5, 3], [decodeGoogleProtobufAny]);
/**
 * Decodes a protobuf Header message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineHeader}
 */
export const decodeIbcLightclientsSolomachineHeader = (atu8_payload) => decode_protobuf(atu8_payload, [3, 3, 1, 1, 5], [0, 0, 0, decodeGoogleProtobufAny]);
/**
 * Decodes a protobuf Misbehaviour message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineMisbehaviour}
 */
export const decodeIbcLightclientsSolomachineMisbehaviour = (atu8_payload) => decode_protobuf(atu8_payload, [5, 3, 1, 1], [0, 0, decodeIbcLightclientsSolomachineSignatureAndData, decodeIbcLightclientsSolomachineSignatureAndData]);
/**
 * Decodes a protobuf SignatureAndData message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineSignatureAndData}
 */
export const decodeIbcLightclientsSolomachineSignatureAndData = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1, 1, 3]);
/**
 * Decodes a protobuf TimestampedSignatureData message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineTimestampedSignatureData}
 */
export const decodeIbcLightclientsSolomachineTimestampedSignatureData = (atu8_payload) => decode_protobuf(atu8_payload, [1, 3]);
/**
 * Decodes a protobuf SignBytes message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineSignBytes}
 */
export const decodeIbcLightclientsSolomachineSignBytes = (atu8_payload) => decode_protobuf(atu8_payload, [3, 3, 5, 1, 1]);
/**
 * Decodes a protobuf HeaderData message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineHeaderData}
 */
export const decodeIbcLightclientsSolomachineHeaderData = (atu8_payload) => decode_protobuf(atu8_payload, [1, 5], [decodeGoogleProtobufAny]);
/**
 * Decodes a protobuf ClientStateData message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineClientStateData}
 */
export const decodeIbcLightclientsSolomachineClientStateData = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1], [0, decodeGoogleProtobufAny]);
/**
 * Decodes a protobuf ConsensusStateData message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineConsensusStateData}
 */
export const decodeIbcLightclientsSolomachineConsensusStateData = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1], [0, decodeGoogleProtobufAny]);
/**
 * Decodes a protobuf ConnectionStateData message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineConnectionStateData}
 */
export const decodeIbcLightclientsSolomachineConnectionStateData = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1], [0, decodeIbcCoreConnectionConnectionEnd]);
/**
 * Decodes a protobuf ChannelStateData message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineChannelStateData}
 */
export const decodeIbcLightclientsSolomachineChannelStateData = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1], [0, decodeIbcCoreChannelChannel]);
/**
 * Decodes a protobuf PacketCommitmentData message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachinePacketCommitmentData}
 */
export const decodeIbcLightclientsSolomachinePacketCommitmentData = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1]);
/**
 * Decodes a protobuf PacketAcknowledgementData message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachinePacketAcknowledgementData}
 */
export const decodeIbcLightclientsSolomachinePacketAcknowledgementData = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1]);
/**
 * Decodes a protobuf PacketReceiptAbsenceData message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachinePacketReceiptAbsenceData}
 */
export const decodeIbcLightclientsSolomachinePacketReceiptAbsenceData = (atu8_payload) => decode_protobuf(atu8_payload, [1]);
/**
 * Decodes a protobuf NextSequenceRecvData message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedIbcLightclientsSolomachineNextSequenceRecvData}
 */
export const decodeIbcLightclientsSolomachineNextSequenceRecvData = (atu8_payload) => decode_protobuf(atu8_payload, [1, 3]);
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineClientState} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: sequence - latest sequence of the client state
 *   - 1: is_frozen - frozen sequence of the solo machine
 *   - 2: consensus_state -
 *   - 3: allow_update_after_proposal - when set to true, will allow governance to update a solo machine client. The client will be unfrozen if it is frozen.
 */
export const destructIbcLightclientsSolomachineClientState = (g_struct) => [g_struct.sequence, g_struct.is_frozen, g_struct.consensus_state, g_struct.allow_update_after_proposal];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_CLIENT_STATE = '/ibc.lightclients.solomachine.v2.ClientState';
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineConsensusState} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: public_key - public key of the solo machine
 *   - 1: diversifier - allows the same public key to be re-used across different solo machine clients (potentially on different chains) without being considered misbehaviour.
 *   - 2: timestamp -
 */
export const destructIbcLightclientsSolomachineConsensusState = (g_struct) => [g_struct.public_key, g_struct.diversifier, g_struct.timestamp];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_CONSENSUS_STATE = '/ibc.lightclients.solomachine.v2.ConsensusState';
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineHeader} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: sequence - to update solo machine public key at
 *   - 1: timestamp -
 *   - 2: signature -
 *   - 3: new_public_key -
 *   - 4: new_diversifier -
 */
export const destructIbcLightclientsSolomachineHeader = (g_struct) => [g_struct.sequence, g_struct.timestamp, safe_base64_to_bytes(g_struct.signature), g_struct.new_public_key, g_struct.new_diversifier];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_HEADER = '/ibc.lightclients.solomachine.v2.Header';
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineMisbehaviour} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: client_id -
 *   - 1: sequence -
 *   - 2: signature_one -
 *   - 3: signature_two -
 */
export const destructIbcLightclientsSolomachineMisbehaviour = (g_struct) => [g_struct.client_id, g_struct.sequence, g_struct.signature_one, g_struct.signature_two];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_MISBEHAVIOUR = '/ibc.lightclients.solomachine.v2.Misbehaviour';
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineSignatureAndData} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: signature -
 *   - 1: data_type -
 *   - 2: data -
 *   - 3: timestamp -
 */
export const destructIbcLightclientsSolomachineSignatureAndData = (g_struct) => [safe_base64_to_bytes(g_struct.signature), g_struct.data_type, safe_base64_to_bytes(g_struct.data), g_struct.timestamp];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_SIGNATURE_AND_DATA = '/ibc.lightclients.solomachine.v2.SignatureAndData';
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineTimestampedSignatureData} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: signature_data -
 *   - 1: timestamp -
 */
export const destructIbcLightclientsSolomachineTimestampedSignatureData = (g_struct) => [safe_base64_to_bytes(g_struct.signature_data), g_struct.timestamp];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_TIMESTAMPED_SIGNATURE_DATA = '/ibc.lightclients.solomachine.v2.TimestampedSignatureData';
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineSignBytes} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: sequence -
 *   - 1: timestamp -
 *   - 2: diversifier -
 *   - 3: data_type - type of the data used
 *   - 4: data - marshaled data
 */
export const destructIbcLightclientsSolomachineSignBytes = (g_struct) => [g_struct.sequence, g_struct.timestamp, g_struct.diversifier, g_struct.data_type, safe_base64_to_bytes(g_struct.data)];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_SIGN_BYTES = '/ibc.lightclients.solomachine.v2.SignBytes';
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineHeaderData} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: new_pub_key - header public key
 *   - 1: new_diversifier - header diversifier
 */
export const destructIbcLightclientsSolomachineHeaderData = (g_struct) => [g_struct.new_pub_key, g_struct.new_diversifier];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_HEADER_DATA = '/ibc.lightclients.solomachine.v2.HeaderData';
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineClientStateData} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: path -
 *   - 1: client_state -
 */
export const destructIbcLightclientsSolomachineClientStateData = (g_struct) => [safe_base64_to_bytes(g_struct.path), g_struct.client_state];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_CLIENT_STATE_DATA = '/ibc.lightclients.solomachine.v2.ClientStateData';
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineConsensusStateData} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: path -
 *   - 1: consensus_state -
 */
export const destructIbcLightclientsSolomachineConsensusStateData = (g_struct) => [safe_base64_to_bytes(g_struct.path), g_struct.consensus_state];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_CONSENSUS_STATE_DATA = '/ibc.lightclients.solomachine.v2.ConsensusStateData';
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineConnectionStateData} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: path -
 *   - 1: connection -
 */
export const destructIbcLightclientsSolomachineConnectionStateData = (g_struct) => [safe_base64_to_bytes(g_struct.path), g_struct.connection];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_CONNECTION_STATE_DATA = '/ibc.lightclients.solomachine.v2.ConnectionStateData';
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineChannelStateData} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: path -
 *   - 1: channel -
 */
export const destructIbcLightclientsSolomachineChannelStateData = (g_struct) => [safe_base64_to_bytes(g_struct.path), g_struct.channel];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_CHANNEL_STATE_DATA = '/ibc.lightclients.solomachine.v2.ChannelStateData';
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachinePacketCommitmentData} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: path -
 *   - 1: commitment -
 */
export const destructIbcLightclientsSolomachinePacketCommitmentData = (g_struct) => [safe_base64_to_bytes(g_struct.path), safe_base64_to_bytes(g_struct.commitment)];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_PACKET_COMMITMENT_DATA = '/ibc.lightclients.solomachine.v2.PacketCommitmentData';
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachinePacketAcknowledgementData} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: path -
 *   - 1: acknowledgement -
 */
export const destructIbcLightclientsSolomachinePacketAcknowledgementData = (g_struct) => [safe_base64_to_bytes(g_struct.path), safe_base64_to_bytes(g_struct.acknowledgement)];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_PACKET_ACKNOWLEDGEMENT_DATA = '/ibc.lightclients.solomachine.v2.PacketAcknowledgementData';
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachinePacketReceiptAbsenceData} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: path -
 */
export const destructIbcLightclientsSolomachinePacketReceiptAbsenceData = (g_struct) => [safe_base64_to_bytes(g_struct.path)];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_PACKET_RECEIPT_ABSENCE_DATA = '/ibc.lightclients.solomachine.v2.PacketReceiptAbsenceData';
/**
 * Destructures the fields of a {@link IbcLightclientsSolomachineNextSequenceRecvData} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: path -
 *   - 1: next_seq_recv -
 */
export const destructIbcLightclientsSolomachineNextSequenceRecvData = (g_struct) => [safe_base64_to_bytes(g_struct.path), g_struct.next_seq_recv];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_IBC_LIGHTCLIENTS_SOLOMACHINE_NEXT_SEQUENCE_RECV_DATA = '/ibc.lightclients.solomachine.v2.NextSequenceRecvData';
/**
 * Protobuf enum value for `ibc.lightclients.solomachine.v2.DataType`.
 *
 * **DATA_TYPE_UNINITIALIZED_UNSPECIFIED** - Default State
 *
 * Belongs to enum type {@link ProtoEnumIbcLightclientsSolomachineDataType}
 */
export const XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_UNINITIALIZED_UNSPECIFIED = 0;
/**
 * JSON enum value for `ibc.lightclients.solomachine.v2.DataType`.
 *
 * **DATA_TYPE_UNINITIALIZED_UNSPECIFIED** - Default State
 *
 * Belongs to enum type {@link JsonEnumIbcLightclientsSolomachineDataType}
 */
export const SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_UNINITIALIZED_UNSPECIFIED = 'UNSPECIFIED';
/**
 * Protobuf enum value for `ibc.lightclients.solomachine.v2.DataType`.
 *
 * **DATA_TYPE_CLIENT_STATE** - Data type for client state verification
 *
 * Belongs to enum type {@link ProtoEnumIbcLightclientsSolomachineDataType}
 */
export const XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_CLIENT_STATE = 1;
/**
 * JSON enum value for `ibc.lightclients.solomachine.v2.DataType`.
 *
 * **DATA_TYPE_CLIENT_STATE** - Data type for client state verification
 *
 * Belongs to enum type {@link JsonEnumIbcLightclientsSolomachineDataType}
 */
export const SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_CLIENT_STATE = 'CLIENT';
/**
 * Protobuf enum value for `ibc.lightclients.solomachine.v2.DataType`.
 *
 * **DATA_TYPE_CONSENSUS_STATE** - Data type for consensus state verification
 *
 * Belongs to enum type {@link ProtoEnumIbcLightclientsSolomachineDataType}
 */
export const XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_CONSENSUS_STATE = 2;
/**
 * JSON enum value for `ibc.lightclients.solomachine.v2.DataType`.
 *
 * **DATA_TYPE_CONSENSUS_STATE** - Data type for consensus state verification
 *
 * Belongs to enum type {@link JsonEnumIbcLightclientsSolomachineDataType}
 */
export const SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_CONSENSUS_STATE = 'CONSENSUS';
/**
 * Protobuf enum value for `ibc.lightclients.solomachine.v2.DataType`.
 *
 * **DATA_TYPE_CONNECTION_STATE** - Data type for connection state verification
 *
 * Belongs to enum type {@link ProtoEnumIbcLightclientsSolomachineDataType}
 */
export const XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_CONNECTION_STATE = 3;
/**
 * JSON enum value for `ibc.lightclients.solomachine.v2.DataType`.
 *
 * **DATA_TYPE_CONNECTION_STATE** - Data type for connection state verification
 *
 * Belongs to enum type {@link JsonEnumIbcLightclientsSolomachineDataType}
 */
export const SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_CONNECTION_STATE = 'CONNECTION';
/**
 * Protobuf enum value for `ibc.lightclients.solomachine.v2.DataType`.
 *
 * **DATA_TYPE_CHANNEL_STATE** - Data type for channel state verification
 *
 * Belongs to enum type {@link ProtoEnumIbcLightclientsSolomachineDataType}
 */
export const XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_CHANNEL_STATE = 4;
/**
 * JSON enum value for `ibc.lightclients.solomachine.v2.DataType`.
 *
 * **DATA_TYPE_CHANNEL_STATE** - Data type for channel state verification
 *
 * Belongs to enum type {@link JsonEnumIbcLightclientsSolomachineDataType}
 */
export const SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_CHANNEL_STATE = 'CHANNEL';
/**
 * Protobuf enum value for `ibc.lightclients.solomachine.v2.DataType`.
 *
 * **DATA_TYPE_PACKET_COMMITMENT** - Data type for packet commitment verification
 *
 * Belongs to enum type {@link ProtoEnumIbcLightclientsSolomachineDataType}
 */
export const XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_PACKET_COMMITMENT = 5;
/**
 * JSON enum value for `ibc.lightclients.solomachine.v2.DataType`.
 *
 * **DATA_TYPE_PACKET_COMMITMENT** - Data type for packet commitment verification
 *
 * Belongs to enum type {@link JsonEnumIbcLightclientsSolomachineDataType}
 */
export const SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_PACKET_COMMITMENT = 'PACKETCOMMITMENT';
/**
 * Protobuf enum value for `ibc.lightclients.solomachine.v2.DataType`.
 *
 * **DATA_TYPE_PACKET_ACKNOWLEDGEMENT** - Data type for packet acknowledgement verification
 *
 * Belongs to enum type {@link ProtoEnumIbcLightclientsSolomachineDataType}
 */
export const XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_PACKET_ACKNOWLEDGEMENT = 6;
/**
 * JSON enum value for `ibc.lightclients.solomachine.v2.DataType`.
 *
 * **DATA_TYPE_PACKET_ACKNOWLEDGEMENT** - Data type for packet acknowledgement verification
 *
 * Belongs to enum type {@link JsonEnumIbcLightclientsSolomachineDataType}
 */
export const SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_PACKET_ACKNOWLEDGEMENT = 'PACKETACKNOWLEDGEMENT';
/**
 * Protobuf enum value for `ibc.lightclients.solomachine.v2.DataType`.
 *
 * **DATA_TYPE_PACKET_RECEIPT_ABSENCE** - Data type for packet receipt absence verification
 *
 * Belongs to enum type {@link ProtoEnumIbcLightclientsSolomachineDataType}
 */
export const XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_PACKET_RECEIPT_ABSENCE = 7;
/**
 * JSON enum value for `ibc.lightclients.solomachine.v2.DataType`.
 *
 * **DATA_TYPE_PACKET_RECEIPT_ABSENCE** - Data type for packet receipt absence verification
 *
 * Belongs to enum type {@link JsonEnumIbcLightclientsSolomachineDataType}
 */
export const SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_PACKET_RECEIPT_ABSENCE = 'PACKETRECEIPTABSENCE';
/**
 * Protobuf enum value for `ibc.lightclients.solomachine.v2.DataType`.
 *
 * **DATA_TYPE_NEXT_SEQUENCE_RECV** - Data type for next sequence recv verification
 *
 * Belongs to enum type {@link ProtoEnumIbcLightclientsSolomachineDataType}
 */
export const XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_NEXT_SEQUENCE_RECV = 8;
/**
 * JSON enum value for `ibc.lightclients.solomachine.v2.DataType`.
 *
 * **DATA_TYPE_NEXT_SEQUENCE_RECV** - Data type for next sequence recv verification
 *
 * Belongs to enum type {@link JsonEnumIbcLightclientsSolomachineDataType}
 */
export const SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_NEXT_SEQUENCE_RECV = 'NEXTSEQUENCERECV';
/**
 * Protobuf enum value for `ibc.lightclients.solomachine.v2.DataType`.
 *
 * **DATA_TYPE_HEADER** - Data type for header verification
 *
 * Belongs to enum type {@link ProtoEnumIbcLightclientsSolomachineDataType}
 */
export const XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_HEADER = 9;
/**
 * JSON enum value for `ibc.lightclients.solomachine.v2.DataType`.
 *
 * **DATA_TYPE_HEADER** - Data type for header verification
 *
 * Belongs to enum type {@link JsonEnumIbcLightclientsSolomachineDataType}
 */
export const SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_HEADER = 'HEADER';
/**
 * Maps a protobuf enum int value for `ibc.lightclients.solomachine.v2.DataType` to is JSON equivalent enum string value
 */
export const ProtoToJsonEnumIbcLightclientsSolomachineDataType = {
    [XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_UNINITIALIZED_UNSPECIFIED]: SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_UNINITIALIZED_UNSPECIFIED,
    [XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_CLIENT_STATE]: SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_CLIENT_STATE,
    [XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_CONSENSUS_STATE]: SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_CONSENSUS_STATE,
    [XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_CONNECTION_STATE]: SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_CONNECTION_STATE,
    [XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_CHANNEL_STATE]: SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_CHANNEL_STATE,
    [XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_PACKET_COMMITMENT]: SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_PACKET_COMMITMENT,
    [XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_PACKET_ACKNOWLEDGEMENT]: SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_PACKET_ACKNOWLEDGEMENT,
    [XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_PACKET_RECEIPT_ABSENCE]: SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_PACKET_RECEIPT_ABSENCE,
    [XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_NEXT_SEQUENCE_RECV]: SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_NEXT_SEQUENCE_RECV,
    [XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_HEADER]: SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_HEADER,
};
/**
 * Maps a JSON enum string value for `ibc.lightclients.solomachine.v2.DataType` to is protobuf equivalent enum int value
 */
export const JsonToProtoEnumIbcLightclientsSolomachineDataType = {
    [SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_UNINITIALIZED_UNSPECIFIED]: XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_UNINITIALIZED_UNSPECIFIED,
    [SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_CLIENT_STATE]: XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_CLIENT_STATE,
    [SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_CONSENSUS_STATE]: XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_CONSENSUS_STATE,
    [SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_CONNECTION_STATE]: XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_CONNECTION_STATE,
    [SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_CHANNEL_STATE]: XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_CHANNEL_STATE,
    [SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_PACKET_COMMITMENT]: XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_PACKET_COMMITMENT,
    [SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_PACKET_ACKNOWLEDGEMENT]: XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_PACKET_ACKNOWLEDGEMENT,
    [SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_PACKET_RECEIPT_ABSENCE]: XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_PACKET_RECEIPT_ABSENCE,
    [SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_NEXT_SEQUENCE_RECV]: XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_NEXT_SEQUENCE_RECV,
    [SI_JSON_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_HEADER]: XC_PROTO_IBC_LIGHTCLIENTS_SOLOMACHINE_DATA_TYPE_HEADER,
};
//# sourceMappingURL=solomachine.js.map