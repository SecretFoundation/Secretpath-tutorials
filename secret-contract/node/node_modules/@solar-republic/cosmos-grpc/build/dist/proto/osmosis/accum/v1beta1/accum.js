/*
* ================================
*     GENERATED FILE WARNING
* Do not edit this file manually.
* ================================
*/
import { decode_protobuf } from '../../../../api/protobuf-reader.js';
import { Protobuf } from '../../../../api/protobuf-writer.js';
import { decodeCosmosBaseDecCoin } from '../../../cosmos/base/v1beta1/coin.js';
/**
 * Encodes a `AccumulatorContent` protobuf message: the state-entry for the global accumulator. It contains the name of the global accumulator and the total value of shares belonging to it from all positions.
 * @param a_accum_values - `accum_value`:
 * @param s_total_shares - `total_shares`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeOsmosisAccumAccumulatorContent = (a_accum_values, s_total_shares) => Protobuf() // ...
    .B(a_accum_values) // DecCoin[] accum_value = 1
    .s(s_total_shares) // string total_shares = 2
    .o;
/**
 * Encodes a `Options` protobuf message:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeOsmosisAccumOptions = () => Protobuf() // ...
    .o;
/**
 * Encodes a `Record` protobuf message: corresponds to an individual position value belonging to the global accumulator.
 * @param s_num_shares - `num_shares`: the number of shares belonging to the position associated with this record.
 * @param a_accum_value_per_shares - `accum_value_per_share`: the subset of coins per shar of the global accumulator value that allows to infer how much a position is entitled to per share that it owns. In the default case with no intervals, this value equals to the global accumulator value at the time of the position creation, the last update or reward claim. In the interval case such as concentrated liquidity, this value equals to the global growth of rewards inside the interval during one of: the time of the position creation, the last update or reward claim. Note, that immediately prior to claiming or updating rewards, this value must be updated to "the growth inside at the time of last update + the growth outside at the time of the current block". This is so that the claiming logic can subtract this updated value from the global accumulator value to get the growth inside the interval from the time of last update up until the current block time.
 * @param a_unclaimed_rewards_totals - `unclaimed_rewards_total`: the total amount of unclaimed rewards that the position is entitled to. This value is updated whenever shares are added or removed from an existing position. We also expose API for manually updating this value for some custom use cases such as merging pre-existing positions into a single one.
 * @param g_options - `options`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeOsmosisAccumRecord = (s_num_shares, a_accum_value_per_shares, a_unclaimed_rewards_totals, atu8_options) => Protobuf() // ...
    .s(s_num_shares) // string num_shares = 1
    .B(a_accum_value_per_shares) // DecCoin[] accum_value_per_share = 2
    .B(a_unclaimed_rewards_totals) // DecCoin[] unclaimed_rewards_total = 3
    .b(atu8_options) // Options options = 4
    .o;
/**
 * Decodes a protobuf AccumulatorContent message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisAccumAccumulatorContent}
 */
export const decodeOsmosisAccumAccumulatorContent = (atu8_payload) => decode_protobuf(atu8_payload, [0, 5], [decodeCosmosBaseDecCoin]);
/**
 * Decodes a protobuf Options message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisAccumOptions}
 */
export const decodeOsmosisAccumOptions = (atu8_payload) => decode_protobuf(atu8_payload);
/**
 * Decodes a protobuf Record message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisAccumRecord}
 */
export const decodeOsmosisAccumRecord = (atu8_payload) => decode_protobuf(atu8_payload, [5, 0, 0, 1], [0, decodeCosmosBaseDecCoin, decodeCosmosBaseDecCoin, decodeOsmosisAccumOptions]);
/**
 * Destructures the fields of a {@link OsmosisAccumAccumulatorContent} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: accum_value -
 *   - 1: total_shares -
 */
export const destructOsmosisAccumAccumulatorContent = (g_struct) => [g_struct.accum_value, g_struct.total_shares];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_OSMOSIS_ACCUM_ACCUMULATOR_CONTENT = '/osmosis.accum.v1beta1.AccumulatorContent';
/**
 * Destructures the fields of a {@link OsmosisAccumOptions} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 */
export const destructOsmosisAccumOptions = (g_struct) => [];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_OSMOSIS_ACCUM_OPTIONS = '/osmosis.accum.v1beta1.Options';
/**
 * Destructures the fields of a {@link OsmosisAccumRecord} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: num_shares - the number of shares belonging to the position associated with this record.
 *   - 1: accum_value_per_share - the subset of coins per shar of the global accumulator value that allows to infer how much a position is entitled to per share that it owns. In the default case with no intervals, this value equals to the global accumulator value at the time of the position creation, the last update or reward claim. In the interval case such as concentrated liquidity, this value equals to the global growth of rewards inside the interval during one of: the time of the position creation, the last update or reward claim. Note, that immediately prior to claiming or updating rewards, this value must be updated to "the growth inside at the time of last update + the growth outside at the time of the current block". This is so that the claiming logic can subtract this updated value from the global accumulator value to get the growth inside the interval from the time of last update up until the current block time.
 *   - 2: unclaimed_rewards_total - the total amount of unclaimed rewards that the position is entitled to. This value is updated whenever shares are added or removed from an existing position. We also expose API for manually updating this value for some custom use cases such as merging pre-existing positions into a single one.
 *   - 3: options -
 */
export const destructOsmosisAccumRecord = (g_struct) => [g_struct.num_shares, g_struct.accum_value_per_share, g_struct.unclaimed_rewards_total, g_struct.options];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_OSMOSIS_ACCUM_RECORD = '/osmosis.accum.v1beta1.Record';
//# sourceMappingURL=accum.js.map