import { decode_protobuf } from '../../../../../api/protobuf-reader.js';
import { Protobuf, any } from '../../../../../api/protobuf-writer.js';
import { safe_base64_to_bytes } from '../../../../../api/util.js';
/**
 * Encodes a `CosmWasmPool` protobuf message wrapped in the `Any` container: represents the data serialized into state for each CW pool. Note: CW Pool has 2 pool models: - CosmWasmPool which is a proto-generated store model used for serialization into state. - Pool struct that encapsulates the CosmWasmPool and wasmKeeper for calling the contract. CosmWasmPool implements the poolmanager.PoolI interface but it panics on all methods. The reason is that access to wasmKeeper is required to call the contract. Instead, all interactions and poolmanager.PoolI methods are to be performed on the Pool struct. The reason why we cannot have a Pool struct only is because it cannot be serialized into state due to having a non-serializable wasmKeeper field.
 * @param sa_contract - `contract_address`:
 * @param sg_pool_id - `pool_id`:
 * @param sg_code_id - `code_id`:
 * @param atu8_instantiate_msg - `instantiate_msg`:
 * @returns a strongly subtyped Uint8Array representing an `Any` protobuf message
 */
export const anyCosmWasmPool = (sa_contract, sg_pool_id, sg_code_id, atu8_instantiate_msg) => any('/osmosis.cosmwasmpool.v1beta1.CosmWasmPool', Protobuf() // ...
    .s(sa_contract) // string contract_address = 1
    .g(sg_pool_id) // uint64 pool_id = 2
    .g(sg_code_id) // uint64 code_id = 3
    .b(atu8_instantiate_msg) // bytes instantiate_msg = 4
    .o);
/**
 * Encodes a `CosmWasmPool` protobuf message: represents the data serialized into state for each CW pool. Note: CW Pool has 2 pool models: - CosmWasmPool which is a proto-generated store model used for serialization into state. - Pool struct that encapsulates the CosmWasmPool and wasmKeeper for calling the contract. CosmWasmPool implements the poolmanager.PoolI interface but it panics on all methods. The reason is that access to wasmKeeper is required to call the contract. Instead, all interactions and poolmanager.PoolI methods are to be performed on the Pool struct. The reason why we cannot have a Pool struct only is because it cannot be serialized into state due to having a non-serializable wasmKeeper field.
 * @param sa_contract - `contract_address`:
 * @param sg_pool_id - `pool_id`:
 * @param sg_code_id - `code_id`:
 * @param atu8_instantiate_msg - `instantiate_msg`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeOsmosisCosmwasmpoolCosmWasmPool = (sa_contract, sg_pool_id, sg_code_id, atu8_instantiate_msg) => Protobuf() // ...
    .s(sa_contract) // string contract_address = 1
    .g(sg_pool_id) // uint64 pool_id = 2
    .g(sg_code_id) // uint64 code_id = 3
    .b(atu8_instantiate_msg) // bytes instantiate_msg = 4
    .o;
/**
 * Decodes a protobuf CosmWasmPool message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisCosmwasmpoolCosmWasmPool}
 */
export const decodeOsmosisCosmwasmpoolCosmWasmPool = (atu8_payload) => decode_protobuf(atu8_payload, [5, 3, 3, 1]);
/**
 * Destructures the fields of a {@link OsmosisCosmwasmpoolCosmWasmPool} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: contract_address -
 *   - 1: pool_id -
 *   - 2: code_id -
 *   - 3: instantiate_msg -
 */
export const destructOsmosisCosmwasmpoolCosmWasmPool = (g_struct) => [g_struct.contract_address, g_struct.pool_id, g_struct.code_id, safe_base64_to_bytes(g_struct.instantiate_msg)];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_OSMOSIS_COSMWASMPOOL_COSM_WASM_POOL = '/osmosis.cosmwasmpool.v1beta1.CosmWasmPool';
//# sourceMappingURL=pool.js.map