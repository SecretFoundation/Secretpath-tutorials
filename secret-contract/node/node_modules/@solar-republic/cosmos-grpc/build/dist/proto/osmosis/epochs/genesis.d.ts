import type { WeakInt64Str, CwInt64 } from '@solar-republic/types';
import type { Encoded, Opt, WeakTimestampStr, WeakDurationStr } from '../../../api/types.js';
export type EncodedOsmosisEpochsEpochInfo = Encoded<'/osmosis.epochs.v1beta1.EpochInfo'>;
export type EncodedOsmosisEpochsGenesisState = Encoded<'/osmosis.epochs.v1beta1.GenesisState'>;
/**
 * Encodes a `EpochInfo` protobuf message: a struct that describes the data going into a timer defined by the x/epochs module.
 * @param s_identifier - `identifier`: a unique reference to this particular timer.
 * @param xt_start_time - `start_time`: the time at which the timer first ever ticks. If start_time is in the future, the epoch will not begin until the start time.
 * @param xt_duration - `duration`: the time in between epoch ticks. In order for intended behavior to be met, duration should be greater than the chains expected block time. Duration must be non-zero.
 * @param sg_current_epoch - `current_epoch`: the current epoch number, or in other words, how many times has the timer 'ticked'. The first tick (current_epoch=1) is defined as the first block whose blocktime is greater than the EpochInfo start_time.
 * @param xt_current_epoch_start_time - `current_epoch_start_time`: describes the start time of the current timer interval. The interval is (current_epoch_start_time, current_epoch_start_time + duration] When the timer ticks, this is set to current_epoch_start_time = last_epoch_start_time + duration only one timer tick for a given identifier can occur per block. NOTE! The current_epoch_start_time may diverge significantly from the wall-clock time the epoch began at. Wall-clock time of epoch start may be >> current_epoch_start_time. Suppose current_epoch_start_time = 10, duration = 5. Suppose the chain goes offline at t=14, and comes back online at t=30, and produces blocks at every successive time. (t=31, 32, etc.) * The t=30 block will start the epoch for (10, 15] * The t=31 block will start the epoch for (15, 20] * The t=32 block will start the epoch for (20, 25] * The t=33 block will start the epoch for (25, 30] * The t=34 block will start the epoch for (30, 35] * The **t=36** block will start the epoch for (35, 40]
 * @param b_epoch_counting_started - `epoch_counting_started`: a boolean, that indicates whether this epoch timer has began yet.
 * @param sg_current_epoch_start_height - `current_epoch_start_height`: the block height at which the current epoch started. (The block height at which the timer last ticked)
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisEpochsEpochInfo: (s_identifier?: Opt<string>, xt_start_time?: Opt<number>, xt_duration?: Opt<number>, sg_current_epoch?: Opt<WeakInt64Str>, xt_current_epoch_start_time?: Opt<number>, b_epoch_counting_started?: Opt<boolean | 0 | 1>, sg_current_epoch_start_height?: Opt<WeakInt64Str>) => EncodedOsmosisEpochsEpochInfo;
/**
 * Encodes a `GenesisState` protobuf message: defines the epochs module's genesis state.
 * @param a_epochs - `epochs`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisEpochsGenesisState: (a_epochs?: Opt<Encoded<'/osmosis.epochs.v1beta1.EpochInfo'>[]>) => EncodedOsmosisEpochsGenesisState;
/**
 * A decoded protobuf EpochInfo message
 *
 * Tuple where:
 *   - 0: identifier - a unique reference to this particular timer.
 *   - 1: start_time - the time at which the timer first ever ticks. If start_time is in the future, the epoch will not begin until the start time.
 *   - 2: duration - the time in between epoch ticks. In order for intended behavior to be met, duration should be greater than the chains expected block time. Duration must be non-zero.
 *   - 3: current_epoch - the current epoch number, or in other words, how many times has the timer 'ticked'. The first tick (current_epoch=1) is defined as the first block whose blocktime is greater than the EpochInfo start_time.
 *   - 4: current_epoch_start_time - describes the start time of the current timer interval. The interval is (current_epoch_start_time, current_epoch_start_time + duration] When the timer ticks, this is set to current_epoch_start_time = last_epoch_start_time + duration only one timer tick for a given identifier can occur per block. NOTE! The current_epoch_start_time may diverge significantly from the wall-clock time the epoch began at. Wall-clock time of epoch start may be >> current_epoch_start_time. Suppose current_epoch_start_time = 10, duration = 5. Suppose the chain goes offline at t=14, and comes back online at t=30, and produces blocks at every successive time. (t=31, 32, etc.) * The t=30 block will start the epoch for (10, 15] * The t=31 block will start the epoch for (15, 20] * The t=32 block will start the epoch for (20, 25] * The t=33 block will start the epoch for (25, 30] * The t=34 block will start the epoch for (30, 35] * The **t=36** block will start the epoch for (35, 40]
 *   - 5: epoch_counting_started - a boolean, that indicates whether this epoch timer has began yet.
 *   - 7: current_epoch_start_height - the block height at which the current epoch started. (The block height at which the timer last ticked)
 */
export type DecodedOsmosisEpochsEpochInfo = [
    s_identifier?: string,
    a_start_time?: [
        string,
        number
    ],
    a_duration?: [
        string,
        number
    ],
    sg_current_epoch?: CwInt64,
    a_current_epoch_start_time?: [
        string,
        number
    ],
    b_epoch_counting_started?: 0 | 1,
    w_0?: undefined,
    sg_current_epoch_start_height?: CwInt64
];
/**
 * Decodes a protobuf EpochInfo message
 * @param atu8_payload - raw bytes to decode
 * @param RESERVED - a second argument is explicitly forbidden. make sure not to pass this function by reference to some callback argument
 * @returns a {@link DecodedOsmosisEpochsEpochInfo}
 */
export declare const decodeOsmosisEpochsEpochInfo: (atu8_payload: Uint8Array, RESERVED?: never) => DecodedOsmosisEpochsEpochInfo;
/**
 * A decoded protobuf GenesisState message
 *
 * Alias for: epochs -
 */
export type DecodedOsmosisEpochsGenesisState = [
    a_epochs?: DecodedOsmosisEpochsEpochInfo[]
];
/**
 * Decodes a protobuf GenesisState message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisEpochsGenesisState}
 */
export declare const decodeOsmosisEpochsGenesisState: (atu8_payload: Uint8Array) => DecodedOsmosisEpochsGenesisState;
/**
 * Destructures the fields of a {@link OsmosisEpochsEpochInfo} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: identifier - a unique reference to this particular timer.
 *   - 1: start_time - the time at which the timer first ever ticks. If start_time is in the future, the epoch will not begin until the start time.
 *   - 2: duration - the time in between epoch ticks. In order for intended behavior to be met, duration should be greater than the chains expected block time. Duration must be non-zero.
 *   - 3: current_epoch - the current epoch number, or in other words, how many times has the timer 'ticked'. The first tick (current_epoch=1) is defined as the first block whose blocktime is greater than the EpochInfo start_time.
 *   - 4: current_epoch_start_time - describes the start time of the current timer interval. The interval is (current_epoch_start_time, current_epoch_start_time + duration] When the timer ticks, this is set to current_epoch_start_time = last_epoch_start_time + duration only one timer tick for a given identifier can occur per block. NOTE! The current_epoch_start_time may diverge significantly from the wall-clock time the epoch began at. Wall-clock time of epoch start may be >> current_epoch_start_time. Suppose current_epoch_start_time = 10, duration = 5. Suppose the chain goes offline at t=14, and comes back online at t=30, and produces blocks at every successive time. (t=31, 32, etc.) * The t=30 block will start the epoch for (10, 15] * The t=31 block will start the epoch for (15, 20] * The t=32 block will start the epoch for (20, 25] * The t=33 block will start the epoch for (25, 30] * The t=34 block will start the epoch for (30, 35] * The **t=36** block will start the epoch for (35, 40]
 *   - 5: epoch_counting_started - a boolean, that indicates whether this epoch timer has began yet.
 *   - 7: current_epoch_start_height - the block height at which the current epoch started. (The block height at which the timer last ticked)
 */
export declare const destructOsmosisEpochsEpochInfo: (g_struct: OsmosisEpochsEpochInfo) => [identifier?: string, start_time?: number, duration?: number, current_epoch?: CwInt64, current_epoch_start_time?: number, epoch_counting_started?: boolean, EMPTY?: void, current_epoch_start_height?: CwInt64];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_EPOCHS_EPOCH_INFO = "/osmosis.epochs.v1beta1.EpochInfo";
/**
 * JSON serialization of `osmosis.epochs.v1beta1.EpochInfo` - a struct that describes the data going into a timer defined by the x/epochs module.
 */
export type OsmosisEpochsEpochInfo = {
    identifier?: string | undefined;
    start_time?: WeakTimestampStr | undefined;
    duration?: WeakDurationStr | undefined;
    current_epoch?: CwInt64 | undefined;
    current_epoch_start_time?: WeakTimestampStr | undefined;
    epoch_counting_started?: boolean | undefined;
    current_epoch_start_height?: CwInt64 | undefined;
};
/**
 * Destructures the fields of a {@link OsmosisEpochsGenesisState} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: epochs -
 */
export declare const destructOsmosisEpochsGenesisState: (g_struct: OsmosisEpochsGenesisState) => [epochs?: OsmosisEpochsEpochInfo[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_EPOCHS_GENESIS_STATE = "/osmosis.epochs.v1beta1.GenesisState";
/**
 * JSON serialization of `osmosis.epochs.v1beta1.GenesisState` - defines the epochs module's genesis state.
 */
export type OsmosisEpochsGenesisState = {
    epochs?: OsmosisEpochsEpochInfo[] | undefined;
};
