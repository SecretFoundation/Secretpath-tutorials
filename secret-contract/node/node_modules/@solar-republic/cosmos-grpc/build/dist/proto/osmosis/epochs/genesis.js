import { __UNDEFINED } from '@blake.regalia/belt';
import { parse_duration, parse_timestamp } from '../../../api/json.js';
import { decode_protobuf, decode_temporal } from '../../../api/protobuf-reader.js';
import { Protobuf, temporal } from '../../../api/protobuf-writer.js';
/**
 * Encodes a `EpochInfo` protobuf message: a struct that describes the data going into a timer defined by the x/epochs module.
 * @param s_identifier - `identifier`: a unique reference to this particular timer.
 * @param xt_start_time - `start_time`: the time at which the timer first ever ticks. If start_time is in the future, the epoch will not begin until the start time.
 * @param xt_duration - `duration`: the time in between epoch ticks. In order for intended behavior to be met, duration should be greater than the chains expected block time. Duration must be non-zero.
 * @param sg_current_epoch - `current_epoch`: the current epoch number, or in other words, how many times has the timer 'ticked'. The first tick (current_epoch=1) is defined as the first block whose blocktime is greater than the EpochInfo start_time.
 * @param xt_current_epoch_start_time - `current_epoch_start_time`: describes the start time of the current timer interval. The interval is (current_epoch_start_time, current_epoch_start_time + duration] When the timer ticks, this is set to current_epoch_start_time = last_epoch_start_time + duration only one timer tick for a given identifier can occur per block. NOTE! The current_epoch_start_time may diverge significantly from the wall-clock time the epoch began at. Wall-clock time of epoch start may be >> current_epoch_start_time. Suppose current_epoch_start_time = 10, duration = 5. Suppose the chain goes offline at t=14, and comes back online at t=30, and produces blocks at every successive time. (t=31, 32, etc.) * The t=30 block will start the epoch for (10, 15] * The t=31 block will start the epoch for (15, 20] * The t=32 block will start the epoch for (20, 25] * The t=33 block will start the epoch for (25, 30] * The t=34 block will start the epoch for (30, 35] * The **t=36** block will start the epoch for (35, 40]
 * @param b_epoch_counting_started - `epoch_counting_started`: a boolean, that indicates whether this epoch timer has began yet.
 * @param sg_current_epoch_start_height - `current_epoch_start_height`: the block height at which the current epoch started. (The block height at which the timer last ticked)
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeOsmosisEpochsEpochInfo = (s_identifier, xt_start_time, xt_duration, sg_current_epoch, xt_current_epoch_start_time, b_epoch_counting_started, sg_current_epoch_start_height) => Protobuf() // ...
    .s(s_identifier) // string identifier = 1
    .b(temporal(xt_start_time)) // Timestamp start_time = 2
    .b(temporal(xt_duration)) // Duration duration = 3
    .g(sg_current_epoch) // int32 current_epoch = 4
    .b(temporal(xt_current_epoch_start_time)) // Timestamp current_epoch_start_time = 5
    .v(b_epoch_counting_started) // boolean epoch_counting_started = 6
    .g(sg_current_epoch_start_height, 8) // int32 current_epoch_start_height = 8
    .o;
/**
 * Encodes a `GenesisState` protobuf message: defines the epochs module's genesis state.
 * @param a_epochs - `epochs`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeOsmosisEpochsGenesisState = (a_epochs) => Protobuf() // ...
    .B(a_epochs) // EpochInfo[] epochs = 1
    .o;
/**
 * Decodes a protobuf EpochInfo message
 * @param atu8_payload - raw bytes to decode
 * @param RESERVED - a second argument is explicitly forbidden. make sure not to pass this function by reference to some callback argument
 * @returns a {@link DecodedOsmosisEpochsEpochInfo}
 */
export const decodeOsmosisEpochsEpochInfo = ((atu8_payload, [s_identifier, a_start_time, a_duration, sg_current_epoch, a_current_epoch_start_time, b_epoch_counting_started, , sg_current_epoch_start_height] = decode_protobuf(atu8_payload, [5, [3, 1], [3, 1], 3, [3, 1], 1, 0, 3], [0, decode_temporal, decode_temporal, 0, decode_temporal])) => [s_identifier, a_start_time, a_duration, sg_current_epoch, a_current_epoch_start_time, b_epoch_counting_started, __UNDEFINED, sg_current_epoch_start_height]);
/**
 * Decodes a protobuf GenesisState message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisEpochsGenesisState}
 */
export const decodeOsmosisEpochsGenesisState = (atu8_payload) => decode_protobuf(atu8_payload, [0], [decodeOsmosisEpochsEpochInfo]);
/**
 * Destructures the fields of a {@link OsmosisEpochsEpochInfo} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: identifier - a unique reference to this particular timer.
 *   - 1: start_time - the time at which the timer first ever ticks. If start_time is in the future, the epoch will not begin until the start time.
 *   - 2: duration - the time in between epoch ticks. In order for intended behavior to be met, duration should be greater than the chains expected block time. Duration must be non-zero.
 *   - 3: current_epoch - the current epoch number, or in other words, how many times has the timer 'ticked'. The first tick (current_epoch=1) is defined as the first block whose blocktime is greater than the EpochInfo start_time.
 *   - 4: current_epoch_start_time - describes the start time of the current timer interval. The interval is (current_epoch_start_time, current_epoch_start_time + duration] When the timer ticks, this is set to current_epoch_start_time = last_epoch_start_time + duration only one timer tick for a given identifier can occur per block. NOTE! The current_epoch_start_time may diverge significantly from the wall-clock time the epoch began at. Wall-clock time of epoch start may be >> current_epoch_start_time. Suppose current_epoch_start_time = 10, duration = 5. Suppose the chain goes offline at t=14, and comes back online at t=30, and produces blocks at every successive time. (t=31, 32, etc.) * The t=30 block will start the epoch for (10, 15] * The t=31 block will start the epoch for (15, 20] * The t=32 block will start the epoch for (20, 25] * The t=33 block will start the epoch for (25, 30] * The t=34 block will start the epoch for (30, 35] * The **t=36** block will start the epoch for (35, 40]
 *   - 5: epoch_counting_started - a boolean, that indicates whether this epoch timer has began yet.
 *   - 7: current_epoch_start_height - the block height at which the current epoch started. (The block height at which the timer last ticked)
 */
export const destructOsmosisEpochsEpochInfo = (g_struct) => [g_struct.identifier, parse_timestamp(g_struct.start_time), parse_duration(g_struct.duration), g_struct.current_epoch, parse_timestamp(g_struct.current_epoch_start_time), g_struct.epoch_counting_started, __UNDEFINED, g_struct.current_epoch_start_height];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_OSMOSIS_EPOCHS_EPOCH_INFO = '/osmosis.epochs.v1beta1.EpochInfo';
/**
 * Destructures the fields of a {@link OsmosisEpochsGenesisState} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: epochs -
 */
export const destructOsmosisEpochsGenesisState = (g_struct) => [g_struct.epochs];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_OSMOSIS_EPOCHS_GENESIS_STATE = '/osmosis.epochs.v1beta1.GenesisState';
//# sourceMappingURL=genesis.js.map