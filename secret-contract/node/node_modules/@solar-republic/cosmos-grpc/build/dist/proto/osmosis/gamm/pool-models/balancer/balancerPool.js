import { parse_duration, parse_timestamp } from '../../../../../api/json.js';
import { decode_protobuf, decode_coin, decode_temporal } from '../../../../../api/protobuf-reader.js';
import { Protobuf, temporal, any, coin } from '../../../../../api/protobuf-writer.js';
/**
 * Encodes a `Pool` protobuf message wrapped in the `Any` container:
 * @param sa_address - `address`:
 * @param sg_id - `id`:
 * @param g_pool_params - `pool_params`:
 * @param s_future_pool_governor - `future_pool_governor`: This string specifies who will govern the pool in the future. Valid forms of this are: {token name},{duration} {duration} where {token name} if specified is the token which determines the governor, and if not specified is the LP token for this pool.duration is a time specified as 0w,1w,2w, etc. which specifies how long the token would need to be locked up to count in governance. 0w means no lockup. TODO: Further improve these docs
 * @param a_total_shares - `total_shares`: sum of all LP tokens sent out
 * @param a_pool_assets - `pool_assets`: These are assumed to be sorted by denomiation. They contain the pool asset and the information about the weight
 * @param s_total_weight - `total_weight`: sum of all non-normalized pool weights
 * @returns a strongly subtyped Uint8Array representing an `Any` protobuf message
 */
export const anyPool = (sa_address, sg_id, atu8_pool_params, s_future_pool_governor, a_total_shares, a_pool_assets, s_total_weight) => any('/osmosis.gamm.v1beta1.Pool', Protobuf() // ...
    .s(sa_address) // string address = 1
    .g(sg_id) // uint64 id = 2
    .b(atu8_pool_params) // PoolParams pool_params = 3
    .s(s_future_pool_governor) // string future_pool_governor = 4
    .b(coin(a_total_shares)) // Coin total_shares = 5
    .B(a_pool_assets) // PoolAsset[] pool_assets = 6
    .s(s_total_weight) // string total_weight = 7
    .o);
/**
 * Encodes a `SmoothWeightChangeParams` protobuf message: Parameters for changing the weights in a balancer pool smoothly from a start weight and end weight over a period of time. Currently, the only smooth change supported is linear changing between the two weights, but more types may be added in the future. When these parameters are set, the weight w(t) for pool time `t` is the following: t <= start_time: w(t) = initial_pool_weights start_time < t <= start_time + duration: w(t) = initial_pool_weights + (t - start_time) * (target_pool_weights - initial_pool_weights) / (duration) t > start_time + duration: w(t) = target_pool_weights
 * @param xt_start_time - `start_time`: The start time for beginning the weight change. If a parameter change / pool instantiation leaves this blank, it should be generated by the state_machine as the current time.
 * @param xt_duration - `duration`: Duration for the weights to change over
 * @param a_initial_pool_weights - `initial_pool_weights`: The initial pool weights. These are copied from the pool's settings at the time of weight change instantiation. The amount PoolAsset.token.amount field is ignored if present, future type refactorings should just have a type with the denom & weight here.
 * @param a_target_pool_weights - `target_pool_weights`: The target pool weights. The pool weights will change linearly with respect to time between start_time, and start_time + duration. The amount PoolAsset.token.amount field is ignored if present, future type refactorings should just have a type with the denom & weight here.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeOsmosisGammSmoothWeightChangeParams = (xt_start_time, xt_duration, a_initial_pool_weights, a_target_pool_weights) => Protobuf() // ...
    .b(temporal(xt_start_time)) // Timestamp start_time = 1
    .b(temporal(xt_duration)) // Duration duration = 2
    .B(a_initial_pool_weights) // PoolAsset[] initial_pool_weights = 3
    .B(a_target_pool_weights) // PoolAsset[] target_pool_weights = 4
    .o;
/**
 * Encodes a `PoolParams` protobuf message: defined the parameters that will be managed by the pool governance in the future. This params are not managed by the chain governance. Instead they will be managed by the token holders of the pool. The pool's token holders are specified in future_pool_governor.
 * @param s_swap_fee - `swap_fee`:
 * @param s_exit_fee - `exit_fee`: N.B.: exit fee is disabled during pool creation in x/poolmanager. While old pools can maintain a non-zero fee. No new pool can be created with non-zero fee anymore
 * @param g_smooth_weight_change_params - `smooth_weight_change_params`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeOsmosisGammPoolParams = (s_swap_fee, s_exit_fee, atu8_smooth_weight_change_params) => Protobuf() // ...
    .s(s_swap_fee) // string swap_fee = 1
    .s(s_exit_fee) // string exit_fee = 2
    .b(atu8_smooth_weight_change_params) // SmoothWeightChangeParams smooth_weight_change_params = 3
    .o;
/**
 * Encodes a `PoolAsset` protobuf message: Pool asset is an internal struct that combines the amount of the token in the pool, and its balancer weight. This is an awkward packaging of data, and should be revisited in a future state migration.
 * @param a_token - `token`: Coins we are talking about, the denomination must be unique amongst all PoolAssets for this pool.
 * @param s_weight - `weight`: Weight that is not normalized. This weight must be less than 2^50
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeOsmosisGammPoolAsset = (a_token, s_weight) => Protobuf() // ...
    .b(coin(a_token)) // Coin token = 1
    .s(s_weight) // string weight = 2
    .o;
/**
 * Encodes a `Pool` protobuf message:
 * @param sa_address - `address`:
 * @param sg_id - `id`:
 * @param g_pool_params - `pool_params`:
 * @param s_future_pool_governor - `future_pool_governor`: This string specifies who will govern the pool in the future. Valid forms of this are: {token name},{duration} {duration} where {token name} if specified is the token which determines the governor, and if not specified is the LP token for this pool.duration is a time specified as 0w,1w,2w, etc. which specifies how long the token would need to be locked up to count in governance. 0w means no lockup. TODO: Further improve these docs
 * @param a_total_shares - `total_shares`: sum of all LP tokens sent out
 * @param a_pool_assets - `pool_assets`: These are assumed to be sorted by denomiation. They contain the pool asset and the information about the weight
 * @param s_total_weight - `total_weight`: sum of all non-normalized pool weights
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeOsmosisGammPool = (sa_address, sg_id, atu8_pool_params, s_future_pool_governor, a_total_shares, a_pool_assets, s_total_weight) => Protobuf() // ...
    .s(sa_address) // string address = 1
    .g(sg_id) // uint64 id = 2
    .b(atu8_pool_params) // PoolParams pool_params = 3
    .s(s_future_pool_governor) // string future_pool_governor = 4
    .b(coin(a_total_shares)) // Coin total_shares = 5
    .B(a_pool_assets) // PoolAsset[] pool_assets = 6
    .s(s_total_weight) // string total_weight = 7
    .o;
/**
 * Decodes a protobuf SmoothWeightChangeParams message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisGammSmoothWeightChangeParams}
 */
export const decodeOsmosisGammSmoothWeightChangeParams = (atu8_payload) => decode_protobuf(atu8_payload, [[3, 1], [3, 1], 0, 0], [decode_temporal, decode_temporal, decodeOsmosisGammPoolAsset, decodeOsmosisGammPoolAsset]);
/**
 * Decodes a protobuf PoolParams message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisGammPoolParams}
 */
export const decodeOsmosisGammPoolParams = (atu8_payload) => decode_protobuf(atu8_payload, [5, 5, 1], [0, 0, decodeOsmosisGammSmoothWeightChangeParams]);
/**
 * Decodes a protobuf PoolAsset message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisGammPoolAsset}
 */
export const decodeOsmosisGammPoolAsset = (atu8_payload) => decode_protobuf(atu8_payload, [1, 5], [decode_coin]);
/**
 * Decodes a protobuf Pool message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisGammPool}
 */
export const decodeOsmosisGammPool = (atu8_payload) => decode_protobuf(atu8_payload, [5, 3, 1, 5, 1, 0, 5], [0, 0, decodeOsmosisGammPoolParams, 0, decode_coin, decodeOsmosisGammPoolAsset]);
/**
 * Destructures the fields of a {@link OsmosisGammPoolParams} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: swap_fee -
 *   - 1: exit_fee - N.B.: exit fee is disabled during pool creation in x/poolmanager. While old pools can maintain a non-zero fee. No new pool can be created with non-zero fee anymore
 *   - 2: smooth_weight_change_params -
 */
export const destructOsmosisGammPoolParams = (g_struct) => [g_struct.swap_fee, g_struct.exit_fee, g_struct.smooth_weight_change_params];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_OSMOSIS_GAMM_POOL_PARAMS = '/osmosis.gamm.v1beta1.PoolParams';
/**
 * Destructures the fields of a {@link OsmosisGammSmoothWeightChangeParams} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: start_time - The start time for beginning the weight change. If a parameter change / pool instantiation leaves this blank, it should be generated by the state_machine as the current time.
 *   - 1: duration - Duration for the weights to change over
 *   - 2: initial_pool_weights - The initial pool weights. These are copied from the pool's settings at the time of weight change instantiation. The amount PoolAsset.token.amount field is ignored if present, future type refactorings should just have a type with the denom & weight here.
 *   - 3: target_pool_weights - The target pool weights. The pool weights will change linearly with respect to time between start_time, and start_time + duration. The amount PoolAsset.token.amount field is ignored if present, future type refactorings should just have a type with the denom & weight here.
 */
export const destructOsmosisGammSmoothWeightChangeParams = (g_struct) => [parse_timestamp(g_struct.start_time), parse_duration(g_struct.duration), g_struct.initial_pool_weights, g_struct.target_pool_weights];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_OSMOSIS_GAMM_SMOOTH_WEIGHT_CHANGE_PARAMS = '/osmosis.gamm.v1beta1.SmoothWeightChangeParams';
/**
 * Destructures the fields of a {@link OsmosisGammPoolAsset} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: token - Coins we are talking about, the denomination must be unique amongst all PoolAssets for this pool.
 *   - 1: weight - Weight that is not normalized. This weight must be less than 2^50
 */
export const destructOsmosisGammPoolAsset = (g_struct) => [g_struct.token, g_struct.weight];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_OSMOSIS_GAMM_POOL_ASSET = '/osmosis.gamm.v1beta1.PoolAsset';
/**
 * Destructures the fields of a {@link OsmosisGammPool} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: address -
 *   - 1: id -
 *   - 2: pool_params -
 *   - 3: future_pool_governor - This string specifies who will govern the pool in the future. Valid forms of this are: {token name},{duration} {duration} where {token name} if specified is the token which determines the governor, and if not specified is the LP token for this pool.duration is a time specified as 0w,1w,2w, etc. which specifies how long the token would need to be locked up to count in governance. 0w means no lockup. TODO: Further improve these docs
 *   - 4: total_shares - sum of all LP tokens sent out
 *   - 5: pool_assets - These are assumed to be sorted by denomiation. They contain the pool asset and the information about the weight
 *   - 6: total_weight - sum of all non-normalized pool weights
 */
export const destructOsmosisGammPool = (g_struct) => [g_struct.address, g_struct.id, g_struct.pool_params, g_struct.future_pool_governor, g_struct.total_shares, g_struct.pool_assets, g_struct.total_weight];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_OSMOSIS_GAMM_POOL = '/osmosis.gamm.v1beta1.Pool';
//# sourceMappingURL=balancerPool.js.map