import { parse_duration, parse_timestamp } from '../../../api/json.js';
import { decode_protobuf, decode_coin, decode_temporal } from '../../../api/protobuf-reader.js';
import { Protobuf, map, temporal, coins } from '../../../api/protobuf-writer.js';
import { decodeOsmosisLockupQueryCondition } from '../lockup/lock.js';
/**
 * Encodes a `Gauge` protobuf message: an object that stores and distributes yields to recipients who satisfy certain conditions. Currently gauges support conditions around the duration for which a given denom is locked.
 * @param sg_id - `id`: the unique ID of a Gauge
 * @param b_is_perpetual - `is_perpetual`: a flag to show if it's a perpetual or non-perpetual gauge Non-perpetual gauges distribute their tokens equally per epoch while the gauge is in the active period. Perpetual gauges distribute all their tokens at a single time and only distribute their tokens again once the gauge is refilled, Intended for use with incentives that get refilled daily.
 * @param g_distribute_to - `distribute_to`: where the gauge rewards are distributed to. This is queried via lock duration or by timestamp
 * @param a_coins - `coins`: the total amount of coins that have been in the gauge Can distribute multiple coin denoms
 * @param xt_start_time - `start_time`: the distribution start time
 * @param sg_num_epochs_paid_over - `num_epochs_paid_over`: the number of total epochs distribution will be completed over
 * @param sg_filled_epochs - `filled_epochs`: the number of epochs distribution has been completed on already
 * @param a_distributed_coins - `distributed_coins`: coins that have been distributed already
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeOsmosisIncentivesGauge = (sg_id, b_is_perpetual, atu8_distribute_to, a_coins, xt_start_time, sg_num_epochs_paid_over, sg_filled_epochs, a_distributed_coins) => Protobuf() // ...
    .g(sg_id) // uint64 id = 1
    .v(b_is_perpetual) // boolean is_perpetual = 2
    .b(atu8_distribute_to) // QueryCondition distribute_to = 3
    .B(coins(a_coins)) // Coin[] coins = 4
    .b(temporal(xt_start_time)) // Timestamp start_time = 5
    .g(sg_num_epochs_paid_over) // uint64 num_epochs_paid_over = 6
    .g(sg_filled_epochs) // uint64 filled_epochs = 7
    .B(coins(a_distributed_coins)) // Coin[] distributed_coins = 8
    .o;
/**
 * Encodes a `LockableDurationsInfo` protobuf message:
 * @param a_lockable_durations - `lockable_durations`: List of incentivised durations that gauges will pay out to
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeOsmosisIncentivesLockableDurationsInfo = (a_lockable_durations) => Protobuf() // ...
    .B(map(a_lockable_durations, temporal)) // Duration[] lockable_durations = 1
    .o;
/**
 * Decodes a protobuf Gauge message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisIncentivesGauge}
 */
export const decodeOsmosisIncentivesGauge = (atu8_payload) => decode_protobuf(atu8_payload, [3, 1, 1, 0, [3, 1], 3, 3, 0], [0, 0, decodeOsmosisLockupQueryCondition, decode_coin, decode_temporal, 0, 0, decode_coin]);
/**
 * Decodes a protobuf LockableDurationsInfo message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisIncentivesLockableDurationsInfo}
 */
export const decodeOsmosisIncentivesLockableDurationsInfo = (atu8_payload) => decode_protobuf(atu8_payload, [[3, 1]], [decode_temporal]);
/**
 * Destructures the fields of a {@link OsmosisIncentivesGauge} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: id - the unique ID of a Gauge
 *   - 1: is_perpetual - a flag to show if it's a perpetual or non-perpetual gauge Non-perpetual gauges distribute their tokens equally per epoch while the gauge is in the active period. Perpetual gauges distribute all their tokens at a single time and only distribute their tokens again once the gauge is refilled, Intended for use with incentives that get refilled daily.
 *   - 2: distribute_to - where the gauge rewards are distributed to. This is queried via lock duration or by timestamp
 *   - 3: coins - the total amount of coins that have been in the gauge Can distribute multiple coin denoms
 *   - 4: start_time - the distribution start time
 *   - 5: num_epochs_paid_over - the number of total epochs distribution will be completed over
 *   - 6: filled_epochs - the number of epochs distribution has been completed on already
 *   - 7: distributed_coins - coins that have been distributed already
 */
export const destructOsmosisIncentivesGauge = (g_struct) => [g_struct.id, g_struct.is_perpetual, g_struct.distribute_to, g_struct.coins, parse_timestamp(g_struct.start_time), g_struct.num_epochs_paid_over, g_struct.filled_epochs, g_struct.distributed_coins];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_OSMOSIS_INCENTIVES_GAUGE = '/osmosis.incentives.Gauge';
/**
 * Destructures the fields of a {@link OsmosisIncentivesLockableDurationsInfo} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: lockable_durations - List of incentivised durations that gauges will pay out to
 */
export const destructOsmosisIncentivesLockableDurationsInfo = (g_struct) => [map(g_struct.lockable_durations, parse_duration)];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_OSMOSIS_INCENTIVES_LOCKABLE_DURATIONS_INFO = '/osmosis.incentives.LockableDurationsInfo';
//# sourceMappingURL=gauge.js.map