import type { WeakUint64Str, CwUint64 } from '@solar-republic/types';
import type { Encoded, Opt } from '../../../api/types.js';
import type { OsmosisIncentivesGauge, DecodedOsmosisIncentivesGauge } from './gauge.js';
export type EncodedOsmosisIncentivesInternalGaugeInfo = Encoded<'/osmosis.incentives.InternalGaugeInfo'>;
export type EncodedOsmosisIncentivesInternalGaugeRecord = Encoded<'/osmosis.incentives.InternalGaugeRecord'>;
export type EncodedOsmosisIncentivesGroup = Encoded<'/osmosis.incentives.Group'>;
export type EncodedOsmosisIncentivesCreateGroup = Encoded<'/osmosis.incentives.CreateGroup'>;
export type EncodedOsmosisIncentivesGroupsWithGauge = Encoded<'/osmosis.incentives.GroupsWithGauge'>;
/**
 * Encodes a `InternalGaugeInfo` protobuf message: Note that while both InternalGaugeInfo and InternalGaugeRecord could technically be replaced by DistrInfo and DistrRecord from the pool-incentives module, we create separate types here to keep our abstractions clean and readable (pool-incentives distribution abstractions are used in a very specific way that does not directly relate to gauge logic). This also helps us sidestep a refactor to avoid an import cycle.
 * @param s_total_weight - `total_weight`:
 * @param a_gauge_records - `gauge_records`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisIncentivesInternalGaugeInfo: (s_total_weight?: Opt<string>, a_gauge_records?: Opt<Encoded<'/osmosis.incentives.InternalGaugeRecord'>[]>) => EncodedOsmosisIncentivesInternalGaugeInfo;
/**
 * Encodes a `InternalGaugeRecord` protobuf message:
 * @param sg_gauge_id - `gauge_id`:
 * @param s_current_weight - `current_weight`: CurrentWeight is the current weight of this gauge being distributed to for this epoch. For instance, for volume splitting policy, this stores the volume generated in the last epoch of the linked pool.
 * @param s_cumulative_weight - `cumulative_weight`: CumulativeWeight serves as a snapshot of the accumulator being tracked based on splitting policy. For instance, for volume splitting policy, this stores the cumulative volume for the linked pool at time of last update.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisIncentivesInternalGaugeRecord: (sg_gauge_id?: Opt<WeakUint64Str>, s_current_weight?: Opt<string>, s_cumulative_weight?: Opt<string>) => EncodedOsmosisIncentivesInternalGaugeRecord;
/**
 * Encodes a `Group` protobuf message: an object that stores a 1:1 mapped gauge ID, a list of pool gauge info, and a splitting policy. These are grouped into a single abstraction to allow for distribution of group incentives to internal gauges according to the specified splitting policy.
 * @param sg_group_gauge_id - `group_gauge_id`:
 * @param g_internal_gauge_info - `internal_gauge_info`:
 * @param xc_splitting_policy - `splitting_policy`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisIncentivesGroup: (sg_group_gauge_id?: Opt<WeakUint64Str>, atu8_internal_gauge_info?: Opt<Encoded<'/osmosis.incentives.InternalGaugeInfo'>>, xc_splitting_policy?: Opt<ProtoEnumOsmosisIncentivesSplittingPolicy>) => EncodedOsmosisIncentivesGroup;
/**
 * Encodes a `CreateGroup` protobuf message: called via governance to create a new group. It takes an array of pool IDs to split the incentives across.
 * @param a_pool_ids - `pool_ids`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisIncentivesCreateGroup: (a_pool_ids?: Opt<WeakUint64Str[]>) => EncodedOsmosisIncentivesCreateGroup;
/**
 * Encodes a `GroupsWithGauge` protobuf message: a helper struct that stores a group and its associated gauge.
 * @param g_group - `group`:
 * @param g_gauge - `gauge`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisIncentivesGroupsWithGauge: (atu8_group?: Opt<Encoded<'/osmosis.incentives.Group'>>, atu8_gauge?: Opt<Encoded<'/osmosis.incentives.Gauge'>>) => EncodedOsmosisIncentivesGroupsWithGauge;
/**
 * A decoded protobuf InternalGaugeInfo message
 *
 * Tuple where:
 *   - 0: total_weight -
 *   - 1: gauge_records -
 */
export type DecodedOsmosisIncentivesInternalGaugeInfo = [
    s_total_weight?: string,
    a_gauge_records?: DecodedOsmosisIncentivesInternalGaugeRecord[]
];
/**
 * Decodes a protobuf InternalGaugeInfo message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisIncentivesInternalGaugeInfo}
 */
export declare const decodeOsmosisIncentivesInternalGaugeInfo: (atu8_payload: Uint8Array) => DecodedOsmosisIncentivesInternalGaugeInfo;
/**
 * A decoded protobuf InternalGaugeRecord message
 *
 * Tuple where:
 *   - 0: gauge_id -
 *   - 1: current_weight - CurrentWeight is the current weight of this gauge being distributed to for this epoch. For instance, for volume splitting policy, this stores the volume generated in the last epoch of the linked pool.
 *   - 2: cumulative_weight - CumulativeWeight serves as a snapshot of the accumulator being tracked based on splitting policy. For instance, for volume splitting policy, this stores the cumulative volume for the linked pool at time of last update.
 */
export type DecodedOsmosisIncentivesInternalGaugeRecord = [
    sg_gauge_id?: CwUint64,
    s_current_weight?: string,
    s_cumulative_weight?: string
];
/**
 * Decodes a protobuf InternalGaugeRecord message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisIncentivesInternalGaugeRecord}
 */
export declare const decodeOsmosisIncentivesInternalGaugeRecord: (atu8_payload: Uint8Array) => DecodedOsmosisIncentivesInternalGaugeRecord;
/**
 * A decoded protobuf Group message
 *
 * Tuple where:
 *   - 0: group_gauge_id -
 *   - 1: internal_gauge_info -
 *   - 2: splitting_policy -
 */
export type DecodedOsmosisIncentivesGroup = [
    sg_group_gauge_id?: CwUint64,
    a_internal_gauge_info?: DecodedOsmosisIncentivesInternalGaugeInfo,
    xc_splitting_policy?: ProtoEnumOsmosisIncentivesSplittingPolicy
];
/**
 * Decodes a protobuf Group message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisIncentivesGroup}
 */
export declare const decodeOsmosisIncentivesGroup: (atu8_payload: Uint8Array) => DecodedOsmosisIncentivesGroup;
/**
 * A decoded protobuf CreateGroup message
 *
 * Alias for: pool_ids -
 */
export type DecodedOsmosisIncentivesCreateGroup = [
    a_pool_ids?: CwUint64[]
];
/**
 * Decodes a protobuf CreateGroup message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisIncentivesCreateGroup}
 */
export declare const decodeOsmosisIncentivesCreateGroup: (atu8_payload: Uint8Array) => DecodedOsmosisIncentivesCreateGroup;
/**
 * A decoded protobuf GroupsWithGauge message
 *
 * Tuple where:
 *   - 0: group -
 *   - 1: gauge -
 */
export type DecodedOsmosisIncentivesGroupsWithGauge = [
    a_group?: DecodedOsmosisIncentivesGroup,
    a_gauge?: DecodedOsmosisIncentivesGauge
];
/**
 * Decodes a protobuf GroupsWithGauge message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisIncentivesGroupsWithGauge}
 */
export declare const decodeOsmosisIncentivesGroupsWithGauge: (atu8_payload: Uint8Array) => DecodedOsmosisIncentivesGroupsWithGauge;
/**
 * Destructures the fields of a {@link OsmosisIncentivesCreateGroup} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: pool_ids -
 */
export declare const destructOsmosisIncentivesCreateGroup: (g_struct: OsmosisIncentivesCreateGroup) => [pool_ids?: CwUint64[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_INCENTIVES_CREATE_GROUP = "/osmosis.incentives.CreateGroup";
/**
 * JSON serialization of `osmosis.incentives.CreateGroup` - called via governance to create a new group. It takes an array of pool IDs to split the incentives across.
 */
export type OsmosisIncentivesCreateGroup = {
    pool_ids?: CwUint64[] | undefined;
};
/**
 * Destructures the fields of a {@link OsmosisIncentivesInternalGaugeInfo} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: total_weight -
 *   - 1: gauge_records -
 */
export declare const destructOsmosisIncentivesInternalGaugeInfo: (g_struct: OsmosisIncentivesInternalGaugeInfo) => [total_weight?: string, gauge_records?: OsmosisIncentivesInternalGaugeRecord[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_INCENTIVES_INTERNAL_GAUGE_INFO = "/osmosis.incentives.InternalGaugeInfo";
/**
 * JSON serialization of `osmosis.incentives.InternalGaugeInfo` - Note that while both InternalGaugeInfo and InternalGaugeRecord could technically be replaced by DistrInfo and DistrRecord from the pool-incentives module, we create separate types here to keep our abstractions clean and readable (pool-incentives distribution abstractions are used in a very specific way that does not directly relate to gauge logic). This also helps us sidestep a refactor to avoid an import cycle.
 */
export type OsmosisIncentivesInternalGaugeInfo = {
    total_weight?: string | undefined;
    gauge_records?: OsmosisIncentivesInternalGaugeRecord[] | undefined;
};
/**
 * Destructures the fields of a {@link OsmosisIncentivesInternalGaugeRecord} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: gauge_id -
 *   - 1: current_weight - CurrentWeight is the current weight of this gauge being distributed to for this epoch. For instance, for volume splitting policy, this stores the volume generated in the last epoch of the linked pool.
 *   - 2: cumulative_weight - CumulativeWeight serves as a snapshot of the accumulator being tracked based on splitting policy. For instance, for volume splitting policy, this stores the cumulative volume for the linked pool at time of last update.
 */
export declare const destructOsmosisIncentivesInternalGaugeRecord: (g_struct: OsmosisIncentivesInternalGaugeRecord) => [gauge_id?: CwUint64, current_weight?: string, cumulative_weight?: string];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_INCENTIVES_INTERNAL_GAUGE_RECORD = "/osmosis.incentives.InternalGaugeRecord";
/**
 * JSON serialization of `osmosis.incentives.InternalGaugeRecord` -
 */
export type OsmosisIncentivesInternalGaugeRecord = {
    gauge_id?: CwUint64 | undefined;
    current_weight?: string | undefined;
    cumulative_weight?: string | undefined;
};
/**
 * Destructures the fields of a {@link OsmosisIncentivesGroup} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: group_gauge_id -
 *   - 1: internal_gauge_info -
 *   - 2: splitting_policy -
 */
export declare const destructOsmosisIncentivesGroup: (g_struct: OsmosisIncentivesGroup) => [group_gauge_id?: CwUint64, internal_gauge_info?: OsmosisIncentivesInternalGaugeInfo, splitting_policy?: "ByVolume"];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_INCENTIVES_GROUP = "/osmosis.incentives.Group";
/**
 * JSON serialization of `osmosis.incentives.Group` - an object that stores a 1:1 mapped gauge ID, a list of pool gauge info, and a splitting policy. These are grouped into a single abstraction to allow for distribution of group incentives to internal gauges according to the specified splitting policy.
 */
export type OsmosisIncentivesGroup = {
    group_gauge_id?: CwUint64 | undefined;
    internal_gauge_info?: OsmosisIncentivesInternalGaugeInfo | undefined;
    splitting_policy?: JsonEnumOsmosisIncentivesSplittingPolicy | undefined;
};
/**
 * Destructures the fields of a {@link OsmosisIncentivesGroupsWithGauge} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: group -
 *   - 1: gauge -
 */
export declare const destructOsmosisIncentivesGroupsWithGauge: (g_struct: OsmosisIncentivesGroupsWithGauge) => [group?: OsmosisIncentivesGroup, gauge?: OsmosisIncentivesGauge];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_INCENTIVES_GROUPS_WITH_GAUGE = "/osmosis.incentives.GroupsWithGauge";
/**
 * JSON serialization of `osmosis.incentives.GroupsWithGauge` - a helper struct that stores a group and its associated gauge.
 */
export type OsmosisIncentivesGroupsWithGauge = {
    group?: OsmosisIncentivesGroup | undefined;
    gauge?: OsmosisIncentivesGauge | undefined;
};
/**
 * Protobuf enum value for `osmosis.incentives.SplittingPolicy`.
 *
 * **ByVolume** -
 *
 * Belongs to enum type {@link ProtoEnumOsmosisIncentivesSplittingPolicy}
 */
export declare const XC_PROTO_OSMOSIS_INCENTIVES_ByVolume = 0;
/**
 * JSON enum value for `osmosis.incentives.SplittingPolicy`.
 *
 * **ByVolume** -
 *
 * Belongs to enum type {@link JsonEnumOsmosisIncentivesSplittingPolicy}
 */
export declare const SI_JSON_OSMOSIS_INCENTIVES_ByVolume = "ByVolume";
/**
 * Raw protobuf enum values for `osmosis.incentives.SplittingPolicy` to be used when passing to an encoder or comparing to a decoded protobuf value.
 *
 * Values:
 *   - {@link XC_PROTO_OSMOSIS_INCENTIVES_ByVolume}
 */
export type ProtoEnumOsmosisIncentivesSplittingPolicy = typeof XC_PROTO_OSMOSIS_INCENTIVES_ByVolume;
/**
 * JSON enum values for `osmosis.incentives.SplittingPolicy` to be used when passing to a gRPC-gateway method or comparing to a response value
 *
 * Values:
 *   - {@link SI_JSON_OSMOSIS_INCENTIVES_ByVolume}
 */
export type JsonEnumOsmosisIncentivesSplittingPolicy = typeof SI_JSON_OSMOSIS_INCENTIVES_ByVolume;
/**
 * Maps a protobuf enum int value for `osmosis.incentives.SplittingPolicy` to is JSON equivalent enum string value
 */
export declare const ProtoToJsonEnumOsmosisIncentivesSplittingPolicy: Record<ProtoEnumOsmosisIncentivesSplittingPolicy, JsonEnumOsmosisIncentivesSplittingPolicy>;
/**
 * Maps a JSON enum string value for `osmosis.incentives.SplittingPolicy` to is protobuf equivalent enum int value
 */
export declare const JsonToProtoEnumOsmosisIncentivesSplittingPolicy: Record<JsonEnumOsmosisIncentivesSplittingPolicy, ProtoEnumOsmosisIncentivesSplittingPolicy>;
