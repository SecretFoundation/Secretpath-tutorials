import type { WeakUint64Str, WeakAccountAddr, SlimCoin, CwUint64, CwAccountAddr } from '@solar-republic/types';
import type { Encoded, Opt, WeakTimestampStr } from '../../../api/types.js';
import type { CosmosBaseCoin } from '../../cosmos/base/v1beta1/coin.js';
import type { OsmosisLockupQueryCondition, DecodedOsmosisLockupQueryCondition } from '../lockup/lock.js';
export type EncodedOsmosisIncentivesMsgCreateGauge = Encoded<'/osmosis.incentives.MsgCreateGauge'>;
export type EncodedOsmosisIncentivesMsgCreateGaugeResponse = Encoded<'/osmosis.incentives.MsgCreateGaugeResponse'>;
export type EncodedOsmosisIncentivesMsgAddToGauge = Encoded<'/osmosis.incentives.MsgAddToGauge'>;
export type EncodedOsmosisIncentivesMsgAddToGaugeResponse = Encoded<'/osmosis.incentives.MsgAddToGaugeResponse'>;
export type EncodedOsmosisIncentivesMsgCreateGroup = Encoded<'/osmosis.incentives.MsgCreateGroup'>;
export type EncodedOsmosisIncentivesMsgCreateGroupResponse = Encoded<'/osmosis.incentives.MsgCreateGroupResponse'>;
/**
 * Encodes a `MsgCreateGauge` protobuf message: creates a gague to distribute rewards to users
 * @param b_is_perpetual - `is_perpetual`: shows if it's a perpetual or non-perpetual gauge Non-perpetual gauges distribute their tokens equally per epoch while the gauge is in the active period. Perpetual gauges distribute all their tokens at a single time and only distribute their tokens again once the gauge is refilled
 * @param sa_owner - `owner`: the address of gauge creator
 * @param g_distribute_to - `distribute_to`: show which lock the gauge should distribute to by time duration or by timestamp
 * @param a_coins - `coins`: coin(s) to be distributed by the gauge
 * @param xt_start_time - `start_time`: the distribution start time
 * @param sg_num_epochs_paid_over - `num_epochs_paid_over`: the number of epochs distribution will be completed over
 * @param sg_pool_id - `pool_id`: the ID of the pool that the gauge is meant to be associated with. if pool_id is set, then the "QueryCondition.LockQueryType" must be "NoLock" with all other fields of the "QueryCondition.LockQueryType" struct unset, including "QueryCondition.Denom". However, note that, internally, the empty string in "QueryCondition.Denom" ends up being overwritten with incentivestypes.NoLockExternalGaugeDenom(<pool-id>) so that the gauges associated with a pool can be queried by this prefix if needed.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisIncentivesMsgCreateGauge: (b_is_perpetual?: Opt<boolean | 0 | 1>, sa_owner?: Opt<WeakAccountAddr>, atu8_distribute_to?: Opt<Encoded<'/osmosis.lockup.QueryCondition'>>, a_coins?: Opt<SlimCoin[]>, xt_start_time?: Opt<number>, sg_num_epochs_paid_over?: Opt<WeakUint64Str>, sg_pool_id?: Opt<WeakUint64Str>) => EncodedOsmosisIncentivesMsgCreateGauge;
/**
 * Encodes a `MsgCreateGaugeResponse` protobuf message:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisIncentivesMsgCreateGaugeResponse: () => EncodedOsmosisIncentivesMsgCreateGaugeResponse;
/**
 * Encodes a `MsgAddToGauge` protobuf message: adds coins to a previously created gauge
 * @param sa_owner - `owner`: the gauge owner's address
 * @param sg_gauge_id - `gauge_id`: the ID of gauge that rewards are getting added to
 * @param a_rewards - `rewards`: the coin(s) to add to gauge
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisIncentivesMsgAddToGauge: (sa_owner?: Opt<WeakAccountAddr>, sg_gauge_id?: Opt<WeakUint64Str>, a_rewards?: Opt<SlimCoin[]>) => EncodedOsmosisIncentivesMsgAddToGauge;
/**
 * Encodes a `MsgAddToGaugeResponse` protobuf message:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisIncentivesMsgAddToGaugeResponse: () => EncodedOsmosisIncentivesMsgAddToGaugeResponse;
/**
 * Encodes a `MsgCreateGroup` protobuf message: creates a group to distribute rewards to a group of pools
 * @param a_coins - `coins`: the provided coins that the group will distribute
 * @param sg_num_epochs_paid_over - `num_epochs_paid_over`: the number of epochs distribution will be completed in. 0 means it's perpetual
 * @param sa_owner - `owner`: the group owner's address
 * @param a_pool_ids - `pool_ids`: the IDs of pools that the group is comprised of
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisIncentivesMsgCreateGroup: (a_coins?: Opt<SlimCoin[]>, sg_num_epochs_paid_over?: Opt<WeakUint64Str>, sa_owner?: Opt<WeakAccountAddr>, a_pool_ids?: Opt<WeakUint64Str[]>) => EncodedOsmosisIncentivesMsgCreateGroup;
/**
 * Encodes a `MsgCreateGroupResponse` protobuf message:
 * @param sg_group_id - `group_id`: the ID of the group that is created from this msg
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisIncentivesMsgCreateGroupResponse: (sg_group_id?: Opt<WeakUint64Str>) => EncodedOsmosisIncentivesMsgCreateGroupResponse;
/**
 * A decoded protobuf CreateGauge message
 *
 * Tuple where:
 *   - 0: is_perpetual - shows if it's a perpetual or non-perpetual gauge Non-perpetual gauges distribute their tokens equally per epoch while the gauge is in the active period. Perpetual gauges distribute all their tokens at a single time and only distribute their tokens again once the gauge is refilled
 *   - 1: owner - the address of gauge creator
 *   - 2: distribute_to - show which lock the gauge should distribute to by time duration or by timestamp
 *   - 3: coins - coin(s) to be distributed by the gauge
 *   - 4: start_time - the distribution start time
 *   - 5: num_epochs_paid_over - the number of epochs distribution will be completed over
 *   - 6: pool_id - the ID of the pool that the gauge is meant to be associated with. if pool_id is set, then the "QueryCondition.LockQueryType" must be "NoLock" with all other fields of the "QueryCondition.LockQueryType" struct unset, including "QueryCondition.Denom". However, note that, internally, the empty string in "QueryCondition.Denom" ends up being overwritten with incentivestypes.NoLockExternalGaugeDenom(<pool-id>) so that the gauges associated with a pool can be queried by this prefix if needed.
 */
export type DecodedOsmosisIncentivesMsgCreateGauge = [
    b_is_perpetual?: 0 | 1,
    sa_owner?: CwAccountAddr,
    a_distribute_to?: DecodedOsmosisLockupQueryCondition,
    a_coins?: [
        string,
        string
    ][],
    a_start_time?: [
        string,
        number
    ],
    sg_num_epochs_paid_over?: CwUint64,
    sg_pool_id?: CwUint64
];
/**
 * Decodes a protobuf CreateGauge message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisIncentivesMsgCreateGauge}
 */
export declare const decodeOsmosisIncentivesMsgCreateGauge: (atu8_payload: Uint8Array) => DecodedOsmosisIncentivesMsgCreateGauge;
/**
 * A decoded protobuf CreateGauge message
 *
 * Tuple where:
 */
export type DecodedOsmosisIncentivesMsgCreateGaugeResponse = [];
/**
 * Decodes a protobuf CreateGauge message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisIncentivesMsgCreateGaugeResponse}
 */
export declare const decodeOsmosisIncentivesMsgCreateGaugeResponse: (atu8_payload: Uint8Array) => [];
/**
 * A decoded protobuf AddToGauge message
 *
 * Tuple where:
 *   - 0: owner - the gauge owner's address
 *   - 1: gauge_id - the ID of gauge that rewards are getting added to
 *   - 2: rewards - the coin(s) to add to gauge
 */
export type DecodedOsmosisIncentivesMsgAddToGauge = [
    sa_owner?: CwAccountAddr,
    sg_gauge_id?: CwUint64,
    a_rewards?: [
        string,
        string
    ][]
];
/**
 * Decodes a protobuf AddToGauge message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisIncentivesMsgAddToGauge}
 */
export declare const decodeOsmosisIncentivesMsgAddToGauge: (atu8_payload: Uint8Array) => DecodedOsmosisIncentivesMsgAddToGauge;
/**
 * A decoded protobuf AddToGauge message
 *
 * Tuple where:
 */
export type DecodedOsmosisIncentivesMsgAddToGaugeResponse = [];
/**
 * Decodes a protobuf AddToGauge message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisIncentivesMsgAddToGaugeResponse}
 */
export declare const decodeOsmosisIncentivesMsgAddToGaugeResponse: (atu8_payload: Uint8Array) => [];
/**
 * A decoded protobuf CreateGroup message
 *
 * Tuple where:
 *   - 0: coins - the provided coins that the group will distribute
 *   - 1: num_epochs_paid_over - the number of epochs distribution will be completed in. 0 means it's perpetual
 *   - 2: owner - the group owner's address
 *   - 3: pool_ids - the IDs of pools that the group is comprised of
 */
export type DecodedOsmosisIncentivesMsgCreateGroup = [
    a_coins?: [
        string,
        string
    ][],
    sg_num_epochs_paid_over?: CwUint64,
    sa_owner?: CwAccountAddr,
    a_pool_ids?: CwUint64[]
];
/**
 * Decodes a protobuf CreateGroup message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisIncentivesMsgCreateGroup}
 */
export declare const decodeOsmosisIncentivesMsgCreateGroup: (atu8_payload: Uint8Array) => DecodedOsmosisIncentivesMsgCreateGroup;
/**
 * A decoded protobuf CreateGroup message
 *
 * Alias for: group_id - the ID of the group that is created from this msg
 */
export type DecodedOsmosisIncentivesMsgCreateGroupResponse = [
    sg_group_id?: CwUint64
];
/**
 * Decodes a protobuf CreateGroup message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisIncentivesMsgCreateGroupResponse}
 */
export declare const decodeOsmosisIncentivesMsgCreateGroupResponse: (atu8_payload: Uint8Array) => DecodedOsmosisIncentivesMsgCreateGroupResponse;
/**
 * Destructures the fields of a {@link OsmosisIncentivesMsgCreateGauge} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: is_perpetual - shows if it's a perpetual or non-perpetual gauge Non-perpetual gauges distribute their tokens equally per epoch while the gauge is in the active period. Perpetual gauges distribute all their tokens at a single time and only distribute their tokens again once the gauge is refilled
 *   - 1: owner - the address of gauge creator
 *   - 2: distribute_to - show which lock the gauge should distribute to by time duration or by timestamp
 *   - 3: coins - coin(s) to be distributed by the gauge
 *   - 4: start_time - the distribution start time
 *   - 5: num_epochs_paid_over - the number of epochs distribution will be completed over
 *   - 6: pool_id - the ID of the pool that the gauge is meant to be associated with. if pool_id is set, then the "QueryCondition.LockQueryType" must be "NoLock" with all other fields of the "QueryCondition.LockQueryType" struct unset, including "QueryCondition.Denom". However, note that, internally, the empty string in "QueryCondition.Denom" ends up being overwritten with incentivestypes.NoLockExternalGaugeDenom(<pool-id>) so that the gauges associated with a pool can be queried by this prefix if needed.
 */
export declare const destructOsmosisIncentivesMsgCreateGauge: (g_struct: OsmosisIncentivesMsgCreateGauge) => [is_perpetual?: boolean, owner?: CwAccountAddr, distribute_to?: OsmosisLockupQueryCondition, coins?: CosmosBaseCoin[], start_time?: number, num_epochs_paid_over?: CwUint64, pool_id?: CwUint64];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_INCENTIVES_MSG_CREATE_GAUGE = "/osmosis.incentives.MsgCreateGauge";
/**
 * JSON serialization of `osmosis.incentives.MsgCreateGauge` - creates a gague to distribute rewards to users
 */
export type OsmosisIncentivesMsgCreateGauge = {
    is_perpetual?: boolean | undefined;
    owner?: CwAccountAddr | undefined;
    distribute_to?: OsmosisLockupQueryCondition | undefined;
    coins?: CosmosBaseCoin[] | undefined;
    start_time?: WeakTimestampStr | undefined;
    num_epochs_paid_over?: CwUint64 | undefined;
    pool_id?: CwUint64 | undefined;
};
/**
 * Destructures the fields of a {@link OsmosisIncentivesMsgCreateGaugeResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 */
export declare const destructOsmosisIncentivesMsgCreateGaugeResponse: (g_struct: OsmosisIncentivesMsgCreateGaugeResponse) => [];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_INCENTIVES_MSG_CREATE_GAUGE_RESPONSE = "/osmosis.incentives.MsgCreateGaugeResponse";
/**
 * JSON serialization of `osmosis.incentives.MsgCreateGaugeResponse` -
 */
export type OsmosisIncentivesMsgCreateGaugeResponse = {};
/**
 * Destructures the fields of a {@link OsmosisIncentivesMsgAddToGauge} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: owner - the gauge owner's address
 *   - 1: gauge_id - the ID of gauge that rewards are getting added to
 *   - 2: rewards - the coin(s) to add to gauge
 */
export declare const destructOsmosisIncentivesMsgAddToGauge: (g_struct: OsmosisIncentivesMsgAddToGauge) => [owner?: CwAccountAddr, gauge_id?: CwUint64, rewards?: CosmosBaseCoin[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_INCENTIVES_MSG_ADD_TO_GAUGE = "/osmosis.incentives.MsgAddToGauge";
/**
 * JSON serialization of `osmosis.incentives.MsgAddToGauge` - adds coins to a previously created gauge
 */
export type OsmosisIncentivesMsgAddToGauge = {
    owner?: CwAccountAddr | undefined;
    gauge_id?: CwUint64 | undefined;
    rewards?: CosmosBaseCoin[] | undefined;
};
/**
 * Destructures the fields of a {@link OsmosisIncentivesMsgAddToGaugeResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 */
export declare const destructOsmosisIncentivesMsgAddToGaugeResponse: (g_struct: OsmosisIncentivesMsgAddToGaugeResponse) => [];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_INCENTIVES_MSG_ADD_TO_GAUGE_RESPONSE = "/osmosis.incentives.MsgAddToGaugeResponse";
/**
 * JSON serialization of `osmosis.incentives.MsgAddToGaugeResponse` -
 */
export type OsmosisIncentivesMsgAddToGaugeResponse = {};
/**
 * Destructures the fields of a {@link OsmosisIncentivesMsgCreateGroup} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: coins - the provided coins that the group will distribute
 *   - 1: num_epochs_paid_over - the number of epochs distribution will be completed in. 0 means it's perpetual
 *   - 2: owner - the group owner's address
 *   - 3: pool_ids - the IDs of pools that the group is comprised of
 */
export declare const destructOsmosisIncentivesMsgCreateGroup: (g_struct: OsmosisIncentivesMsgCreateGroup) => [coins?: CosmosBaseCoin[], num_epochs_paid_over?: CwUint64, owner?: CwAccountAddr, pool_ids?: CwUint64[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_INCENTIVES_MSG_CREATE_GROUP = "/osmosis.incentives.MsgCreateGroup";
/**
 * JSON serialization of `osmosis.incentives.MsgCreateGroup` - creates a group to distribute rewards to a group of pools
 */
export type OsmosisIncentivesMsgCreateGroup = {
    coins?: CosmosBaseCoin[] | undefined;
    num_epochs_paid_over?: CwUint64 | undefined;
    owner?: CwAccountAddr | undefined;
    pool_ids?: CwUint64[] | undefined;
};
/**
 * Destructures the fields of a {@link OsmosisIncentivesMsgCreateGroupResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: group_id - the ID of the group that is created from this msg
 */
export declare const destructOsmosisIncentivesMsgCreateGroupResponse: (g_struct: OsmosisIncentivesMsgCreateGroupResponse) => [group_id?: CwUint64];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_INCENTIVES_MSG_CREATE_GROUP_RESPONSE = "/osmosis.incentives.MsgCreateGroupResponse";
/**
 * JSON serialization of `osmosis.incentives.MsgCreateGroupResponse` -
 */
export type OsmosisIncentivesMsgCreateGroupResponse = {
    group_id?: CwUint64 | undefined;
};
