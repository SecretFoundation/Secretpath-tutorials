import { parse_timestamp } from '../../../api/json.js';
import { decode_protobuf, decode_coin, decode_temporal } from '../../../api/protobuf-reader.js';
import { Protobuf, temporal, coins } from '../../../api/protobuf-writer.js';
import { decodeOsmosisLockupQueryCondition } from '../lockup/lock.js';
/**
 * Encodes a `MsgCreateGauge` protobuf message: creates a gague to distribute rewards to users
 * @param b_is_perpetual - `is_perpetual`: shows if it's a perpetual or non-perpetual gauge Non-perpetual gauges distribute their tokens equally per epoch while the gauge is in the active period. Perpetual gauges distribute all their tokens at a single time and only distribute their tokens again once the gauge is refilled
 * @param sa_owner - `owner`: the address of gauge creator
 * @param g_distribute_to - `distribute_to`: show which lock the gauge should distribute to by time duration or by timestamp
 * @param a_coins - `coins`: coin(s) to be distributed by the gauge
 * @param xt_start_time - `start_time`: the distribution start time
 * @param sg_num_epochs_paid_over - `num_epochs_paid_over`: the number of epochs distribution will be completed over
 * @param sg_pool_id - `pool_id`: the ID of the pool that the gauge is meant to be associated with. if pool_id is set, then the "QueryCondition.LockQueryType" must be "NoLock" with all other fields of the "QueryCondition.LockQueryType" struct unset, including "QueryCondition.Denom". However, note that, internally, the empty string in "QueryCondition.Denom" ends up being overwritten with incentivestypes.NoLockExternalGaugeDenom(<pool-id>) so that the gauges associated with a pool can be queried by this prefix if needed.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeOsmosisIncentivesMsgCreateGauge = (b_is_perpetual, sa_owner, atu8_distribute_to, a_coins, xt_start_time, sg_num_epochs_paid_over, sg_pool_id) => Protobuf() // ...
    .v(b_is_perpetual) // boolean is_perpetual = 1
    .s(sa_owner) // string owner = 2
    .b(atu8_distribute_to) // QueryCondition distribute_to = 3
    .B(coins(a_coins)) // Coin[] coins = 4
    .b(temporal(xt_start_time)) // Timestamp start_time = 5
    .g(sg_num_epochs_paid_over) // uint64 num_epochs_paid_over = 6
    .g(sg_pool_id) // uint64 pool_id = 7
    .o;
/**
 * Encodes a `MsgCreateGaugeResponse` protobuf message:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeOsmosisIncentivesMsgCreateGaugeResponse = () => Protobuf() // ...
    .o;
/**
 * Encodes a `MsgAddToGauge` protobuf message: adds coins to a previously created gauge
 * @param sa_owner - `owner`: the gauge owner's address
 * @param sg_gauge_id - `gauge_id`: the ID of gauge that rewards are getting added to
 * @param a_rewards - `rewards`: the coin(s) to add to gauge
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeOsmosisIncentivesMsgAddToGauge = (sa_owner, sg_gauge_id, a_rewards) => Protobuf() // ...
    .s(sa_owner) // string owner = 1
    .g(sg_gauge_id) // uint64 gauge_id = 2
    .B(coins(a_rewards)) // Coin[] rewards = 3
    .o;
/**
 * Encodes a `MsgAddToGaugeResponse` protobuf message:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeOsmosisIncentivesMsgAddToGaugeResponse = () => Protobuf() // ...
    .o;
/**
 * Encodes a `MsgCreateGroup` protobuf message: creates a group to distribute rewards to a group of pools
 * @param a_coins - `coins`: the provided coins that the group will distribute
 * @param sg_num_epochs_paid_over - `num_epochs_paid_over`: the number of epochs distribution will be completed in. 0 means it's perpetual
 * @param sa_owner - `owner`: the group owner's address
 * @param a_pool_ids - `pool_ids`: the IDs of pools that the group is comprised of
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeOsmosisIncentivesMsgCreateGroup = (a_coins, sg_num_epochs_paid_over, sa_owner, a_pool_ids) => Protobuf() // ...
    .B(coins(a_coins)) // Coin[] coins = 1
    .g(sg_num_epochs_paid_over) // uint64 num_epochs_paid_over = 2
    .s(sa_owner) // string owner = 3
    .G(a_pool_ids) // uint64[] pool_ids = 4
    .o;
/**
 * Encodes a `MsgCreateGroupResponse` protobuf message:
 * @param sg_group_id - `group_id`: the ID of the group that is created from this msg
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeOsmosisIncentivesMsgCreateGroupResponse = (sg_group_id) => Protobuf() // ...
    .g(sg_group_id) // uint64 group_id = 1
    .o;
/**
 * Decodes a protobuf CreateGauge message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisIncentivesMsgCreateGauge}
 */
export const decodeOsmosisIncentivesMsgCreateGauge = (atu8_payload) => decode_protobuf(atu8_payload, [1, 5, 1, 0, [3, 1], 3, 3], [0, 0, decodeOsmosisLockupQueryCondition, decode_coin, decode_temporal]);
/**
 * Decodes a protobuf CreateGauge message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisIncentivesMsgCreateGaugeResponse}
 */
export const decodeOsmosisIncentivesMsgCreateGaugeResponse = (atu8_payload) => decode_protobuf(atu8_payload);
/**
 * Decodes a protobuf AddToGauge message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisIncentivesMsgAddToGauge}
 */
export const decodeOsmosisIncentivesMsgAddToGauge = (atu8_payload) => decode_protobuf(atu8_payload, [5, 3, 0], [0, 0, decode_coin]);
/**
 * Decodes a protobuf AddToGauge message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisIncentivesMsgAddToGaugeResponse}
 */
export const decodeOsmosisIncentivesMsgAddToGaugeResponse = (atu8_payload) => decode_protobuf(atu8_payload);
/**
 * Decodes a protobuf CreateGroup message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisIncentivesMsgCreateGroup}
 */
export const decodeOsmosisIncentivesMsgCreateGroup = (atu8_payload) => decode_protobuf(atu8_payload, [0, 3, 5, 2], [decode_coin]);
/**
 * Decodes a protobuf CreateGroup message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisIncentivesMsgCreateGroupResponse}
 */
export const decodeOsmosisIncentivesMsgCreateGroupResponse = (atu8_payload) => decode_protobuf(atu8_payload, [3]);
/**
 * Destructures the fields of a {@link OsmosisIncentivesMsgCreateGauge} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: is_perpetual - shows if it's a perpetual or non-perpetual gauge Non-perpetual gauges distribute their tokens equally per epoch while the gauge is in the active period. Perpetual gauges distribute all their tokens at a single time and only distribute their tokens again once the gauge is refilled
 *   - 1: owner - the address of gauge creator
 *   - 2: distribute_to - show which lock the gauge should distribute to by time duration or by timestamp
 *   - 3: coins - coin(s) to be distributed by the gauge
 *   - 4: start_time - the distribution start time
 *   - 5: num_epochs_paid_over - the number of epochs distribution will be completed over
 *   - 6: pool_id - the ID of the pool that the gauge is meant to be associated with. if pool_id is set, then the "QueryCondition.LockQueryType" must be "NoLock" with all other fields of the "QueryCondition.LockQueryType" struct unset, including "QueryCondition.Denom". However, note that, internally, the empty string in "QueryCondition.Denom" ends up being overwritten with incentivestypes.NoLockExternalGaugeDenom(<pool-id>) so that the gauges associated with a pool can be queried by this prefix if needed.
 */
export const destructOsmosisIncentivesMsgCreateGauge = (g_struct) => [g_struct.is_perpetual, g_struct.owner, g_struct.distribute_to, g_struct.coins, parse_timestamp(g_struct.start_time), g_struct.num_epochs_paid_over, g_struct.pool_id];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_OSMOSIS_INCENTIVES_MSG_CREATE_GAUGE = '/osmosis.incentives.MsgCreateGauge';
/**
 * Destructures the fields of a {@link OsmosisIncentivesMsgCreateGaugeResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 */
export const destructOsmosisIncentivesMsgCreateGaugeResponse = (g_struct) => [];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_OSMOSIS_INCENTIVES_MSG_CREATE_GAUGE_RESPONSE = '/osmosis.incentives.MsgCreateGaugeResponse';
/**
 * Destructures the fields of a {@link OsmosisIncentivesMsgAddToGauge} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: owner - the gauge owner's address
 *   - 1: gauge_id - the ID of gauge that rewards are getting added to
 *   - 2: rewards - the coin(s) to add to gauge
 */
export const destructOsmosisIncentivesMsgAddToGauge = (g_struct) => [g_struct.owner, g_struct.gauge_id, g_struct.rewards];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_OSMOSIS_INCENTIVES_MSG_ADD_TO_GAUGE = '/osmosis.incentives.MsgAddToGauge';
/**
 * Destructures the fields of a {@link OsmosisIncentivesMsgAddToGaugeResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 */
export const destructOsmosisIncentivesMsgAddToGaugeResponse = (g_struct) => [];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_OSMOSIS_INCENTIVES_MSG_ADD_TO_GAUGE_RESPONSE = '/osmosis.incentives.MsgAddToGaugeResponse';
/**
 * Destructures the fields of a {@link OsmosisIncentivesMsgCreateGroup} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: coins - the provided coins that the group will distribute
 *   - 1: num_epochs_paid_over - the number of epochs distribution will be completed in. 0 means it's perpetual
 *   - 2: owner - the group owner's address
 *   - 3: pool_ids - the IDs of pools that the group is comprised of
 */
export const destructOsmosisIncentivesMsgCreateGroup = (g_struct) => [g_struct.coins, g_struct.num_epochs_paid_over, g_struct.owner, g_struct.pool_ids];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_OSMOSIS_INCENTIVES_MSG_CREATE_GROUP = '/osmosis.incentives.MsgCreateGroup';
/**
 * Destructures the fields of a {@link OsmosisIncentivesMsgCreateGroupResponse} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: group_id - the ID of the group that is created from this msg
 */
export const destructOsmosisIncentivesMsgCreateGroupResponse = (g_struct) => [g_struct.group_id];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_OSMOSIS_INCENTIVES_MSG_CREATE_GROUP_RESPONSE = '/osmosis.incentives.MsgCreateGroupResponse';
//# sourceMappingURL=tx.js.map