import type { WeakUint64Str, WeakAccountAddr, SlimCoin, CwUint64, CwAccountAddr } from '@solar-republic/types';
import type { Encoded, Opt, WeakTimestampStr, WeakDurationStr } from '../../../api/types.js';
import type { CosmosBaseCoin } from '../../cosmos/base/v1beta1/coin.js';
export type EncodedOsmosisLockupPeriodLock = Encoded<'/osmosis.lockup.PeriodLock'>;
export type EncodedOsmosisLockupQueryCondition = Encoded<'/osmosis.lockup.QueryCondition'>;
export type EncodedOsmosisLockupSyntheticLock = Encoded<'/osmosis.lockup.SyntheticLock'>;
/**
 * Encodes a `PeriodLock` protobuf message: a single lock unit by period defined by the x/lockup module. It's a record of a locked coin at a specific time. It stores owner, duration, unlock time and the number of coins locked. A state of a period lock is created upon lock creation, and deleted once the lock has been matured after the `duration` has passed since unbonding started.
 * @param sg_ID - `ID`: the unique id of the lock. The ID of the lock is decided upon lock creation, incrementing by 1 for every lock.
 * @param sa_owner - `owner`: Owner is the account address of the lock owner. Only the owner can modify the state of the lock.
 * @param xt_duration - `duration`: Duration is the time needed for a lock to mature after unlocking has started.
 * @param xt_end_time - `end_time`: EndTime refers to the time at which the lock would mature and get deleted. This value is first initialized when an unlock has started for the lock, end time being block time + duration.
 * @param a_coins - `coins`: Coins are the tokens locked within the lock, kept in the module account.
 * @param sa_reward_receiver - `reward_receiver_address`: Reward Receiver Address is the address that would be receiving rewards for the incentives for the lock. This is set to owner by default and can be changed via separate msg.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisLockupPeriodLock: (sg_ID?: Opt<WeakUint64Str>, sa_owner?: Opt<WeakAccountAddr>, xt_duration?: Opt<number>, xt_end_time?: Opt<number>, a_coins?: Opt<SlimCoin[]>, sa_reward_receiver?: Opt<WeakAccountAddr>) => EncodedOsmosisLockupPeriodLock;
/**
 * Encodes a `QueryCondition` protobuf message: a struct used for querying locks upon different conditions. Duration field and timestamp fields could be optional, depending on the LockQueryType.
 * @param xc_lock_query_type - `lock_query_type`: LockQueryType is a type of lock query, ByLockDuration | ByLockTime
 * @param s_denom - `denom`: Denom represents the token denomination we are looking to lock up
 * @param xt_duration - `duration`: Duration is used to query locks with longer duration than the specified duration. Duration field must not be nil when the lock query type is `ByLockDuration`.
 * @param xt_timestamp - `timestamp`: Timestamp is used by locks started before the specified duration. Timestamp field must not be nil when the lock query type is `ByLockTime`. Querying locks with timestamp is currently not implemented.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisLockupQueryCondition: (xc_lock_query_type?: Opt<ProtoEnumOsmosisLockupLockQueryType>, s_denom?: Opt<string>, xt_duration?: Opt<number>, xt_timestamp?: Opt<number>) => EncodedOsmosisLockupQueryCondition;
/**
 * Encodes a `SyntheticLock` protobuf message: creating virtual lockup where new denom is combination of original denom and synthetic suffix. At the time of synthetic lockup creation and deletion, accumulation store is also being updated and on querier side, they can query as freely as native lockup.
 * @param sg_underlying_lock_id - `underlying_lock_id`: Underlying Lock ID is the underlying native lock's id for this synthetic lockup. A synthetic lock MUST have an underlying lock.
 * @param s_synth_denom - `synth_denom`: SynthDenom is the synthetic denom that is a combination of gamm share + bonding status + validator address.
 * @param xt_end_time - `end_time`: used for unbonding synthetic lockups, for active synthetic lockups, this value is set to uninitialized value
 * @param xt_duration - `duration`: Duration is the duration for a synthetic lock to mature at the point of unbonding has started.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeOsmosisLockupSyntheticLock: (sg_underlying_lock_id?: Opt<WeakUint64Str>, s_synth_denom?: Opt<string>, xt_end_time?: Opt<number>, xt_duration?: Opt<number>) => EncodedOsmosisLockupSyntheticLock;
/**
 * A decoded protobuf PeriodLock message
 *
 * Tuple where:
 *   - 0: ID - the unique id of the lock. The ID of the lock is decided upon lock creation, incrementing by 1 for every lock.
 *   - 1: owner - Owner is the account address of the lock owner. Only the owner can modify the state of the lock.
 *   - 2: duration - Duration is the time needed for a lock to mature after unlocking has started.
 *   - 3: end_time - EndTime refers to the time at which the lock would mature and get deleted. This value is first initialized when an unlock has started for the lock, end time being block time + duration.
 *   - 4: coins - Coins are the tokens locked within the lock, kept in the module account.
 *   - 5: reward_receiver_address - Reward Receiver Address is the address that would be receiving rewards for the incentives for the lock. This is set to owner by default and can be changed via separate msg.
 */
export type DecodedOsmosisLockupPeriodLock = [
    sg_ID?: CwUint64,
    sa_owner?: CwAccountAddr,
    a_duration?: [
        string,
        number
    ],
    a_end_time?: [
        string,
        number
    ],
    a_coins?: [
        string,
        string
    ][],
    sa_reward_receiver?: CwAccountAddr
];
/**
 * Decodes a protobuf PeriodLock message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisLockupPeriodLock}
 */
export declare const decodeOsmosisLockupPeriodLock: (atu8_payload: Uint8Array) => DecodedOsmosisLockupPeriodLock;
/**
 * A decoded protobuf QueryCondition message
 *
 * Tuple where:
 *   - 0: lock_query_type - LockQueryType is a type of lock query, ByLockDuration | ByLockTime
 *   - 1: denom - Denom represents the token denomination we are looking to lock up
 *   - 2: duration - Duration is used to query locks with longer duration than the specified duration. Duration field must not be nil when the lock query type is `ByLockDuration`.
 *   - 3: timestamp - Timestamp is used by locks started before the specified duration. Timestamp field must not be nil when the lock query type is `ByLockTime`. Querying locks with timestamp is currently not implemented.
 */
export type DecodedOsmosisLockupQueryCondition = [
    xc_lock_query_type?: ProtoEnumOsmosisLockupLockQueryType,
    s_denom?: string,
    a_duration?: [
        string,
        number
    ],
    a_timestamp?: [
        string,
        number
    ]
];
/**
 * Decodes a protobuf QueryCondition message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisLockupQueryCondition}
 */
export declare const decodeOsmosisLockupQueryCondition: (atu8_payload: Uint8Array) => DecodedOsmosisLockupQueryCondition;
/**
 * A decoded protobuf SyntheticLock message
 *
 * Tuple where:
 *   - 0: underlying_lock_id - Underlying Lock ID is the underlying native lock's id for this synthetic lockup. A synthetic lock MUST have an underlying lock.
 *   - 1: synth_denom - SynthDenom is the synthetic denom that is a combination of gamm share + bonding status + validator address.
 *   - 2: end_time - used for unbonding synthetic lockups, for active synthetic lockups, this value is set to uninitialized value
 *   - 3: duration - Duration is the duration for a synthetic lock to mature at the point of unbonding has started.
 */
export type DecodedOsmosisLockupSyntheticLock = [
    sg_underlying_lock_id?: CwUint64,
    s_synth_denom?: string,
    a_end_time?: [
        string,
        number
    ],
    a_duration?: [
        string,
        number
    ]
];
/**
 * Decodes a protobuf SyntheticLock message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisLockupSyntheticLock}
 */
export declare const decodeOsmosisLockupSyntheticLock: (atu8_payload: Uint8Array) => DecodedOsmosisLockupSyntheticLock;
/**
 * Destructures the fields of a {@link OsmosisLockupQueryCondition} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: lock_query_type - LockQueryType is a type of lock query, ByLockDuration | ByLockTime
 *   - 1: denom - Denom represents the token denomination we are looking to lock up
 *   - 2: duration - Duration is used to query locks with longer duration than the specified duration. Duration field must not be nil when the lock query type is `ByLockDuration`.
 *   - 3: timestamp - Timestamp is used by locks started before the specified duration. Timestamp field must not be nil when the lock query type is `ByLockTime`. Querying locks with timestamp is currently not implemented.
 */
export declare const destructOsmosisLockupQueryCondition: (g_struct: OsmosisLockupQueryCondition) => [lock_query_type?: JsonEnumOsmosisLockupLockQueryType, denom?: string, duration?: number, timestamp?: number];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_LOCKUP_QUERY_CONDITION = "/osmosis.lockup.QueryCondition";
/**
 * JSON serialization of `osmosis.lockup.QueryCondition` - a struct used for querying locks upon different conditions. Duration field and timestamp fields could be optional, depending on the LockQueryType.
 */
export type OsmosisLockupQueryCondition = {
    lock_query_type?: JsonEnumOsmosisLockupLockQueryType | undefined;
    denom?: string | undefined;
    duration?: WeakDurationStr | undefined;
    timestamp?: WeakTimestampStr | undefined;
};
/**
 * Destructures the fields of a {@link OsmosisLockupSyntheticLock} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: underlying_lock_id - Underlying Lock ID is the underlying native lock's id for this synthetic lockup. A synthetic lock MUST have an underlying lock.
 *   - 1: synth_denom - SynthDenom is the synthetic denom that is a combination of gamm share + bonding status + validator address.
 *   - 2: end_time - used for unbonding synthetic lockups, for active synthetic lockups, this value is set to uninitialized value
 *   - 3: duration - Duration is the duration for a synthetic lock to mature at the point of unbonding has started.
 */
export declare const destructOsmosisLockupSyntheticLock: (g_struct: OsmosisLockupSyntheticLock) => [underlying_lock_id?: CwUint64, synth_denom?: string, end_time?: number, duration?: number];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_LOCKUP_SYNTHETIC_LOCK = "/osmosis.lockup.SyntheticLock";
/**
 * JSON serialization of `osmosis.lockup.SyntheticLock` - creating virtual lockup where new denom is combination of original denom and synthetic suffix. At the time of synthetic lockup creation and deletion, accumulation store is also being updated and on querier side, they can query as freely as native lockup.
 */
export type OsmosisLockupSyntheticLock = {
    underlying_lock_id?: CwUint64 | undefined;
    synth_denom?: string | undefined;
    end_time?: WeakTimestampStr | undefined;
    duration?: WeakDurationStr | undefined;
};
/**
 * Destructures the fields of a {@link OsmosisLockupPeriodLock} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: ID - the unique id of the lock. The ID of the lock is decided upon lock creation, incrementing by 1 for every lock.
 *   - 1: owner - Owner is the account address of the lock owner. Only the owner can modify the state of the lock.
 *   - 2: duration - Duration is the time needed for a lock to mature after unlocking has started.
 *   - 3: end_time - EndTime refers to the time at which the lock would mature and get deleted. This value is first initialized when an unlock has started for the lock, end time being block time + duration.
 *   - 4: coins - Coins are the tokens locked within the lock, kept in the module account.
 *   - 5: reward_receiver_address - Reward Receiver Address is the address that would be receiving rewards for the incentives for the lock. This is set to owner by default and can be changed via separate msg.
 */
export declare const destructOsmosisLockupPeriodLock: (g_struct: OsmosisLockupPeriodLock) => [ID?: CwUint64, owner?: CwAccountAddr, duration?: number, end_time?: number, coins?: CosmosBaseCoin[], reward_receiver_address?: CwAccountAddr];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_OSMOSIS_LOCKUP_PERIOD_LOCK = "/osmosis.lockup.PeriodLock";
/**
 * JSON serialization of `osmosis.lockup.PeriodLock` - a single lock unit by period defined by the x/lockup module. It's a record of a locked coin at a specific time. It stores owner, duration, unlock time and the number of coins locked. A state of a period lock is created upon lock creation, and deleted once the lock has been matured after the `duration` has passed since unbonding started.
 */
export type OsmosisLockupPeriodLock = {
    ID?: CwUint64 | undefined;
    owner?: CwAccountAddr | undefined;
    duration?: WeakDurationStr | undefined;
    end_time?: WeakTimestampStr | undefined;
    coins?: CosmosBaseCoin[] | undefined;
    reward_receiver_address?: CwAccountAddr | undefined;
};
/**
 * Protobuf enum value for `osmosis.lockup.LockQueryType`.
 *
 * **ByDuration** -
 *
 * Belongs to enum type {@link ProtoEnumOsmosisLockupLockQueryType}
 */
export declare const XC_PROTO_OSMOSIS_LOCKUP_ByDuration = 0;
/**
 * JSON enum value for `osmosis.lockup.LockQueryType`.
 *
 * **ByDuration** -
 *
 * Belongs to enum type {@link JsonEnumOsmosisLockupLockQueryType}
 */
export declare const SI_JSON_OSMOSIS_LOCKUP_ByDuration = "ByDuration";
/**
 * Protobuf enum value for `osmosis.lockup.LockQueryType`.
 *
 * **ByTime** -
 *
 * Belongs to enum type {@link ProtoEnumOsmosisLockupLockQueryType}
 */
export declare const XC_PROTO_OSMOSIS_LOCKUP_ByTime = 1;
/**
 * JSON enum value for `osmosis.lockup.LockQueryType`.
 *
 * **ByTime** -
 *
 * Belongs to enum type {@link JsonEnumOsmosisLockupLockQueryType}
 */
export declare const SI_JSON_OSMOSIS_LOCKUP_ByTime = "ByTime";
/**
 * Protobuf enum value for `osmosis.lockup.LockQueryType`.
 *
 * **NoLock** -
 *
 * Belongs to enum type {@link ProtoEnumOsmosisLockupLockQueryType}
 */
export declare const XC_PROTO_OSMOSIS_LOCKUP_NoLock = 2;
/**
 * JSON enum value for `osmosis.lockup.LockQueryType`.
 *
 * **NoLock** -
 *
 * Belongs to enum type {@link JsonEnumOsmosisLockupLockQueryType}
 */
export declare const SI_JSON_OSMOSIS_LOCKUP_NoLock = "NoLock";
/**
 * Protobuf enum value for `osmosis.lockup.LockQueryType`.
 *
 * **ByGroup** -
 *
 * Belongs to enum type {@link ProtoEnumOsmosisLockupLockQueryType}
 */
export declare const XC_PROTO_OSMOSIS_LOCKUP_ByGroup = 3;
/**
 * JSON enum value for `osmosis.lockup.LockQueryType`.
 *
 * **ByGroup** -
 *
 * Belongs to enum type {@link JsonEnumOsmosisLockupLockQueryType}
 */
export declare const SI_JSON_OSMOSIS_LOCKUP_ByGroup = "ByGroup";
/**
 * Raw protobuf enum values for `osmosis.lockup.LockQueryType` to be used when passing to an encoder or comparing to a decoded protobuf value.
 *
 * Values:
 *   - {@link XC_PROTO_OSMOSIS_LOCKUP_ByDuration}
 *   - {@link XC_PROTO_OSMOSIS_LOCKUP_ByTime}
 *   - {@link XC_PROTO_OSMOSIS_LOCKUP_NoLock}
 *   - {@link XC_PROTO_OSMOSIS_LOCKUP_ByGroup}
 */
export type ProtoEnumOsmosisLockupLockQueryType = typeof XC_PROTO_OSMOSIS_LOCKUP_ByDuration | typeof XC_PROTO_OSMOSIS_LOCKUP_ByTime | typeof XC_PROTO_OSMOSIS_LOCKUP_NoLock | typeof XC_PROTO_OSMOSIS_LOCKUP_ByGroup;
/**
 * JSON enum values for `osmosis.lockup.LockQueryType` to be used when passing to a gRPC-gateway method or comparing to a response value
 *
 * Values:
 *   - {@link SI_JSON_OSMOSIS_LOCKUP_ByDuration}
 *   - {@link SI_JSON_OSMOSIS_LOCKUP_ByTime}
 *   - {@link SI_JSON_OSMOSIS_LOCKUP_NoLock}
 *   - {@link SI_JSON_OSMOSIS_LOCKUP_ByGroup}
 */
export type JsonEnumOsmosisLockupLockQueryType = typeof SI_JSON_OSMOSIS_LOCKUP_ByDuration | typeof SI_JSON_OSMOSIS_LOCKUP_ByTime | typeof SI_JSON_OSMOSIS_LOCKUP_NoLock | typeof SI_JSON_OSMOSIS_LOCKUP_ByGroup;
/**
 * Maps a protobuf enum int value for `osmosis.lockup.LockQueryType` to is JSON equivalent enum string value
 */
export declare const ProtoToJsonEnumOsmosisLockupLockQueryType: Record<ProtoEnumOsmosisLockupLockQueryType, JsonEnumOsmosisLockupLockQueryType>;
/**
 * Maps a JSON enum string value for `osmosis.lockup.LockQueryType` to is protobuf equivalent enum int value
 */
export declare const JsonToProtoEnumOsmosisLockupLockQueryType: Record<JsonEnumOsmosisLockupLockQueryType, ProtoEnumOsmosisLockupLockQueryType>;
