import { parse_duration, parse_timestamp } from '../../../api/json.js';
import { decode_protobuf, decode_coin, decode_temporal } from '../../../api/protobuf-reader.js';
import { Protobuf, temporal, coins } from '../../../api/protobuf-writer.js';
/**
 * Encodes a `PeriodLock` protobuf message: a single lock unit by period defined by the x/lockup module. It's a record of a locked coin at a specific time. It stores owner, duration, unlock time and the number of coins locked. A state of a period lock is created upon lock creation, and deleted once the lock has been matured after the `duration` has passed since unbonding started.
 * @param sg_ID - `ID`: the unique id of the lock. The ID of the lock is decided upon lock creation, incrementing by 1 for every lock.
 * @param sa_owner - `owner`: Owner is the account address of the lock owner. Only the owner can modify the state of the lock.
 * @param xt_duration - `duration`: Duration is the time needed for a lock to mature after unlocking has started.
 * @param xt_end_time - `end_time`: EndTime refers to the time at which the lock would mature and get deleted. This value is first initialized when an unlock has started for the lock, end time being block time + duration.
 * @param a_coins - `coins`: Coins are the tokens locked within the lock, kept in the module account.
 * @param sa_reward_receiver - `reward_receiver_address`: Reward Receiver Address is the address that would be receiving rewards for the incentives for the lock. This is set to owner by default and can be changed via separate msg.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeOsmosisLockupPeriodLock = (sg_ID, sa_owner, xt_duration, xt_end_time, a_coins, sa_reward_receiver) => Protobuf() // ...
    .g(sg_ID) // uint64 ID = 1
    .s(sa_owner) // string owner = 2
    .b(temporal(xt_duration)) // Duration duration = 3
    .b(temporal(xt_end_time)) // Timestamp end_time = 4
    .B(coins(a_coins)) // Coin[] coins = 5
    .s(sa_reward_receiver) // string reward_receiver_address = 6
    .o;
/**
 * Encodes a `QueryCondition` protobuf message: a struct used for querying locks upon different conditions. Duration field and timestamp fields could be optional, depending on the LockQueryType.
 * @param xc_lock_query_type - `lock_query_type`: LockQueryType is a type of lock query, ByLockDuration | ByLockTime
 * @param s_denom - `denom`: Denom represents the token denomination we are looking to lock up
 * @param xt_duration - `duration`: Duration is used to query locks with longer duration than the specified duration. Duration field must not be nil when the lock query type is `ByLockDuration`.
 * @param xt_timestamp - `timestamp`: Timestamp is used by locks started before the specified duration. Timestamp field must not be nil when the lock query type is `ByLockTime`. Querying locks with timestamp is currently not implemented.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeOsmosisLockupQueryCondition = (xc_lock_query_type, s_denom, xt_duration, xt_timestamp) => Protobuf() // ...
    .v(xc_lock_query_type) // LockQueryType lock_query_type = 1
    .s(s_denom) // string denom = 2
    .b(temporal(xt_duration)) // Duration duration = 3
    .b(temporal(xt_timestamp)) // Timestamp timestamp = 4
    .o;
/**
 * Encodes a `SyntheticLock` protobuf message: creating virtual lockup where new denom is combination of original denom and synthetic suffix. At the time of synthetic lockup creation and deletion, accumulation store is also being updated and on querier side, they can query as freely as native lockup.
 * @param sg_underlying_lock_id - `underlying_lock_id`: Underlying Lock ID is the underlying native lock's id for this synthetic lockup. A synthetic lock MUST have an underlying lock.
 * @param s_synth_denom - `synth_denom`: SynthDenom is the synthetic denom that is a combination of gamm share + bonding status + validator address.
 * @param xt_end_time - `end_time`: used for unbonding synthetic lockups, for active synthetic lockups, this value is set to uninitialized value
 * @param xt_duration - `duration`: Duration is the duration for a synthetic lock to mature at the point of unbonding has started.
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeOsmosisLockupSyntheticLock = (sg_underlying_lock_id, s_synth_denom, xt_end_time, xt_duration) => Protobuf() // ...
    .g(sg_underlying_lock_id) // uint64 underlying_lock_id = 1
    .s(s_synth_denom) // string synth_denom = 2
    .b(temporal(xt_end_time)) // Timestamp end_time = 3
    .b(temporal(xt_duration)) // Duration duration = 4
    .o;
/**
 * Decodes a protobuf PeriodLock message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisLockupPeriodLock}
 */
export const decodeOsmosisLockupPeriodLock = (atu8_payload) => decode_protobuf(atu8_payload, [3, 5, [3, 1], [3, 1], 0, 5], [0, 0, decode_temporal, decode_temporal, decode_coin]);
/**
 * Decodes a protobuf QueryCondition message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisLockupQueryCondition}
 */
export const decodeOsmosisLockupQueryCondition = (atu8_payload) => decode_protobuf(atu8_payload, [1, 5, [3, 1], [3, 1]], [0, 0, decode_temporal, decode_temporal]);
/**
 * Decodes a protobuf SyntheticLock message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisLockupSyntheticLock}
 */
export const decodeOsmosisLockupSyntheticLock = (atu8_payload) => decode_protobuf(atu8_payload, [3, 5, [3, 1], [3, 1]], [0, 0, decode_temporal, decode_temporal]);
/**
 * Destructures the fields of a {@link OsmosisLockupQueryCondition} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: lock_query_type - LockQueryType is a type of lock query, ByLockDuration | ByLockTime
 *   - 1: denom - Denom represents the token denomination we are looking to lock up
 *   - 2: duration - Duration is used to query locks with longer duration than the specified duration. Duration field must not be nil when the lock query type is `ByLockDuration`.
 *   - 3: timestamp - Timestamp is used by locks started before the specified duration. Timestamp field must not be nil when the lock query type is `ByLockTime`. Querying locks with timestamp is currently not implemented.
 */
export const destructOsmosisLockupQueryCondition = (g_struct) => [g_struct.lock_query_type, g_struct.denom, parse_duration(g_struct.duration), parse_timestamp(g_struct.timestamp)];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_OSMOSIS_LOCKUP_QUERY_CONDITION = '/osmosis.lockup.QueryCondition';
/**
 * Destructures the fields of a {@link OsmosisLockupSyntheticLock} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: underlying_lock_id - Underlying Lock ID is the underlying native lock's id for this synthetic lockup. A synthetic lock MUST have an underlying lock.
 *   - 1: synth_denom - SynthDenom is the synthetic denom that is a combination of gamm share + bonding status + validator address.
 *   - 2: end_time - used for unbonding synthetic lockups, for active synthetic lockups, this value is set to uninitialized value
 *   - 3: duration - Duration is the duration for a synthetic lock to mature at the point of unbonding has started.
 */
export const destructOsmosisLockupSyntheticLock = (g_struct) => [g_struct.underlying_lock_id, g_struct.synth_denom, parse_timestamp(g_struct.end_time), parse_duration(g_struct.duration)];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_OSMOSIS_LOCKUP_SYNTHETIC_LOCK = '/osmosis.lockup.SyntheticLock';
/**
 * Destructures the fields of a {@link OsmosisLockupPeriodLock} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: ID - the unique id of the lock. The ID of the lock is decided upon lock creation, incrementing by 1 for every lock.
 *   - 1: owner - Owner is the account address of the lock owner. Only the owner can modify the state of the lock.
 *   - 2: duration - Duration is the time needed for a lock to mature after unlocking has started.
 *   - 3: end_time - EndTime refers to the time at which the lock would mature and get deleted. This value is first initialized when an unlock has started for the lock, end time being block time + duration.
 *   - 4: coins - Coins are the tokens locked within the lock, kept in the module account.
 *   - 5: reward_receiver_address - Reward Receiver Address is the address that would be receiving rewards for the incentives for the lock. This is set to owner by default and can be changed via separate msg.
 */
export const destructOsmosisLockupPeriodLock = (g_struct) => [g_struct.ID, g_struct.owner, parse_duration(g_struct.duration), parse_timestamp(g_struct.end_time), g_struct.coins, g_struct.reward_receiver_address];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_OSMOSIS_LOCKUP_PERIOD_LOCK = '/osmosis.lockup.PeriodLock';
/**
 * Protobuf enum value for `osmosis.lockup.LockQueryType`.
 *
 * **ByDuration** -
 *
 * Belongs to enum type {@link ProtoEnumOsmosisLockupLockQueryType}
 */
export const XC_PROTO_OSMOSIS_LOCKUP_ByDuration = 0;
/**
 * JSON enum value for `osmosis.lockup.LockQueryType`.
 *
 * **ByDuration** -
 *
 * Belongs to enum type {@link JsonEnumOsmosisLockupLockQueryType}
 */
export const SI_JSON_OSMOSIS_LOCKUP_ByDuration = 'ByDuration';
/**
 * Protobuf enum value for `osmosis.lockup.LockQueryType`.
 *
 * **ByTime** -
 *
 * Belongs to enum type {@link ProtoEnumOsmosisLockupLockQueryType}
 */
export const XC_PROTO_OSMOSIS_LOCKUP_ByTime = 1;
/**
 * JSON enum value for `osmosis.lockup.LockQueryType`.
 *
 * **ByTime** -
 *
 * Belongs to enum type {@link JsonEnumOsmosisLockupLockQueryType}
 */
export const SI_JSON_OSMOSIS_LOCKUP_ByTime = 'ByTime';
/**
 * Protobuf enum value for `osmosis.lockup.LockQueryType`.
 *
 * **NoLock** -
 *
 * Belongs to enum type {@link ProtoEnumOsmosisLockupLockQueryType}
 */
export const XC_PROTO_OSMOSIS_LOCKUP_NoLock = 2;
/**
 * JSON enum value for `osmosis.lockup.LockQueryType`.
 *
 * **NoLock** -
 *
 * Belongs to enum type {@link JsonEnumOsmosisLockupLockQueryType}
 */
export const SI_JSON_OSMOSIS_LOCKUP_NoLock = 'NoLock';
/**
 * Protobuf enum value for `osmosis.lockup.LockQueryType`.
 *
 * **ByGroup** -
 *
 * Belongs to enum type {@link ProtoEnumOsmosisLockupLockQueryType}
 */
export const XC_PROTO_OSMOSIS_LOCKUP_ByGroup = 3;
/**
 * JSON enum value for `osmosis.lockup.LockQueryType`.
 *
 * **ByGroup** -
 *
 * Belongs to enum type {@link JsonEnumOsmosisLockupLockQueryType}
 */
export const SI_JSON_OSMOSIS_LOCKUP_ByGroup = 'ByGroup';
/**
 * Maps a protobuf enum int value for `osmosis.lockup.LockQueryType` to is JSON equivalent enum string value
 */
export const ProtoToJsonEnumOsmosisLockupLockQueryType = {
    [XC_PROTO_OSMOSIS_LOCKUP_ByDuration]: SI_JSON_OSMOSIS_LOCKUP_ByDuration,
    [XC_PROTO_OSMOSIS_LOCKUP_ByTime]: SI_JSON_OSMOSIS_LOCKUP_ByTime,
    [XC_PROTO_OSMOSIS_LOCKUP_NoLock]: SI_JSON_OSMOSIS_LOCKUP_NoLock,
    [XC_PROTO_OSMOSIS_LOCKUP_ByGroup]: SI_JSON_OSMOSIS_LOCKUP_ByGroup,
};
/**
 * Maps a JSON enum string value for `osmosis.lockup.LockQueryType` to is protobuf equivalent enum int value
 */
export const JsonToProtoEnumOsmosisLockupLockQueryType = {
    [SI_JSON_OSMOSIS_LOCKUP_ByDuration]: XC_PROTO_OSMOSIS_LOCKUP_ByDuration,
    [SI_JSON_OSMOSIS_LOCKUP_ByTime]: XC_PROTO_OSMOSIS_LOCKUP_ByTime,
    [SI_JSON_OSMOSIS_LOCKUP_NoLock]: XC_PROTO_OSMOSIS_LOCKUP_NoLock,
    [SI_JSON_OSMOSIS_LOCKUP_ByGroup]: XC_PROTO_OSMOSIS_LOCKUP_ByGroup,
};
//# sourceMappingURL=lock.js.map