/*
* ================================
*     GENERATED FILE WARNING
* Do not edit this file manually.
* ================================
*/
import { decode_protobuf } from '../../../../api/protobuf-reader.js';
import { Protobuf, any } from '../../../../api/protobuf-writer.js';
import { decodeOsmosisPoolincentivesDistrRecord } from './incentives.js';
/**
 * Encodes a `ReplacePoolIncentivesProposal` protobuf message wrapped in the `Any` container: a gov Content type for updating the pool incentives. If a ReplacePoolIncentivesProposal passes, the proposal’s records override the existing DistrRecords set in the module. Each record has a specified gauge id and weight, and the incentives are distributed to each gauge according to weight/total_weight. The incentives are put in the fee pool and it is allocated to gauges and community pool by the DistrRecords configuration. Note that gaugeId=0 represents the community pool.
 * @param s_title - `title`:
 * @param s_description - `description`:
 * @param a_records - `records`:
 * @returns a strongly subtyped Uint8Array representing an `Any` protobuf message
 */
export const anyReplacePoolIncentivesProposal = (s_title, s_description, a_records) => any('/osmosis.poolincentives.v1beta1.ReplacePoolIncentivesProposal', Protobuf() // ...
    .s(s_title) // string title = 1
    .s(s_description) // string description = 2
    .B(a_records) // DistrRecord[] records = 3
    .o);
/**
 * Encodes a `UpdatePoolIncentivesProposal` protobuf message wrapped in the `Any` container: For example: if the existing DistrRecords were: [(Gauge 0, 5), (Gauge 1, 6), (Gauge 2, 6)] An UpdatePoolIncentivesProposal includes [(Gauge 1, 0), (Gauge 2, 4), (Gauge 3, 10)] This would delete Gauge 1, Edit Gauge 2, and Add Gauge 3 The result DistrRecords in state would be: [(Gauge 0, 5), (Gauge 2, 4), (Gauge 3, 10)]
 * @param s_title - `title`:
 * @param s_description - `description`:
 * @param a_records - `records`:
 * @returns a strongly subtyped Uint8Array representing an `Any` protobuf message
 */
export const anyUpdatePoolIncentivesProposal = (s_title, s_description, a_records) => any('/osmosis.poolincentives.v1beta1.UpdatePoolIncentivesProposal', Protobuf() // ...
    .s(s_title) // string title = 1
    .s(s_description) // string description = 2
    .B(a_records) // DistrRecord[] records = 3
    .o);
/**
 * Encodes a `ReplacePoolIncentivesProposal` protobuf message: a gov Content type for updating the pool incentives. If a ReplacePoolIncentivesProposal passes, the proposal’s records override the existing DistrRecords set in the module. Each record has a specified gauge id and weight, and the incentives are distributed to each gauge according to weight/total_weight. The incentives are put in the fee pool and it is allocated to gauges and community pool by the DistrRecords configuration. Note that gaugeId=0 represents the community pool.
 * @param s_title - `title`:
 * @param s_description - `description`:
 * @param a_records - `records`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeOsmosisPoolincentivesReplacePoolIncentivesProposal = (s_title, s_description, a_records) => Protobuf() // ...
    .s(s_title) // string title = 1
    .s(s_description) // string description = 2
    .B(a_records) // DistrRecord[] records = 3
    .o;
/**
 * Encodes a `UpdatePoolIncentivesProposal` protobuf message: For example: if the existing DistrRecords were: [(Gauge 0, 5), (Gauge 1, 6), (Gauge 2, 6)] An UpdatePoolIncentivesProposal includes [(Gauge 1, 0), (Gauge 2, 4), (Gauge 3, 10)] This would delete Gauge 1, Edit Gauge 2, and Add Gauge 3 The result DistrRecords in state would be: [(Gauge 0, 5), (Gauge 2, 4), (Gauge 3, 10)]
 * @param s_title - `title`:
 * @param s_description - `description`:
 * @param a_records - `records`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeOsmosisPoolincentivesUpdatePoolIncentivesProposal = (s_title, s_description, a_records) => Protobuf() // ...
    .s(s_title) // string title = 1
    .s(s_description) // string description = 2
    .B(a_records) // DistrRecord[] records = 3
    .o;
/**
 * Decodes a protobuf ReplacePoolIncentivesProposal message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisPoolincentivesReplacePoolIncentivesProposal}
 */
export const decodeOsmosisPoolincentivesReplacePoolIncentivesProposal = (atu8_payload) => decode_protobuf(atu8_payload, [5, 5, 0], [0, 0, decodeOsmosisPoolincentivesDistrRecord]);
/**
 * Decodes a protobuf UpdatePoolIncentivesProposal message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedOsmosisPoolincentivesUpdatePoolIncentivesProposal}
 */
export const decodeOsmosisPoolincentivesUpdatePoolIncentivesProposal = (atu8_payload) => decode_protobuf(atu8_payload, [5, 5, 0], [0, 0, decodeOsmosisPoolincentivesDistrRecord]);
/**
 * Destructures the fields of a {@link OsmosisPoolincentivesReplacePoolIncentivesProposal} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: title -
 *   - 1: description -
 *   - 2: records -
 */
export const destructOsmosisPoolincentivesReplacePoolIncentivesProposal = (g_struct) => [g_struct.title, g_struct.description, g_struct.records];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_OSMOSIS_POOLINCENTIVES_REPLACE_POOL_INCENTIVES_PROPOSAL = '/osmosis.poolincentives.v1beta1.ReplacePoolIncentivesProposal';
/**
 * Destructures the fields of a {@link OsmosisPoolincentivesUpdatePoolIncentivesProposal} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: title -
 *   - 1: description -
 *   - 2: records -
 */
export const destructOsmosisPoolincentivesUpdatePoolIncentivesProposal = (g_struct) => [g_struct.title, g_struct.description, g_struct.records];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_OSMOSIS_POOLINCENTIVES_UPDATE_POOL_INCENTIVES_PROPOSAL = '/osmosis.poolincentives.v1beta1.UpdatePoolIncentivesProposal';
//# sourceMappingURL=gov.js.map