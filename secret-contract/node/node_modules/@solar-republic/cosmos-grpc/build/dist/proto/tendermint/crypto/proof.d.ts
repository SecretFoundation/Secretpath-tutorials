import type { WeakInt64Str, CwInt64, CwBase64 } from '@solar-republic/types';
import type { Encoded, Opt } from '../../../api/types.js';
export type EncodedTendermintCryptoProof = Encoded<'/tendermint.crypto.Proof'>;
export type EncodedTendermintCryptoValueOp = Encoded<'/tendermint.crypto.ValueOp'>;
export type EncodedTendermintCryptoDominoOp = Encoded<'/tendermint.crypto.DominoOp'>;
export type EncodedTendermintCryptoProofOp = Encoded<'/tendermint.crypto.ProofOp'>;
export type EncodedTendermintCryptoProofOps = Encoded<'/tendermint.crypto.ProofOps'>;
/**
 * Encodes a `Proof` protobuf message:
 * @param sg_total - `total`:
 * @param sg_index - `index`:
 * @param atu8_leaf_hash - `leaf_hash`:
 * @param a_aunts - `aunts`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeTendermintCryptoProof: (sg_total?: Opt<WeakInt64Str>, sg_index?: Opt<WeakInt64Str>, atu8_leaf_hash?: Opt<Uint8Array>, a_aunts?: Opt<Uint8Array[]>) => EncodedTendermintCryptoProof;
/**
 * Encodes a `ValueOp` protobuf message:
 * @param atu8_key - `key`: Encoded in ProofOp.Key.
 * @param g_proof - `proof`: To encode in ProofOp.Data
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeTendermintCryptoValueOp: (atu8_key?: Opt<Uint8Array>, atu8_proof?: Opt<Encoded<'/tendermint.crypto.Proof'>>) => EncodedTendermintCryptoValueOp;
/**
 * Encodes a `DominoOp` protobuf message:
 * @param s_key - `key`:
 * @param s_input - `input`:
 * @param s_output - `output`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeTendermintCryptoDominoOp: (s_key?: Opt<string>, s_input?: Opt<string>, s_output?: Opt<string>) => EncodedTendermintCryptoDominoOp;
/**
 * Encodes a `ProofOp` protobuf message: defines an operation used for calculating Merkle root The data could be arbitrary format, providing nessecary data for example neighbouring node hash
 * @param s_type - `type`:
 * @param atu8_key - `key`:
 * @param atu8_data - `data`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeTendermintCryptoProofOp: (s_type?: Opt<string>, atu8_key?: Opt<Uint8Array>, atu8_data?: Opt<Uint8Array>) => EncodedTendermintCryptoProofOp;
/**
 * Encodes a `ProofOps` protobuf message: Merkle proof defined by the list of ProofOps
 * @param a_ops - `ops`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export declare const encodeTendermintCryptoProofOps: (a_ops?: Opt<Encoded<'/tendermint.crypto.ProofOp'>[]>) => EncodedTendermintCryptoProofOps;
/**
 * A decoded protobuf Proof message
 *
 * Tuple where:
 *   - 0: total -
 *   - 1: index -
 *   - 2: leaf_hash -
 *   - 3: aunts -
 */
export type DecodedTendermintCryptoProof = [
    sg_total?: CwInt64,
    sg_index?: CwInt64,
    atu8_leaf_hash?: Uint8Array,
    a_aunts?: Uint8Array[]
];
/**
 * Decodes a protobuf Proof message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedTendermintCryptoProof}
 */
export declare const decodeTendermintCryptoProof: (atu8_payload: Uint8Array) => DecodedTendermintCryptoProof;
/**
 * A decoded protobuf ValueOp message
 *
 * Tuple where:
 *   - 0: key - Encoded in ProofOp.Key.
 *   - 1: proof - To encode in ProofOp.Data
 */
export type DecodedTendermintCryptoValueOp = [
    atu8_key?: Uint8Array,
    a_proof?: DecodedTendermintCryptoProof
];
/**
 * Decodes a protobuf ValueOp message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedTendermintCryptoValueOp}
 */
export declare const decodeTendermintCryptoValueOp: (atu8_payload: Uint8Array) => DecodedTendermintCryptoValueOp;
/**
 * A decoded protobuf DominoOp message
 *
 * Tuple where:
 *   - 0: key -
 *   - 1: input -
 *   - 2: output -
 */
export type DecodedTendermintCryptoDominoOp = [
    s_key?: string,
    s_input?: string,
    s_output?: string
];
/**
 * Decodes a protobuf DominoOp message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedTendermintCryptoDominoOp}
 */
export declare const decodeTendermintCryptoDominoOp: (atu8_payload: Uint8Array) => DecodedTendermintCryptoDominoOp;
/**
 * A decoded protobuf ProofOp message
 *
 * Tuple where:
 *   - 0: type -
 *   - 1: key -
 *   - 2: data -
 */
export type DecodedTendermintCryptoProofOp = [
    s_type?: string,
    atu8_key?: Uint8Array,
    atu8_data?: Uint8Array
];
/**
 * Decodes a protobuf ProofOp message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedTendermintCryptoProofOp}
 */
export declare const decodeTendermintCryptoProofOp: (atu8_payload: Uint8Array) => DecodedTendermintCryptoProofOp;
/**
 * A decoded protobuf ProofOps message
 *
 * Alias for: ops -
 */
export type DecodedTendermintCryptoProofOps = [
    a_ops?: DecodedTendermintCryptoProofOp[]
];
/**
 * Decodes a protobuf ProofOps message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedTendermintCryptoProofOps}
 */
export declare const decodeTendermintCryptoProofOps: (atu8_payload: Uint8Array) => DecodedTendermintCryptoProofOps;
/**
 * Destructures the fields of a {@link TendermintCryptoProof} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: total -
 *   - 1: index -
 *   - 2: leaf_hash -
 *   - 3: aunts -
 */
export declare const destructTendermintCryptoProof: (g_struct: TendermintCryptoProof) => [total?: CwInt64, index?: CwInt64, leaf_hash?: Uint8Array, aunts?: Uint8Array[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_TENDERMINT_CRYPTO_PROOF = "/tendermint.crypto.Proof";
/**
 * JSON serialization of `tendermint.crypto.Proof` -
 */
export type TendermintCryptoProof = {
    total?: CwInt64 | undefined;
    index?: CwInt64 | undefined;
    leaf_hash?: CwBase64 | undefined;
    aunts?: CwBase64[] | undefined;
};
/**
 * Destructures the fields of a {@link TendermintCryptoValueOp} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: key - Encoded in ProofOp.Key.
 *   - 1: proof - To encode in ProofOp.Data
 */
export declare const destructTendermintCryptoValueOp: (g_struct: TendermintCryptoValueOp) => [key?: Uint8Array, proof?: TendermintCryptoProof];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_TENDERMINT_CRYPTO_VALUE_OP = "/tendermint.crypto.ValueOp";
/**
 * JSON serialization of `tendermint.crypto.ValueOp` -
 */
export type TendermintCryptoValueOp = {
    key?: CwBase64 | undefined;
    proof?: TendermintCryptoProof | undefined;
};
/**
 * Destructures the fields of a {@link TendermintCryptoDominoOp} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: key -
 *   - 1: input -
 *   - 2: output -
 */
export declare const destructTendermintCryptoDominoOp: (g_struct: TendermintCryptoDominoOp) => [key?: string, input?: string, output?: string];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_TENDERMINT_CRYPTO_DOMINO_OP = "/tendermint.crypto.DominoOp";
/**
 * JSON serialization of `tendermint.crypto.DominoOp` -
 */
export type TendermintCryptoDominoOp = {
    key?: string | undefined;
    input?: string | undefined;
    output?: string | undefined;
};
/**
 * Destructures the fields of a {@link TendermintCryptoProofOp} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: type -
 *   - 1: key -
 *   - 2: data -
 */
export declare const destructTendermintCryptoProofOp: (g_struct: TendermintCryptoProofOp) => [type_?: string, key?: Uint8Array, data?: Uint8Array];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_TENDERMINT_CRYPTO_PROOF_OP = "/tendermint.crypto.ProofOp";
/**
 * JSON serialization of `tendermint.crypto.ProofOp` - defines an operation used for calculating Merkle root The data could be arbitrary format, providing nessecary data for example neighbouring node hash
 */
export type TendermintCryptoProofOp = {
    type?: string | undefined;
    key?: CwBase64 | undefined;
    data?: CwBase64 | undefined;
};
/**
 * Destructures the fields of a {@link TendermintCryptoProofOps} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: ops -
 */
export declare const destructTendermintCryptoProofOps: (g_struct: TendermintCryptoProofOps) => [ops?: TendermintCryptoProofOp[]];
/**
 * Message type string constant
 */
export declare const SI_MESSAGE_TYPE_TENDERMINT_CRYPTO_PROOF_OPS = "/tendermint.crypto.ProofOps";
/**
 * JSON serialization of `tendermint.crypto.ProofOps` - Merkle proof defined by the list of ProofOps
 */
export type TendermintCryptoProofOps = {
    ops?: TendermintCryptoProofOp[] | undefined;
};
