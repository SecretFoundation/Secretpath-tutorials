import { decode_protobuf } from '../../../api/protobuf-reader.js';
import { Protobuf, map } from '../../../api/protobuf-writer.js';
import { safe_base64_to_bytes } from '../../../api/util.js';
/**
 * Encodes a `Proof` protobuf message:
 * @param sg_total - `total`:
 * @param sg_index - `index`:
 * @param atu8_leaf_hash - `leaf_hash`:
 * @param a_aunts - `aunts`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeTendermintCryptoProof = (sg_total, sg_index, atu8_leaf_hash, a_aunts) => Protobuf() // ...
    .g(sg_total) // int32 total = 1
    .g(sg_index) // int32 index = 2
    .b(atu8_leaf_hash) // bytes leaf_hash = 3
    .B(a_aunts) // bytes[] aunts = 4
    .o;
/**
 * Encodes a `ValueOp` protobuf message:
 * @param atu8_key - `key`: Encoded in ProofOp.Key.
 * @param g_proof - `proof`: To encode in ProofOp.Data
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeTendermintCryptoValueOp = (atu8_key, atu8_proof) => Protobuf() // ...
    .b(atu8_key) // bytes key = 1
    .b(atu8_proof) // Proof proof = 2
    .o;
/**
 * Encodes a `DominoOp` protobuf message:
 * @param s_key - `key`:
 * @param s_input - `input`:
 * @param s_output - `output`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeTendermintCryptoDominoOp = (s_key, s_input, s_output) => Protobuf() // ...
    .s(s_key) // string key = 1
    .s(s_input) // string input = 2
    .s(s_output) // string output = 3
    .o;
/**
 * Encodes a `ProofOp` protobuf message: defines an operation used for calculating Merkle root The data could be arbitrary format, providing nessecary data for example neighbouring node hash
 * @param s_type - `type`:
 * @param atu8_key - `key`:
 * @param atu8_data - `data`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeTendermintCryptoProofOp = (s_type, atu8_key, atu8_data) => Protobuf() // ...
    .s(s_type) // string type = 1
    .b(atu8_key) // bytes key = 2
    .b(atu8_data) // bytes data = 3
    .o;
/**
 * Encodes a `ProofOps` protobuf message: Merkle proof defined by the list of ProofOps
 * @param a_ops - `ops`:
 * @returns a strongly subtyped Uint8Array protobuf message
 */
export const encodeTendermintCryptoProofOps = (a_ops) => Protobuf() // ...
    .B(a_ops) // ProofOp[] ops = 1
    .o;
/**
 * Decodes a protobuf Proof message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedTendermintCryptoProof}
 */
export const decodeTendermintCryptoProof = (atu8_payload) => decode_protobuf(atu8_payload, [3, 3, 1, 0]);
/**
 * Decodes a protobuf ValueOp message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedTendermintCryptoValueOp}
 */
export const decodeTendermintCryptoValueOp = (atu8_payload) => decode_protobuf(atu8_payload, [1, 1], [0, decodeTendermintCryptoProof]);
/**
 * Decodes a protobuf DominoOp message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedTendermintCryptoDominoOp}
 */
export const decodeTendermintCryptoDominoOp = (atu8_payload) => decode_protobuf(atu8_payload, [5, 5, 5]);
/**
 * Decodes a protobuf ProofOp message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedTendermintCryptoProofOp}
 */
export const decodeTendermintCryptoProofOp = (atu8_payload) => decode_protobuf(atu8_payload, [5, 1, 1]);
/**
 * Decodes a protobuf ProofOps message
 * @param atu8_payload - raw bytes to decode
 * @returns a {@link DecodedTendermintCryptoProofOps}
 */
export const decodeTendermintCryptoProofOps = (atu8_payload) => decode_protobuf(atu8_payload, [0], [decodeTendermintCryptoProofOp]);
/**
 * Destructures the fields of a {@link TendermintCryptoProof} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: total -
 *   - 1: index -
 *   - 2: leaf_hash -
 *   - 3: aunts -
 */
export const destructTendermintCryptoProof = (g_struct) => [g_struct.total, g_struct.index, safe_base64_to_bytes(g_struct.leaf_hash), map(g_struct.aunts, safe_base64_to_bytes)];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_TENDERMINT_CRYPTO_PROOF = '/tendermint.crypto.Proof';
/**
 * Destructures the fields of a {@link TendermintCryptoValueOp} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: key - Encoded in ProofOp.Key.
 *   - 1: proof - To encode in ProofOp.Data
 */
export const destructTendermintCryptoValueOp = (g_struct) => [safe_base64_to_bytes(g_struct.key), g_struct.proof];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_TENDERMINT_CRYPTO_VALUE_OP = '/tendermint.crypto.ValueOp';
/**
 * Destructures the fields of a {@link TendermintCryptoDominoOp} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: key -
 *   - 1: input -
 *   - 2: output -
 */
export const destructTendermintCryptoDominoOp = (g_struct) => [g_struct.key, g_struct.input, g_struct.output];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_TENDERMINT_CRYPTO_DOMINO_OP = '/tendermint.crypto.DominoOp';
/**
 * Destructures the fields of a {@link TendermintCryptoProofOp} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: type -
 *   - 1: key -
 *   - 2: data -
 */
export const destructTendermintCryptoProofOp = (g_struct) => [g_struct.type, safe_base64_to_bytes(g_struct.key), safe_base64_to_bytes(g_struct.data)];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_TENDERMINT_CRYPTO_PROOF_OP = '/tendermint.crypto.ProofOp';
/**
 * Destructures the fields of a {@link TendermintCryptoProofOps} JSON message into a tuple of parsed ES equivalents
 * @param g_struct - the JSON message
 * @returns a tuple where:
 *   - 0: ops -
 */
export const destructTendermintCryptoProofOps = (g_struct) => [g_struct.ops];
/**
 * Message type string constant
 */
export const SI_MESSAGE_TYPE_TENDERMINT_CRYPTO_PROOF_OPS = '/tendermint.crypto.ProofOps';
//# sourceMappingURL=proof.js.map