/**
 * Provides wrapper for Uint8Array intended to hold sensitive data such as private key material.
 * Rather than allowing key material to possibly outlive garbage collection in memory by using hex strings
 * or BigInt during cryptographic operations, use Uint8Array in order to wipe all intermediate values by
 * zeroing them out (overwriting all bytes with 0x00) immediately after use. Except for the `wipe` method,
 * instances are immutable.
 *
 * Some may wonder why not use Uint32Array for more efficient computations with native 32-bit ints.
 * In Chromium, `Smi` can store 31 bit signed ints on 32-bit archs, and 32 bit signed ints on 64-bit archs.
 * <https://source.chromium.org/chromium/v8/v8.git/+/main:src/objects/smi.h;l=17;drc=bf096ec960eee18c916b4bcb4d96be7b39f732ad>
 * <https://stackoverflow.com/a/57426773/1641160>
 * Meaning that 32-bit unsigned integers will always end up being "boxed", i.e., represented by pointers to
 * heap objects in V8, leading to the potential for more sensitive garbage ending up in deallocated RAM.
 *
 * As for Uint16Array, another issue arises. It would require the use of DataView to control for endianness
 * on the platform, which _may_ introduce temporary values (some of which may allocate on the heap) depending
 * on the runtime implementation. However, this has not been thoroughly investigated and indeed may offer the
 * same protection as Uint8Array with potentially more efficient computations on big-endian platforms (little-
 * endian platforms may or may not see performance hit from DataView's endian conversion).
 *
 * In conclusion, Uint8Array offers the safest byte-wise calculations since all integer operations on their
 * values are most likely (given all options) to never leave CPU registers and thus never end up in the heap.
 *
 * For sake of simplicity and in the interest of avoiding human errors, the `other` instance passed to any
 * method must have exactly the same byte length.
 * For example:
 * ```ts
 * const a = Uint8Array(32); a[0] = 0x01;
 * const b = Uint8Array(64); b[0] = 0x03;
 * const sa = new SensitiveBytes(a);
 * const sb = new SensitiveBytes(b);
 * sa.xor(sb);  // throws Error since `sa` is 32 bytes while `sb` is 64 bytes
 * ```
 *
 * One consideration that should be made is whether timing attacks are part of the user's threat model.
 * It is unclear how, or even if, the methods employed by this data structure make it susceptible to
 * timing attacks.
 */
export declare class SensitiveBytes {
    private readonly _atu8_data;
    /**
     * Generate a cryptographically random value having the given number of bytes.
     */
    static random(nb_size: number): SensitiveBytes;
    /**
     * Convenience method for creating nil-initialized number of given size in bytes.
     */
    static empty(nb_size?: number): SensitiveBytes;
    /**
     * Create an instance around a `Uint8Array`
     * @param atu8_data the sensitive data source
     */
    constructor(_atu8_data: Uint8Array);
    /**
     * Getter for underyling buffers' byte length
     */
    get byteLength(): number;
    /**
     * Getter for this instance's data
     */
    get data(): Uint8Array;
    /**
     * Clone this instance so that it can be destroyed without affecting the clone.
     */
    clone(): SensitiveBytes;
    /**
     * Mutably clear the contents of this object and mark as destroyed.
     */
    wipe(): void;
    /**
     * Perform byte-by-byte XOR with other instance.
     */
    xor(kn_other: SensitiveBytes): SensitiveBytes;
    /**
     * Split a byte array into 'words' using the given delimiter
     * @param xb_value the delimiter value to split by
     * @returns list of words which will all be zeroed out when the parent instance is wiped
     */
    split(xb_value: number): Uint8Array[];
}
