import type { Required } from 'ts-toolbelt/out/Object/Required.js';
import type { WeakSecretAccAddr } from './types.js';
import type { JsonObject, Nilable } from '@blake.regalia/belt';
import type { SecretAccAddr, ContractInterface } from '@solar-republic/contractor';
import type { SecretComputeContractInfo } from '@solar-republic/cosmos-grpc/secret/compute/v1beta1/types';
import type { CwHexLower, SlimCoin, TrustedContextUrl } from '@solar-republic/types';
import { SecretWasm } from './secret-wasm.js';
export type KnownContractInfo = Required<SecretComputeContractInfo, 'code_id' | 'label'>;
/**
 * Stores intermediate values during the process of querying a Secret contract
 */
export interface SecretContractQueryIntermediates {
    /**
     * The nonce that was used to encrypt the query
     */
    n?: Uint8Array;
}
export type SecretContract<g_interface extends ContractInterface = ContractInterface> = {
    /**
     * URL of the LCD endpoint
     */
    lcd: TrustedContextUrl;
    /**
     * Contract address
     */
    addr: SecretAccAddr;
    /**
     * Contract's label, code id, and creator
     */
    info: KnownContractInfo;
    /**
     * Code hash
     */
    hash: CwHexLower;
    /**
     * the {@link SecretWasm} instance
     */
    wasm: SecretWasm;
    /**
     * Queries a contract and returns the parsed JSON response
     * @param h_query - the query JSON as an object
     * @returns the parsed response JSON object of a successful query
     * @throws a tuple of `[Response, string, JsonObject?]` where:
     * 	- 0: d_res - the {@link Response}` object
     * 	- 1: s_res - the response body as text
     *    - 2?: g_res - the parsed response response JSON if valid
     */
    query(h_query: JsonObject, g_out?: SecretContractQueryIntermediates): Promise<JsonObject>;
    /**
     * Construct a contract execution message
     * @param h_exec
     * @param sa_sender
     * @param a_funds
     * @returns
     */
    exec(h_exec: JsonObject, sa_sender: WeakSecretAccAddr, a_funds?: SlimCoin[]): Promise<[
        atu8_data: Uint8Array,
        atu8_nonce: Uint8Array
    ]>;
};
/**
 * Creates a low-level handle for a Secret Contract. Immediately queries the chain for the contract's code hash
 * and info unless already cached.
 *
 * The `query` and `exec` methods are not intended for general application use; projects should instead use
 * {@link query_secret_contract} and {@link exec_secret_contract}.
 * @param p_lcd
 * @param sa_contract
 * @param atu8_seed
 * @returns
 */
export declare const SecretContract: <g_interface extends {
    config: {
        all_executions?: import("@solar-republic/contractor").MethodDescriptor;
        default_execution_answer?: JsonObject<never>;
        all_queries?: import("@solar-republic/contractor").MethodDescriptor;
        snip52_channels?: import("@solar-republic/contractor").Snip52ChannelDict;
    };
    executions: JsonObject<never>;
    queries: JsonObject<never>;
} = {
    config: {
        all_executions?: import("@solar-republic/contractor").MethodDescriptor;
        default_execution_answer?: JsonObject<never>;
        all_queries?: import("@solar-republic/contractor").MethodDescriptor;
        snip52_channels?: import("@solar-republic/contractor").Snip52ChannelDict;
    };
    executions: JsonObject<never>;
    queries: JsonObject<never>;
}>(p_lcd: TrustedContextUrl, sa_contract: WeakSecretAccAddr, atu8_seed?: Nilable<Uint8Array>) => Promise<SecretContract<g_interface>>;
