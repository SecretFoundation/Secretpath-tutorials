import type { LcdRpcStruct, SlimAuthInfo, TypedAminoMsg, TypedStdSignDoc, WeakSecretAccAddr } from './types.js';
import type { Nilable } from '@blake.regalia/belt';
import type { ProtoEnumCosmosTxSigningSignMode } from '@solar-republic/cosmos-grpc/cosmos/tx/signing/v1beta1/signing';
import type { CwUint128, CwHexUpper, CwAccountAddr, TrustedContextUrl, SlimCoin, WeakUint128Str } from '@solar-republic/types';
import { type SignatureAndRecovery } from './secp256k1.js';
type Emptyable<s_type extends string> = s_type | '' | undefined;
export interface Wallet<s_hrp extends string = string> extends LcdRpcStruct {
    /**
     * Chain id
     */
    ref: string;
    /**
     * Bech32 account address
     */
    addr: CwAccountAddr<s_hrp>;
    /**
     * Secp256k1 Public Key in compressed 33-byte form
     */
    pk33: Uint8Array;
    /**
     * Signs a 32-byte message digest
     * @param atu8_hash - the message digest to sign
     * @param atu8_k - optional entropy to use (defaults to secure random 32 bytes)
     */
    sign(atu8_hash: Uint8Array, atu8_k?: Uint8Array): Promise<SignatureAndRecovery>;
}
/**
 * Convert a 33-byte canonical public key to a bech32-encoded string
 * @param atu8_pk_33 - 33-byte public key buffer
 * @param s_hrp - human-readable part of bech32-encoded address
 * @returns bech32-encoded address string
 */
export declare const pubkey_to_bech32: <s_hrp extends string>(atu8_pk_33: Uint8Array, s_hrp?: s_hrp) => Promise<CwAccountAddr<s_hrp>>;
/**
 * Creates a Secp256k1 wallet instance configured for a specific Cosmos chain and LCD/RPC endpoints,
 * capable of signing arbitrary message hashes.
 * @param atu8_sk - the private key
 * @param si_chain - chain identifier
 * @param p_lcd - the LCD endpoint URL (gRPC-gateway)
 * @param p_rpc - the RPC endpoint URL
 * @returns
 */
export declare const Wallet: <s_hrp extends string>(atu8_sk: Uint8Array, si_chain: string, p_lcd: TrustedContextUrl, p_rpc: TrustedContextUrl, s_hrp?: s_hrp) => Promise<Wallet<s_hrp>>;
/**
 * Fetches auth info for the account (account_number and sequence)
 */
export declare const auth: (g_wallet: Pick<Wallet, 'lcd' | 'addr'>, a_auth?: Nilable<SlimAuthInfo> | 0) => Promise<SlimAuthInfo>;
/**
 * Signs a set of Amino messages as part of a transaction
 * @param k_wallet - the {@link Wallet} instance
 * @param a_msgs - ordered list of {@link TypedAminoMsg}
 * @param a_fees - transaction fees to approve in the {@link SlimCoin} format
 * @param sg_limit - gas limit as a {@link WeakUint128Str}
 * @param a_auth - optional auth info to use in order to bypass an additional network request, in the {@link SlimAuthInfo} format
 * @param s_memo - optional public memo text to attach to the transaction
 * @param sa_granter - optional address of fee granter account, who will ultimately pay for the transaction fee
 * @param sa_payer - optional address of account to specify which signer account is responsible for the trasaction fee
 * @returns a tuple where:
 *   - 0: the raw signature bytes as a `Uint8Array`
 *   - 1: the signed doc as a {@link TypedStdSignDoc}
 */
export declare const sign_amino: <a_msgs extends TypedAminoMsg<string, import("@blake.regalia/belt").JsonObject<never>>[] = TypedAminoMsg<string, import("@blake.regalia/belt").JsonObject<never>>[], g_signed extends TypedStdSignDoc<a_msgs> = TypedStdSignDoc<a_msgs>>(k_wallet: Wallet, a_msgs: a_msgs, a_fees: SlimCoin[], sg_limit: WeakUint128Str, a_auth?: Nilable<SlimAuthInfo> | 0, s_memo?: string, sa_granter?: Emptyable<WeakSecretAccAddr>, sa_payer?: Emptyable<WeakSecretAccAddr>) => Promise<[atu8_signature: Uint8Array, g_signed: g_signed]>;
/**
 * Signs a set of Amino messages as part of a transaction
 * @param k_wallet - the {@link Wallet} instance
 * @param a_msgs - ordered list of {@link TypedAminoMsg}
 * @param a_fees - transaction fees to approve in the {@link SlimCoin} format
 * @param sg_limit - gas limit as a {@link WeakUint128Str}
 * @param a_auth - optional auth info to use in order to bypass an additional network request, in the {@link SlimAuthInfo} format
 * @param s_memo - optional public memo text to attach to the transaction
 * @param sa_granter - optional address of fee granter account, who will ultimately pay for the transaction fee
 * @param sa_payer - optional address of account to specify which signer account is responsible for the trasaction fee
 * @returns a tuple where:
 *   - 0: the raw signature bytes as a `Uint8Array`
 *   - 1: the signed doc as a {@link TypedStdSignDoc}
 */
/**
 * Signs a set of protobuf-encoded messages (Direct mode)
 * @param k_wallet - the {@link Wallet} instance
 * @param atu8_auth - protobuf-encoded auth message
 * @param atu8_body - protobuf-encoded
 * @param sg_account
 * @returns
 */
export declare const sign_direct: (k_wallet: Wallet, atu8_auth: Uint8Array, atu8_body: Uint8Array, sg_account?: Nilable<WeakUint128Str>) => Promise<[atu8_signature: Uint8Array, atu8_signdoc: Uint8Array]>;
/**
 * Encodes a transaction
 *
 * @param xc_sign_mode
 * @param k_wallet
 * @param a_msgs
 * @param a_fees
 * @param sg_limit
 * @param a_auth
 * @param s_memo
 * @param sa_granter
 * @param sa_payer
 * @returns
 */
export declare const create_tx_body: (xc_sign_mode: ProtoEnumCosmosTxSigningSignMode, k_wallet: Parameters<typeof auth>[0] & Pick<Wallet, 'pk33'>, a_msgs: Uint8Array[], a_fees: SlimCoin[], sg_limit: WeakUint128Str, a_auth?: Nilable<SlimAuthInfo> | 0, s_memo?: string, sa_granter?: Emptyable<WeakSecretAccAddr>, sa_payer?: Emptyable<WeakSecretAccAddr>) => Promise<[atu8_auth: Uint8Array, atu8_body: Uint8Array, sg_account: Nilable<CwUint128>]>;
/**
 * Signs a message in DIRECT mode (protobuf encoding)
 * @param k_wallet
 * @param a_msgs
 * @param a_fees
 * @param sg_limit
 * @param sa_granter
 * @param sa_payer
 * @param s_memo
 * @param a_auth
 * @returns
 */
export declare const create_and_sign_tx_direct: (k_wallet: Wallet, a_msgs: Uint8Array[], a_fees: SlimCoin[], sg_limit: WeakUint128Str, a_auth?: Nilable<SlimAuthInfo> | 0, s_memo?: string, sa_granter?: Emptyable<WeakSecretAccAddr>, sa_payer?: Emptyable<WeakSecretAccAddr>) => Promise<[atu8_raw: Uint8Array, atu8_signdoc: Uint8Array, si_txn: CwHexUpper]>;
export {};
