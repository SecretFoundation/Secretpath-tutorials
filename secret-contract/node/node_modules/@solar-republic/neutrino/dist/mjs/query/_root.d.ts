import type { Dict, JsonObject } from '@blake.regalia/belt';
import type { Coin } from '@cosmjs/amino';
import type { SecretAccAddr, Uint128 } from '@solar-republic/contractor';
export interface AccountResponse {
    '@type': string;
    address: SecretAccAddr;
    pub_key: {
        '@type': '/cosmos.crypto.secp256k1.PubKey';
        key: string;
    };
    account_number: Uint128;
    sequence: Uint128;
}
export interface BasicAllowance {
    '@type': '/cosmos.feegrant.v1beta1.BasicAllowance';
    spend_limit: Coin[];
    expiration: string | null;
}
export interface PeriodicAllowance {
    '@type': '/cosmos.feegrant.v1beta1.PeriodicAllowance';
    basic: BasicAllowance | null;
    period: string | null;
}
export interface AllowanceResponse {
    granter: SecretAccAddr;
    grantee: SecretAccAddr;
    allowance: BasicAllowance;
}
export type RpcRequest<a_args extends any[] = []> = (...a_args: a_args) => [string] | [string, Dict];
export declare const SR_LCD_AUTH = "/cosmos/auth/v1beta1/";
export declare const SR_LCD_AUTHZ = "/cosmos/authz/v1beta1/";
export declare const SR_LCD_BANK = "/cosmos/bank/v1beta1/";
export declare const SR_LCD_COMPUTE = "/compute/v1beta1/";
export declare const SR_LCD_FEEGRANT = "/cosmos/feegrant/v1beta1/";
export declare const F_RPC_REQ_NO_ARGS: RpcRequest;
export type NetworkErrorDetails = [
    d_res: Response,
    sx_res: string,
    g_res?: JsonObject
];
/**
 * Submits a query to the LCD endpoint
 * @param f_req - the {@link RpcRequest `RpcRequest`}
 * @param f_res - a response-processing callback
 * @returns what `f_res` returned
 * @throws a tuple of `[Response, string, JsonObject?]` where:
 * 	- 0: d_res - the {@link Response `Response`} object
 * 	- 1: s_res - the response body as text
 *    - 2?: g_res - the parsed response response JSON if valid
*/
export declare const lcd_query: <a_args extends any[], w_parsed>(f_req: RpcRequest<a_args>, f_res: (g_response: any) => w_parsed) => (p_origin: string, ...a_args: a_args) => Promise<w_parsed>;
