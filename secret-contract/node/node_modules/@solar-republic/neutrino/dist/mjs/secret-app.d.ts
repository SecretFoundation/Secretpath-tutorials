import type { CreateQueryArgsAndAuthParams } from './inferencing.js';
import type { SecretContract } from './secret-contract.js';
import type { TxResultWrapper, WeakSecretAccAddr } from './types.js';
import type { Wallet } from './wallet.js';
import type { JsonObject } from '@blake.regalia/belt';
import type { ContractInterface } from '@solar-republic/contractor';
import type { SlimCoin } from '@solar-republic/types';
export declare const exec_fees: (xg_limit: bigint | `${bigint}`, x_gas_price: number, s_denom?: string) => [SlimCoin];
/**
 * Simple wrapper for querying and executing a Secret contract. Binds Wallet and SecretContract, as well
 * as an AuthSecret, gas price, and optional granter.
 */
export interface SecretApp<g_interface extends ContractInterface = ContractInterface> {
    price(xn_price: number): void;
    granter(sa_granter: WeakSecretAccAddr): void;
    /**
     * Query a Secret Contract method and automatically apply an auth secret if one is provided.
     * Additionally, unwrap the success response if one was returned.
     * @param si_method - which query method to invoke
     * @param h_args - the args value to pass in with the given query
     * @param z_auth - optional {@link AuthSecret} to perform an authenticated query
     * @returns tuple of `[JsonObject?, number, string, JsonObject?]` where:
     *  - [0]: `w_result?: JsonObject` - parsed & unwrapped contract result on success
     *  - [1]: `xc_code: number` - error code from chain, or non-OK HTTP status code from the LCD server.
     * 		A value of `0` indicates success.
     *  - [2]: `s_error: string` - error message from chain or HTTP response body
     *  - [3]: `h_answer?: JsonObject` - contract response as JSON object on success
     */
    query<h_variants extends ContractInterface.MsgAndAnswer<g_interface, 'queries'> = ContractInterface.MsgAndAnswer<g_interface, 'queries'>, si_method extends Extract<keyof h_variants, string> = Extract<keyof h_variants, string>, g_variant extends h_variants[si_method] = h_variants[si_method]>(si_method: si_method, ...[h_args, z_auth]: CreateQueryArgsAndAuthParams<h_variants, si_method, ContractInterface extends g_interface ? 1 : 0>): Promise<[
        w_result: g_variant['response'] | undefined,
        xc_code: number,
        s_error: string,
        h_answer?: g_variant['answer']
    ]>;
    /**
     * Executes the contract with given method, args, and limit. Automatically determines fee at set gas price.
     * Automatically uses granter if set on instance using {@link SecretApp.granter}.
     * @param si_method - which execution method to invoke
     * @param h_exec - the args value to pass in with the given execution
     * @param xg_limit - the gas limit to set for the transaction
     * @param a_funds - optional Array of {@link SlimCoin} of funds to send into the contract with the tx
     * @param s_memo - optional memo field
     * @returns tuple of `[number, string, TxResponse?]`
     *  - [0]: `w_result?: JsonValue` - parsed & unwrapped contract result on success
     *  - [1]: `xc_code: number` - error code from chain, or non-OK HTTP status code from the LCD server.
     * 		A value of `0` indicates success.
     *  - [2]: `s_res: string` - message text. on success, will be the contract's response as a JSON string.
     * 		on error, will be either the error string from HTTP response text, chain error message,
     * 		or contract error as a JSON string.
     *  - [3]: `g_tx_res?: `{@link TxResponse} - on success, the parsed transaction response JSON object
     *  - [4]: `si_txn?: string` - the transaction hash if a broadcast attempt was made
     *
     * @throws a {@link BroadcastResultErr}
     */
    exec<h_group extends ContractInterface.MsgAndAnswer<g_interface, 'executions'>, as_methods extends Extract<keyof h_group, string>>(si_method: as_methods, h_exec: ContractInterface extends g_interface ? JsonObject : h_group[as_methods]['msg'], xg_limit: bigint, a_funds?: SlimCoin[], s_memo?: string): Promise<[
        w_result: h_group[as_methods]['response'] | undefined,
        xc_code: number,
        s_response: string,
        g_tx: TxResultWrapper['TxResult'] | undefined,
        si_txn: string | undefined
    ]>;
}
export declare const SecretApp: <g_interface extends {
    config: {
        all_executions?: import("@solar-republic/contractor").MethodDescriptor;
        default_execution_answer?: JsonObject<never>;
        all_queries?: import("@solar-republic/contractor").MethodDescriptor;
        snip52_channels?: import("@solar-republic/contractor").Snip52ChannelDict;
    };
    executions: JsonObject<never>;
    queries: JsonObject<never>;
}>(k_wallet: Wallet<'secret'>, k_contract: SecretContract<g_interface>, xn_gas_price: number, sa_granter?: WeakSecretAccAddr) => SecretApp<g_interface>;
