import { buffer } from '@blake.regalia/belt';
import { emsimp } from './emsimp.js';
import { map_wasm_exports, map_wasm_imports } from '../gen/wasm.js';
const S_TAG_ECDH = 'ECDH: ';
const S_TAG_ECDSA_VERIFY = 'ECDSA verify: ';
const S_REASON_INVALID_SK = 'Invalid private key';
const S_REASON_INVALID_PK = 'Invalid public key';
const random_32 = () => crypto.getRandomValues(buffer(32));
/**
 * Creates a new instance of the secp256k1 WASM and returns its ES wrapper
 * @param z_src - a Response containing the WASM binary, a Promise that resolves to one,
 * 	or the raw bytes to the WASM binary as a {@link BufferSource}
 * @returns the wrapper API
 */
export const WasmSecp256k1 = async (z_src) => {
    // prepare the runtime
    const [g_imports, f_bind_heap] = emsimp(map_wasm_imports, 'wasm-secp256k1');
    // prep the wasm module
    let d_wasm;
    // instantiate wasm binary by streaming the response bytes
    if (z_src instanceof Response || z_src instanceof Promise) {
        d_wasm = await WebAssembly.instantiateStreaming(z_src, g_imports);
    }
    // instantiate using raw bianry
    else {
        d_wasm = await WebAssembly.instantiate(z_src, g_imports);
    }
    await WebAssembly.instantiate(z_src, g_imports);
    // create the libsecp256k1 exports struct
    const g_wasm = map_wasm_exports(d_wasm.instance.exports);
    // bind the heap and ref its view(s)
    const [, ATU8_HEAP, ATU32_HEAP] = f_bind_heap(g_wasm.memory);
    // call into the wasm module's init method
    g_wasm.init();
    // ref malloc function
    const malloc = g_wasm.malloc;
    const ip_sk = malloc(32 /* ByteLens.PRIVATE_KEY */);
    const ip_ent = malloc(32 /* ByteLens.NONCE_ENTROPY */);
    const ip_seed = malloc(32 /* ByteLens.RANDOM_SEED */);
    const ip_sk_shared = malloc(32 /* ByteLens.ECDH_SHARED_SK */);
    const ip_msg_hash = malloc(32 /* ByteLens.MSG_HASH */);
    // scratch spaces
    const ip_sig_scratch = malloc(64 /* ByteLens.ECDSA_SIG_COMPACT */);
    const ip_pk_scratch = malloc(65 /* ByteLens.PUBLIC_KEY_MAX */);
    // library handle: secp256k1_pubkey
    const ip_pk_lib = malloc(64 /* ByteLens.PUBLIC_KEY_LIB */);
    // library handle: secp256k1_ecdsa_signature
    const ip_sig_lib = malloc(64 /* ByteLens.ECDSA_SIG_LIB */);
    // create a reusable context
    const ip_ctx = g_wasm.context_create(513 /* Flags.CONTEXT_SIGN */ | 257 /* Flags.CONTEXT_VERIFY */);
    // length specifier
    const ip_len = g_wasm.malloc(4);
    const ip32_len = ip_len >> 2;
    /**
     * Pads the given input data before copying it into the heap at the given location; throws if input
     * data exceeds expected size
     * @param atu8_data - the data to put into program memory
     * @param ib_write - the starting byte position to write into
     * @param nb_size - the size of the region
     */
    const put_bytes = (atu8_data, ip_write, nb_size) => {
        const atu8_buffer = buffer(nb_size);
        atu8_buffer.set(atu8_data);
        ATU8_HEAP.set(atu8_buffer, ip_write);
    };
    /**
     * Randomizes the context for better protection against CPU side-channel attacks
     */
    const randomize_context = () => {
        // put random seed bytes into place
        put_bytes(random_32(), ip_seed, 32 /* ByteLens.RANDOM_SEED */);
        // randomize context
        if (1 /* BinaryResult.SUCCESS */ !== g_wasm.context_randomize(ip_ctx, ip_seed)) {
            throw Error('Failed to randomize context');
        }
    };
    /**
     * Parses the input public key in preparation for use by some method
     * @param atu8_sk - the private key
     * @returns `true` on success, `false` otherwise
     */
    const parse_pubkey = (atu8_pk) => {
        // copy input bytes into place
        put_bytes(atu8_pk, ip_pk_scratch, 65 /* ByteLens.PUBLIC_KEY_MAX */);
        // parse public key
        return 1 /* BinaryResult.SUCCESS */ === g_wasm.ec_pubkey_parse(ip_ctx, ip_pk_lib, ip_pk_scratch, atu8_pk.length);
    };
    /**
     * Puts the given private key into program memory, runs the given callback, then zeroes out the key
     * @param atu8_sk - the private key
     * @param f_use - callback to use the key
     * @returns whatever the callback returns
     */
    const with_sk = (atu8_sk, f_use) => {
        // prep callback return
        let w_return;
        // in case of any exception..
        try {
            // copy input bytes into place
            put_bytes(atu8_sk, ip_sk, 32 /* ByteLens.PRIVATE_KEY */);
            // use private key
            w_return = f_use();
        }
        finally {
            // zero-out private key
            ATU8_HEAP.fill(0, ip_sk, ip_sk + 32 /* ByteLens.PRIVATE_KEY */);
        }
        // forward result
        return w_return;
    };
    /**
     * Serializes the public key
     * @param b_uncompressed - whether or not the result should be in compressed form (33 bytes) or not (65 bytes)
     * @returns the public key as a buffer
     */
    const get_pk = (b_uncompressed = false) => {
        // output length of public key
        const nb_pk = b_uncompressed ? 65 /* ByteLens.PUBLIC_KEY_UNCOMPRESSED */ : 33 /* ByteLens.PUBLIC_KEY_COMPRESSED */;
        // // set target output length in little endian for WASM runtime
        // DV_HEAP.setUint32(ip_len, nb_pk, true);
        // set target output length (the Web has basically become LE-only)
        ATU32_HEAP[ip32_len] = nb_pk;
        // prep compression flag
        const xm_compression = b_uncompressed ? 2 /* Flags.COMPRESSION_UNCOMPRESSED */ : 258 /* Flags.COMPRESSION_COMPRESSED */;
        // serialize public key
        g_wasm.ec_pubkey_serialize(ip_ctx, ip_pk_scratch, ip_len, ip_pk_lib, xm_compression);
        // extract result
        return ATU8_HEAP.slice(ip_pk_scratch, ip_pk_scratch + nb_pk);
    };
    /**
     * Asserts the private key is valid
     * @param atu8_sk - the private key (32 bytes)
     * @returns the valid private key, or throws if the caller somehow discovered an invalid sk
     */
    const valid_sk = (atu8_sk) => {
        // while using the private key, assert the length is valid and the point falls within curve order
        if (with_sk(atu8_sk, () => 32 /* ByteLens.PRIVATE_KEY */ !== atu8_sk.length || 1 /* BinaryResult.SUCCESS */ !== g_wasm.ec_seckey_verify(ip_ctx, ip_sk))) {
            throw Error(S_REASON_INVALID_SK);
        }
        // return the valid sk
        return atu8_sk;
    };
    return {
        gen_sk: () => valid_sk(crypto.getRandomValues(buffer(32 /* ByteLens.PRIVATE_KEY */))),
        valid_sk,
        sk_to_pk(atu8_sk, b_uncompressed = false) {
            // randomize context
            randomize_context();
            // while using the private key, compute its corresponding public key; from the docs:
            if (1 /* BinaryResult.SUCCESS */ !== with_sk(atu8_sk, () => g_wasm.ec_pubkey_create(ip_ctx, ip_pk_lib, ip_sk))) {
                throw Error('sk_to_pk: ' + S_REASON_INVALID_SK);
            }
            // serialize the public key
            return get_pk(b_uncompressed);
        },
        sign(atu8_sk, atu8_hash, atu8_ent = random_32()) {
            // randomize context
            randomize_context();
            // copy message hash bytes into place
            put_bytes(atu8_hash, ip_msg_hash, 32 /* ByteLens.MSG_HASH */);
            // copy entropy bytes into place
            put_bytes(atu8_ent, ip_ent, 32 /* ByteLens.NONCE_ENTROPY */);
            // while using the private key, sign the given message hash
            if (1 /* BinaryResult.SUCCESS */ !== with_sk(atu8_sk, () => g_wasm.ecdsa_sign(ip_ctx, ip_sig_lib, ip_msg_hash, ip_sk, 0, ip_ent))) {
                throw Error('ECDSA sign: ' + S_REASON_INVALID_SK);
            }
            // serialize the signature in compact form as `r || s` (64 bytes)
            g_wasm.ecdsa_signature_serialize_compact(ip_ctx, ip_sig_scratch, ip_sig_lib);
            // return serialized signature
            return ATU8_HEAP.slice(ip_sig_scratch, ip_sig_scratch + 64 /* ByteLens.ECDSA_SIG_COMPACT */);
        },
        verify(atu8_signature, atu8_hash, atu8_pk) {
            // copy signature bytes into place
            put_bytes(atu8_signature, ip_sig_scratch, 64 /* ByteLens.ECDSA_SIG_COMPACT */);
            // copy message hash bytes into place
            put_bytes(atu8_hash, ip_msg_hash, 32 /* ByteLens.MSG_HASH */);
            // parse the public key
            if (!parse_pubkey(atu8_pk)) {
                throw Error(S_TAG_ECDSA_VERIFY + S_REASON_INVALID_PK);
            }
            // parse the signature
            if (1 /* BinaryResult.SUCCESS */ !== g_wasm.ecdsa_signature_parse_compact(ip_ctx, ip_sig_lib, ip_sig_scratch)) {
                throw Error(S_TAG_ECDSA_VERIFY + 'Unparseable signature');
            }
            // verify the signature
            return 1 /* BinaryResult.SUCCESS */ === g_wasm.ecdsa_verify(ip_ctx, ip_sig_lib, ip_msg_hash, ip_pk_lib);
        },
        ecdh(atu8_sk, atu8_pk) {
            // parse public key
            if (!parse_pubkey(atu8_pk))
                throw Error(S_TAG_ECDH + S_REASON_INVALID_PK);
            // start using private key
            return with_sk(atu8_sk, () => {
                // perform ecdh computation
                if (1 /* BinaryResult.SUCCESS */ !== g_wasm.ecdh(ip_ctx, ip_sk_shared, ip_pk_lib, ip_sk)) {
                    throw Error(S_TAG_ECDH + S_REASON_INVALID_SK);
                }
                // return copy of result bytes
                return ATU8_HEAP.slice(ip_sk_shared, ip_sk_shared + 32 /* ByteLens.ECDH_SHARED_SK */);
            });
        },
    };
};
//# sourceMappingURL=secp256k1.js.map